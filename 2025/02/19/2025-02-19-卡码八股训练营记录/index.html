<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/web-app-manifest-192x192.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-96x96.png">
  <link rel="mask-icon" href="/images/favicon/favicon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"souls5.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Day01介绍一下TCP&#x2F;IP模型和OSI模型的区别TCP&#x2F;IP 模型与 OSI 模型的区别    对比项 OSI 模型（七层） TCP&#x2F;IP 模型（四层）    层次划分 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 应用层、传输层、网络层、网络接口层   设计理念 理想化、理论性强，定义清晰的层次关系，每层独立 结合实际网络设计，更符合互联网协议">
<meta property="og:type" content="article">
<meta property="og:title" content="卡码八股训练营记录">
<meta property="og:url" content="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="不是不是">
<meta property="og:description" content="Day01介绍一下TCP&#x2F;IP模型和OSI模型的区别TCP&#x2F;IP 模型与 OSI 模型的区别    对比项 OSI 模型（七层） TCP&#x2F;IP 模型（四层）    层次划分 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 应用层、传输层、网络层、网络接口层   设计理念 理想化、理论性强，定义清晰的层次关系，每层独立 结合实际网络设计，更符合互联网协议">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/1.png">
<meta property="article:published_time" content="2025-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-12T06:49:55.080Z">
<meta property="article:author" content="间">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/1.png">

<link rel="canonical" href="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>卡码八股训练营记录 | 不是不是</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不是不是</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习、挣扎和一些无关紧要的琐事...大概</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          卡码八股训练营记录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-19T00:00:00+08:00">2025-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-12 14:49:55" itemprop="dateModified" datetime="2025-03-12T14:49:55+08:00">2025-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h3><h4 id="介绍一下TCP-IP模型和OSI模型的区别"><a href="#介绍一下TCP-IP模型和OSI模型的区别" class="headerlink" title="介绍一下TCP&#x2F;IP模型和OSI模型的区别"></a>介绍一下TCP&#x2F;IP模型和OSI模型的区别</h4><p><strong>TCP&#x2F;IP 模型与 OSI 模型的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>OSI 模型（七层）</strong></th>
<th><strong>TCP&#x2F;IP 模型（四层）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>层次划分</strong></td>
<td>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</td>
<td>应用层、传输层、网络层、网络接口层</td>
</tr>
<tr>
<td><strong>设计理念</strong></td>
<td>理想化、理论性强，定义清晰的层次关系，每层独立</td>
<td>结合实际网络设计，更符合互联网协议</td>
</tr>
<tr>
<td><strong>协议示例</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>应用层</strong></td>
<td>HTTP、FTP、SMTP、DNS 等</td>
<td>HTTP、FTP、SMTP、DNS 等（合并 OSI 的应用层、表示层、会话层）</td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td>TCP、UDP</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td>IP、ICMP、ARP</td>
<td>IP、ICMP、ARP</td>
</tr>
<tr>
<td><strong>数据链路层 &#x2F; 物理层</strong></td>
<td>以太网、Wi-Fi、PPP</td>
<td>以太网、Wi-Fi、PPP（合并 OSI 的数据链路层、物理层）</td>
</tr>
<tr>
<td><strong>适用范围</strong></td>
<td>理论上更全面</td>
<td>实际网络通信中更为实用。</td>
</tr>
<tr>
<td><strong>数据封装单位</strong></td>
<td><strong>比特流（物理层） → 帧（数据链路层） → 数据包（网络层） → 段（传输层） → 数据（应用层）</strong></td>
<td><strong>比特流 → 帧 → 数据包 → 段 → 数据</strong></td>
</tr>
</tbody></table>
<p>TCP&#x2F;IP 模型的<strong>应用层</strong>相当于 OSI 的 <strong>应用层 + 表示层 + 会话层</strong>，<br>而 TCP&#x2F;IP 的<strong>网络接口层</strong>相当于 OSI 的 <strong>数据链路层 + 物理层</strong>。</p>
<h4 id="从输入-URL-到页面展示到底发生了什么？"><a href="#从输入-URL-到页面展示到底发生了什么？" class="headerlink" title="从输入 URL 到页面展示到底发生了什么？"></a>从输入 URL 到页面展示到底发生了什么？</h4><ul>
<li><strong>浏览器网络请求</strong><ul>
<li><strong>输入网址，解析 URL 信息</strong><ul>
<li>解析 URL，提取协议（<code>https</code>）、域名（<code>www.example.com</code>）、路径（<code>/</code>）</li>
</ul>
</li>
<li><strong>检查浏览器缓存</strong><ul>
<li>有缓存并且仍然有效，则直接加载页面</li>
</ul>
</li>
<li><strong>DNS 解析 （域名 → IP 地址）</strong><ul>
<li>浏览器缓存 —&gt; 本地 <code>hosts</code> 文件 —&gt; 本地 DNS 服务器（ISP 提供）—&gt;权威 DNS 服务器（根 DNS → 顶级域名 DNS → 权威 DNS）</li>
</ul>
</li>
<li><strong>建立 TCP 连接（三次握手）</strong><ul>
<li><strong>第一步</strong>：客户端发送 SYN 报文请求连接。</li>
<li><strong>第二步</strong>：服务器回复 SYN-ACK 报文，确认连接请求。</li>
<li><strong>第三步</strong>：客户端回复 ACK，连接建立成功。</li>
</ul>
</li>
<li><strong>发送 HTTP 请求</strong><ul>
<li>浏览器构造 HTTP 请求：<ul>
<li><strong>请求行</strong>（请求方法 <code>GET</code>、请求路径 <code>/</code>、协议版本 <code>HTTP/1.1</code>）</li>
<li><strong>请求头</strong>（包含 <code>User-Agent</code>、<code>Cookie</code> 等）</li>
</ul>
</li>
<li>如果是 HTTPS，还涉及 <strong>TLS 握手</strong> 进行加密通信。</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务器处理请求</strong><ul>
<li><strong>服务器解析HTTP请求</strong><ul>
<li>接收 HTTP 请求，解析 URL 和请求头，查询静态资源和数据库、渲染动态页面</li>
</ul>
</li>
<li><strong>服务器返回HTTP响应</strong><ul>
<li><strong>响应状态码</strong>（如 <code>200 OK</code>，<code>404 Not Found</code>）</li>
<li><strong>响应头</strong>（<code>Content-Type: text/html</code>）</li>
<li><strong>响应体</strong>（HTML、CSS、JavaScript）</li>
</ul>
</li>
<li><strong>TCP 连接断开（四次挥手）</strong><ul>
<li><strong>客户端发送 FIN</strong>（请求关闭连接）</li>
<li><strong>服务器回复 ACK</strong>  此时若有剩余数据则继续发送</li>
<li><strong>服务器发送 FIN</strong>（服务器准备关闭）</li>
<li><strong>客户端回复 ACK</strong>（最终确认关闭）</li>
</ul>
</li>
</ul>
</li>
<li><strong>浏览器解析并渲染页面</strong><ul>
<li><strong>解析响应头</strong><ul>
<li>301，302重定向，为字节流则下载，为HTML文件则解析html文件</li>
</ul>
</li>
<li><strong>解析HTML 并渲染页面</strong><ul>
<li><strong>解析 HTML</strong>，构建 <strong>DOM 树</strong>    <strong>解析 CSS</strong>，构建 <strong>CSSOM 树</strong>，进行 <strong>样式计算</strong></li>
<li><strong>合成渲染树</strong>（DOM + CSSOM），<strong>布局（Layout）</strong> 计算元素的具体位置，<strong>绘制（Painting）</strong> 将页面渲染到屏幕上</li>
<li><strong>执行 JavaScript</strong>，更新页面内容</li>
</ul>
</li>
<li><strong>页面显示</strong><ul>
<li>页面最终呈现给用户，加载其他资源（图片、视频、异步数据等）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h3><h4 id="HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"><a href="#HTTP请求报文和响应报文是怎样的，有哪些常见的字段？" class="headerlink" title="HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"></a>HTTP请求报文和响应报文是怎样的，有哪些常见的字段？</h4><h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><ul>
<li><p><strong>请求行</strong>（Request Line）</p>
<ul>
<li><p><strong>请求方法（Method）</strong>：如 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等</p>
</li>
<li><p><strong>资源路径（Resource Path）</strong>：要访问的资源地址</p>
</li>
<li><p><strong>HTTP 版本（HTTP Version）</strong>：如 <code>HTTP/1.1</code>、<code>HTTP/2.0</code></p>
</li>
<li><p>例如：<code>GET /index.html HTTP/1.1</code></p>
</li>
</ul>
</li>
<li><p><strong>请求头</strong>（Request Headers）：提供额外的信息，例如浏览器类型、缓存策略等</p>
<ul>
<li><p>常见请求头字段：</p>
<ul>
<li><p><strong>客户端环境&#x2F;请求资源</strong></p>
<ul>
<li><code>Host</code>：请求的服务器域名（必须字段）</li>
<li><code>User-Agent</code>：客户端信息（如浏览器、操作系统）</li>
<li><code>Accept</code>：客户端能接受的数据类型（如 <code>text/html</code>）</li>
<li><code>Accept-Encoding</code>：支持的压缩格式（如 <code>gzip</code>）</li>
</ul>
</li>
<li><p><strong>身份认证与安全</strong></p>
<ul>
<li><code>Authorization</code>：身份认证信息（如 <code>Bearer Token</code>）</li>
</ul>
</li>
<li><p><strong>缓存控制</strong></p>
<ul>
<li><code>If-None-Match </code> &#x2F; <code> If-Modified-Since</code>：资源的ETag &#x2F; 最后修改时间 值，用于缓存控制。</li>
</ul>
</li>
<li><p><strong>请求内容描述</strong></p>
<ul>
<li><code>Content-Length</code>：请求体的长度（仅适用于带请求体的方法）</li>
<li><code>Content-Type</code>：请求体的媒体类型（如 <code>application/json</code>）</li>
<li><code>Cookie</code>：发送存储在客户端的 Cookie</li>
</ul>
</li>
<li><p><code>Connection</code>：管理连接的选项，如 keep-alive</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>空行</strong>：用于分隔请求头和请求体。</p>
</li>
<li><p><strong>请求体</strong>（Request Body）：用于 <code>POST</code>、<code>PUT</code> 请求，包含要发送的数据（如 JSON、表单数据等）。</p>
</li>
</ul>
<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><ul>
<li><p><strong>状态行</strong>（Status Line）：包含 HTTP 版本、状态码、状态描述</p>
<ul>
<li><p><strong>HTTP 版本</strong>：如 <code>HTTP/1.1</code></p>
</li>
<li><p><strong>状态码</strong>（Status Code）</p>
<ul>
<li><code>2xx</code>（成功）：<code>200 OK</code>、<code>201 Created</code></li>
<li><code>3xx</code>（重定向）：<code>301 Moved Permanently</code>、<code>302 Found</code></li>
<li><code>4xx</code>（客户端错误）：<code>400 Bad Request</code>、<code>404 Not Found</code></li>
<li><code>5xx</code>（服务器错误）：<code>500 Internal Server Error</code></li>
</ul>
</li>
<li><p><strong>状态描述</strong>：对状态码的解释（如 <code>OK</code>、<code>Not Found</code>）</p>
</li>
<li><p>例如：<code>HTTP/1.1 200 OK</code></p>
</li>
</ul>
</li>
<li><p><strong>响应头</strong>（Response Headers）：提供额外信息，如内容类型、缓存控制等</p>
<ul>
<li><p>常见响应头字段</p>
<ul>
<li><p><strong>重定向</strong></p>
<ul>
<li><code>Location</code>：重定向地址（适用于 301、302）</li>
</ul>
</li>
<li><p><strong>描述响应内容</strong></p>
<ul>
<li><code>Content-Type</code>：返回数据的 MIME 类型（如 <code>text/html</code>）</li>
<li><code>Content-Length</code>：响应体长度（字节）</li>
</ul>
</li>
<li><p><strong>控制缓存</strong></p>
<ul>
<li><code>Expires</code>：指定响应的过期时间，用于缓存控制。</li>
<li><code>ETag</code>：资源的实体标签，用于缓存验证。</li>
<li><code>Last-Modified</code>：资源最后修改的日期和时间。</li>
</ul>
</li>
<li><p><strong>管理连接和安全</strong></p>
<ul>
<li><code>Server</code>：服务器软件信息（如 <code>nginx/1.18.0</code>）</li>
<li><code>Set-Cookie</code>：设置 Cookie</li>
<li><code>Access-Control-Allow-Origin</code>：指示哪些域名可以访问资源，涉及跨域资源共享（CORS）策略</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>空行</strong>：用于分隔响应头和响应体。</p>
</li>
<li><p><strong>响应体</strong>（Response Body）：实际的返回数据，如 HTML 页面、JSON 数据、图片等。</p>
</li>
</ul>
<h4 id="HTTP有哪些请求方式？"><a href="#HTTP有哪些请求方式？" class="headerlink" title="HTTP有哪些请求方式？"></a>HTTP有哪些请求方式？</h4><p><strong>幂等性</strong>：表示多次执行相同请求，服务器状态不变。</p>
<p><strong>安全性</strong>：表示请求不会修改服务器数据（如 <code>GET</code>、<code>HEAD</code>、<code>OPTIONS</code>）。</p>
<p>HTTP 定义了多种请求方法，每种方法适用于不同的场景。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>用途</strong></th>
<th><strong>幂等性</strong></th>
<th><strong>安全性</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>GET</strong></td>
<td>获取资源</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>POST</strong></td>
<td>提交数据</td>
<td>❌ 非幂等</td>
<td>❌ 不安全（数据在请求体中）</td>
</tr>
<tr>
<td><strong>PUT</strong></td>
<td>更新资源（完整更新）</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>DELETE</strong></td>
<td>删除资源</td>
<td>✅ 幂等</td>
<td>❌ 不安全（改变服务器状态）</td>
</tr>
<tr>
<td><strong>HEAD</strong></td>
<td>获取资源的头部信息</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>OPTIONS</strong></td>
<td>获取服务器支持的请求方法</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>TRACE</strong></td>
<td>回显请求，用于调试</td>
<td>✅ 幂等</td>
<td>❌ 不安全（容易被攻击）</td>
</tr>
<tr>
<td><strong>CONNECT</strong></td>
<td>建立隧道连接（如 HTTPS 代理）</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
</tbody></table>
<h4 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h4><ul>
<li><code>GET</code> <strong>适用于获取数据</strong>，参数放在 URL，容易被缓存，幂等且安全。</li>
<li><code>POST</code> <strong>适用于提交数据</strong>，参数放在请求体，不容易被缓存，不幂等。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>参数位置</strong></td>
<td>URL 查询参数（<code>?key=value</code>）</td>
<td>请求体</td>
</tr>
<tr>
<td><strong>参数长度</strong></td>
<td>受 URL 长度限制</td>
<td>理论上无限制</td>
</tr>
<tr>
<td><strong>缓存</strong></td>
<td>可被缓存</td>
<td>不会被浏览器缓存</td>
</tr>
<tr>
<td><strong>可见性</strong></td>
<td>参数暴露在 URL 中</td>
<td>参数在请求体，不易暴露</td>
</tr>
<tr>
<td><strong>幂等性</strong></td>
<td>✅ 幂等</td>
<td>❌ 非幂等</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>查询数据（如获取用户信息）</td>
<td>提交数据（如用户注册、登录）</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>❌ 不适合传输敏感信息（如密码）</td>
<td>✅ 相对更安全，但仍需 HTTPS</td>
</tr>
</tbody></table>
<h3 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h3><h4 id="HTTP请求中常见的状态码"><a href="#HTTP请求中常见的状态码" class="headerlink" title="HTTP请求中常见的状态码"></a><strong>HTTP请求中常见的状态码</strong></h4><p>HTTP 状态码用于指示服务器对请求的处理结果，按照功能分为 5 类</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>分类名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1xx</strong></td>
<td><strong>信息性状态码</strong></td>
<td>服务器已收到请求，正在继续处理</td>
</tr>
<tr>
<td><strong>2xx</strong></td>
<td><strong>成功状态码</strong></td>
<td>请求成功并返回预期的响应</td>
</tr>
<tr>
<td><strong>3xx</strong></td>
<td><strong>重定向状态码</strong></td>
<td>需要客户端执行进一步操作（重定向）</td>
</tr>
<tr>
<td><strong>4xx</strong></td>
<td><strong>客户端错误码</strong></td>
<td>客户端请求有错误（参数错误、权限不足等）</td>
</tr>
<tr>
<td><strong>5xx</strong></td>
<td><strong>服务器错误码</strong></td>
<td>服务器端发生错误，无法处理请求</td>
</tr>
</tbody></table>
<p><strong>常见状态码</strong></p>
<ul>
<li><p>**2xx：**请求成功</p>
<ul>
<li><strong>200 OK</strong>：常用于 <code>GET</code>、<code>POST</code>、<code>PUT</code> 等请求。</li>
<li><strong>201 Created</strong>：服务器创建了新资源（常用于 <code>POST</code>）。</li>
<li><strong>204 No Content</strong>：服务器无返回内容（常用于 <code>DELETE</code>）。</li>
</ul>
</li>
<li><p><strong>3xx：</strong></p>
<ul>
<li><strong>301 Moved Permanently</strong>：资源永久移动，后续请求应使用新 URL（SEO 友好）。</li>
<li><strong>302 Found</strong>（临时重定向）：资源暂时移动，后续请求仍可使用原 URL。</li>
<li><strong>304 Not Modified</strong>（缓存优化）：客户端缓存资源仍然有效，无需重新下载（结合 <code>ETag</code>、<code>Last-Modified</code> 头使用）。<ul>
<li><strong>缓存相关：</strong></li>
<li>浏览器在接收到 <code>304 Not Modified</code> 后，不会下载新资源，而是从本地缓存加载，提升性能。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>4xx：</strong></p>
<ul>
<li><strong>400 Bad Request</strong>：请求格式错误或参数无效，服务器无法解析。</li>
<li><strong>401 Unauthorized</strong>：身份认证失败，需要提供有效凭证（如未登录）。</li>
<li><strong>403 Forbidden</strong>：服务器拒绝请求。（如权限不够）</li>
<li><strong>404 Not Found</strong>：请求的资源不存在（常见于访问错误的 URL）。</li>
</ul>
</li>
<li><p><strong>5xx：</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong>：服务器内部错误（代码异常、数据库崩溃等）。</li>
<li><strong>502 Bad Gateway</strong>：服务器作为网关&#x2F;代理，收到无效响应（上游服务器问题）。</li>
<li><strong>503 Service Unavailable</strong>：服务器暂时不可用（维护、超载等）。</li>
</ul>
</li>
</ul>
<p><strong>状态码使用案例</strong></p>
<ol>
<li><strong>用户访问网站首页</strong><ul>
<li>正常加载：返回 <code>200 OK</code></li>
<li>页面不存在：返回 <code>404 Not Found</code></li>
<li>需要登录：返回 <code>401 Unauthorized</code></li>
</ul>
</li>
<li><strong>API 接口</strong><ul>
<li>获取数据成功：返回 <code>200 OK</code></li>
<li>没有权限：返回 <code>403 Forbidden</code></li>
<li>请求参数错误：返回 <code>400 Bad Request</code></li>
</ul>
</li>
<li><strong>重定向</strong><ul>
<li>旧网站迁移到新域名：返回 <code>301 Moved Permanently</code></li>
<li>用户登录后跳转到主页：返回 <code>302 Found</code></li>
<li>资源未修改：返回 &#96;304 Not Modified</li>
</ul>
</li>
</ol>
<h4 id="什么是强缓存和协商缓存"><a href="#什么是强缓存和协商缓存" class="headerlink" title="什么是强缓存和协商缓存"></a><strong>什么是强缓存和协商缓存</strong></h4><p>HTTP 协议中，缓存机制主要用于减轻服务器负担，加快页面加载速度</p>
<ol>
<li>浏览器第一次访问时访问服务器时需要下载资源</li>
<li>后续访问时，只要强缓存没有失效就直接从缓存中获取，不需要将获取资源的请求包含在请求报文中</li>
<li>当强缓存失效后，浏览器会使用协商缓存机制来验证资源是否被修改</li>
</ol>
<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><ul>
<li><strong>Expires</strong><br> <code>Expires</code> 是一个 HTTP 响应头，指定资源的过期时间（绝对时间），表示在该时间之前资源都是有效的，可以直接使用缓存，不需要向服务器重新请求。<br> 用于设置强缓存。当客户端收到带有 <code>Expires</code> 头的响应后，在当前时间早于 <code>Expires</code> 指定时间内，浏览器直接从本地缓存中读取资源。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 21 Oct 2025 07:28:00 GMT</span><br><span class="line"><span class="comment">## 表示在 2025 年 10 月 21 日 07:28:00 GMT 之前，资源均可直接使用缓存。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>Cache-Control</strong></p>
<p><code>Cache-Control</code> 是 HTTP&#x2F;1.1 提供的用于控制缓存行为的通用头部，可以用于请求和响应中。它提供了多种指令来精细控制资源如何被缓存。<br>用于替代或补充 <code>Expires</code>，提供更灵活的缓存控制。服务器可以根据业务需求，准确控制资源的缓存策略</p>
<ul>
<li><strong>常见指令</strong>：<ul>
<li><strong>max-age</strong>：指定资源在客户端缓存的最大时间（秒），例如 <code>max-age=3600</code> 表示缓存有效期为 3600 秒。</li>
<li><strong>no-cache</strong>：表示缓存必须在使用前进行重新验证，即使缓存仍在有效期内。</li>
<li><strong>no-store</strong>：禁止缓存，确保每次请求都从服务器获取最新数据。</li>
<li><strong>public</strong> 和 <strong>private</strong>：分别指示资源可以被所有用户缓存，或仅供单个用户缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=3600, public</span><br><span class="line"><span class="comment">## 表示资源可以被缓存 3600 秒，并允许任何缓存设备缓存此资源。</span></span><br></pre></td></tr></table></figure>



<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><ul>
<li><p><strong>Last-Modified</strong></p>
<p> <code>Last-Modified</code> 是服务器在响应中返回的头部字段，用来指示资源的最后修改时间。它通常以 GMT 时间格式表示。</p>
<p> 客户端在后续请求时，可以使用 <code>If-Modified-Since</code> 请求头将之前获取的 <code>Last-Modified</code> 值发送给服务器。如果资源自该时间之后没有更新，服务器可以返回 <code>304 Not Modified</code> 状态，从而避免不必要的数据传输。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Tue, 20 Apr 2025 12:00:00 GMT</span><br><span class="line"><span class="comment">## 表示资源在该时间之后没有发生变化，客户端可据此进行缓存验证。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>ETag</strong></p>
<p> <code>ETag</code>（实体标签）是服务器为特定资源生成的唯一标识符，它反映了资源的版本。当资源内容发生变化时，ETag 值也会改变。</p>
<p> 客户端在后续请求时，可以在请求头中使用 <code>If-None-Match</code> 将之前收到的 ETag 值发送给服务器。服务器比对后，如果发现资源没有变化，则返回 <code>304 Not Modified</code>，让客户端继续使用缓存数据。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ETag: <span class="string">&quot;686897696a7c876b7e&quot;</span></span><br><span class="line"><span class="comment">## 表示该资源当前的版本标识符，后续可以利用此值进行缓存验证。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>浏览器使用缓存流程</code><br><img src="/2025/02/19/2025-02-19-卡码八股训练营记录/1.png"  alt="1" style="zoom:67%;" /></p>
<h3 id="Day04"><a href="#Day04" class="headerlink" title="Day04"></a>Day04</h3><h4 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h4><ul>
<li><strong>连接管理</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：默认使用<strong>短连接</strong>，每次请求&#x2F;响应后关闭 TCP 连接；<br>可以通过 <code>Connection: keep-alive</code> 来实现持久连接</li>
<li><em>HTTP&#x2F;1.1</em>：默认启用<strong>持久连接</strong>（<code>Connection</code>字段值默认为<code>keep-alive</code>），<br>在同一 TCP 连接上可以连续发送多个请求和响应，减少了连接建立和关闭的开销。</li>
</ul>
</li>
<li><strong>管道化</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：客户端的每次请求都需要在上一次请求的响应到达之后发送，请求发送有等待时间</li>
<li><em>HTTP&#x2F;1.1</em>：支持<strong>管道化</strong>，即同一连接上可以连续发送多个请求，<br>但由于服务器必须按顺序返回响应（队头阻塞问题），实际效果有限</li>
</ul>
</li>
<li><strong>缓存控制</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：主要依赖 <code>Expires</code> 头来指定资源的绝对过期时间，没有协商缓存机制</li>
<li><em>HTTP&#x2F;1.1</em>：引入了 <code>Cache-Control </code>头提供更精细的缓存指令,通过 <code>If-Modified-Since </code>和 <code>If-None-Match </code>等头实现协商缓存</li>
</ul>
</li>
<li><strong>错误处理和状态码</strong><br><strong>HTTP&#x2F;1.1</strong>增加了状态码（如 <code>100 Continue</code>）用于中间响应和更精细的错误处理，<br>使客户端能更好地管理请求过程和错误恢复</li>
<li><strong>请求头要求</strong><br><strong>HTTP&#x2F;1.1</strong>要求所有请求必须包含 <code>Host</code> 头  —&gt;  一台服务器&#x2F;一个IP 上可托管多个 域名&#x2F;网站</li>
<li><strong>带宽优化</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：不支持断点续传功能，客户端只需要某个对象的一部分时，服务器也会将整个对象发送过来</li>
<li><em>HTTP&#x2F;1.1</em>：在请求头引入了<code>range</code>头域，允许只请求资源的某个部分，此时服务器返回状态码<code>206</code></li>
</ul>
</li>
</ul>
<h4 id="HTTP2-0与HTTP1-1的区别？"><a href="#HTTP2-0与HTTP1-1的区别？" class="headerlink" title="HTTP2.0与HTTP1.1的区别？"></a>HTTP2.0与HTTP1.1的区别？</h4><ul>
<li><p><strong>二进制协议</strong></p>
<ul>
<li>HTTP&#x2F;1.1：请求和响应内容都是以纯文本方式发送的，解析时开销较大且容易出错。</li>
<li>HTTP&#x2F;2.0：采用二进制格式，将数据分割为小的帧，解析更高效、可靠</li>
</ul>
</li>
<li><p><strong>多路复用</strong></p>
<ul>
<li>HTTP&#x2F;1.1：支持持久连接，但请求在同一连接上串行发送，容易出现队头阻塞<ul>
<li>可以连续发送多个请求，但服务器必须按顺序返回响应</li>
</ul>
</li>
<li>HTTP&#x2F;2.0：支持多路复用，允许在单个TCP连接上并行交错发送多个请求和响应<ul>
<li>请求和响应报文被拆分为更小的帧<ul>
<li>帧类型包括 DATA、HEADERS、PRIORITY 等，每种类型的帧都有特定的用途。</li>
<li>流的状态管理涉及多种状态，如“已打开”、“已关闭”等，客户端和服务器可以通过发送特定的帧（如 RST_STREAM）来管理流的生命周期</li>
</ul>
</li>
<li>帧被分配到不同的流（Stream），每个流都有唯一的标识符</li>
<li>接收方根据帧头中的流标识符将属于同一流的帧重新组装为完整的请求或响应</li>
</ul>
</li>
<li>HTTP&#x2F;2.0 基于 TCP 协议来传输数据，发生了丢包现象时，就会触发 TCP 的重传机制，<br>这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来</li>
</ul>
</li>
<li><p><strong>头部压缩</strong></p>
<ul>
<li>HTTP&#x2F;1.1：头部信息以纯文本发送，冗余较多</li>
<li>HTTP&#x2F;2.0：引入 HPACK 算法对头部进行压缩，显著减少传输数据量<br><strong>HPACK 算法</strong>：<ul>
<li><strong>静态表和动态表</strong>：<br>客户端和服务器各自维护一个<strong>静态表</strong>和<strong>动态表</strong>，用于存储常见的头部字段。<br>静态表包含预定义的常用头部，动态表则在通信过程中动态更新，记录已发送的头部字段。<br>通过引用这些表中的索引，可以避免重复传输相同的头部信息。</li>
<li><strong>哈夫曼编码</strong>：<br>HPACK 使用哈夫曼编码对头部字段进行压缩，将常用字符编码为更短的二进制序列，从而减少头部的大小。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器推送</strong></p>
<p><code>HTTP/2.0</code> 允许服务器主动推送页面相关资源给客户端，而不需要客户端明确请求，<br>避免了客户端请求和服务器响应之间的延迟，可以减少页面加载时间</p>
<ul>
<li>例如，客户端请求一个 HTML 页面时，服务器可以主动推送相关的 CSS、JavaScript 文件等资源，从而加快页面渲染速度</li>
</ul>
</li>
<li><p><strong>优先级和依赖</strong></p>
<p><code>HTTP/2.0</code> 允许客户端为请求设置优先级，并表达请求之间的依赖关系，资源加载更加有序</p>
</li>
</ul>
<h4 id="HTTP3-0有了解过吗？"><a href="#HTTP3-0有了解过吗？" class="headerlink" title="HTTP3.0有了解过吗？"></a>HTTP3.0有了解过吗？</h4><p>HTTP3.0基于 QUIC 协议，运行在UDP上，整合了TCP和TLS协议</p>
<p>应用层数据直接被封装成QUIC帧，<br>整合一个或多个帧，加上信息（<strong>连接 ID</strong>&#x2F;<code>Connection ID</code>）后被封装成一个 QUIC 数据包<br>QUIC 数据包被封装在 UDP 数据报中，通过网络传输</p>
<ul>
<li><strong>无队头阻塞</strong><ul>
<li>HTTP&#x2F;1.1没有解决响应的队头阻塞、HTTP&#x2F;2基于TCP 协议，<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong></li>
<li>HTTP3.0基于UDP 协议发送，<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong></li>
</ul>
</li>
<li><strong>零 RTT 连接建立</strong><ul>
<li>传输数据前的 QUIC 协议握手只需要 1 RTT，目的是为确认双方的「连接 ID」</li>
<li>QUIC 内部包含了 TLS</li>
<li>第二次连接时，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</li>
</ul>
</li>
<li><strong>连接迁移</strong><ul>
<li>网络环境发送改变（如Wifi—&gt;移动网络）时，通过确认<code>Connection ID</code>实现<strong>零 RTT 连接</strong></li>
</ul>
</li>
<li><strong>向前纠错机制</strong><ul>
<li>每个数据包还包括了部分其他数据包的数据，少量丢包无需重传</li>
</ul>
</li>
<li><strong>安全性</strong><ul>
<li>默认使用TLS加密</li>
</ul>
</li>
</ul>
<h3 id="Day05"><a href="#Day05" class="headerlink" title="Day05"></a>Day05</h3><h4 id="HTTPS和HTTP有哪些区别"><a href="#HTTPS和HTTP有哪些区别" class="headerlink" title="HTTPS和HTTP有哪些区别"></a>HTTPS和HTTP有哪些区别</h4><ul>
<li>HTTP 明文传输、TCP三次握手后建立连接传输报文，默认工作在80端口</li>
<li>HTTPS TCP三次握手后还需要进行SSL&#x2F;TLS的握手过程才能进入加密报文传输，默认工作在443端口<ul>
<li>需要向CA（证书权威机构）申请数字证书，来保证服务器身份可信</li>
</ul>
</li>
</ul>
<h4 id="HTTPS的工作原理-HTTPS建立连接的过程）"><a href="#HTTPS的工作原理-HTTPS建立连接的过程）" class="headerlink" title="HTTPS的工作原理(HTTPS建立连接的过程）"></a>HTTPS的工作原理(HTTPS建立连接的过程）</h4><p><code>HTTPS</code> 主要基于<code>SSL/TLS</code> 协议，确保数据传输的安全性和完整性</p>
<ol>
<li><p><strong>客户端向服务器请求加密通信</strong></p>
<ul>
<li>请求报文包括：<ul>
<li>客户端支持的TLS版本、支持的加密算法、随机数1（Client Random）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器选择一个客户端支持的加密算法</strong></p>
<ul>
<li>响应报文包括：<ul>
<li>CA证书：服务器的数字证书，由受信任的CA签发、<br>随机数2（Server Random）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>客户端验证证书合法性</strong></p>
<ul>
<li>使用数字证书中的公钥<strong>加密</strong>报文<br>报文内容包括：<ul>
<li>随机数3（预主密钥 Pre-Master Secret）：三个随机数生成 <strong>会话密钥&#x2F;主密钥（Master Secret）</strong></li>
<li>加密算法改变通知：之前使用会话密钥加密通话</li>
<li>结束握手通知、之前消息摘要校验值（用于服务器验证数据完整性）<ul>
<li>“加密算法改变通知”通常是通过<strong>ChangeCipherSpec</strong>消息发送，<br>而<strong>Finished</strong>消息则包含了整个握手过程的摘要，用于双方确认握手数据未被篡改。<br>这两个消息实际上是分开的，而不是合并在一个报文中。<ol>
<li>客户端生成并发送加密后的预主密钥（即ClientKeyExchange消息）。</li>
<li>客户端随后发送ChangeCipherSpec和Finished消息。</li>
<li><code>Tips</code>：<br>消息通常指应用层的数据单位，而报文是网络层的数据传输单位。<br>消息在传输过程中可能被分割成多个报文进行传输。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器生成会话密钥</strong></p>
<ul>
<li><p>服务器使用自己的私钥解密客户端发送的预主密钥，随后与客户端共同计算出主密钥，再派生出对称加密所需的各个子密钥。</p>
</li>
<li><p>发送内容：通知服务器后续加密、结束握手通知、之前消息摘要校验值（用于客户端验证数据完整性）</p>
<ul>
<li>后续加密的通知、结束握手通知和之前消息摘要校验值同样是两个消息分别发送的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据传输完成后销毁密钥</strong></p>
<ul>
<li>通信结束后双方应销毁会话密钥以防止长期使用造成安全风险。</li>
</ul>
</li>
</ol>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><ul>
<li><strong>TCP</strong> <ul>
<li><strong>面向连接</strong>：数据传输前需要建立连接（三次握手），确保通信双方的可靠连接</li>
<li><strong>可靠数据传输</strong>（保证顺序、完整性）：通过序列号、确认应答、重传机制等<ul>
<li>检测并重传丢失数据包</li>
</ul>
</li>
<li><strong>拥塞控制机制</strong>：根据网络状况调整发送速率</li>
<li><strong>滑动窗口机制</strong>：流量控制，保证对端能够处理发送的数据</li>
<li>报文头部复杂：TCP头部通常为20字节，包含序列号、确认号、窗口大小等多个字段</li>
</ul>
</li>
<li><strong>UDP</strong> <ul>
<li><strong>无连接</strong>：数据传输前不需要建立连接，发送方直接将数据包发送出去，接收方无需确认</li>
<li><strong>不可靠</strong>：UDP不提供数据包的确认、重传等机制，无法保证数据的顺序性和完整性，<br>           适用于对实时性要求高且能容忍一定数据丢失的应用。</li>
<li>发送速率恒定</li>
<li>头部报文相对简单，开销较小 ：<br>UDP头部只有8字节，包含源端口、目的端口、长度和校验和等基本信息，适合对速度和效率要求高的应用。</li>
</ul>
</li>
</ul>
<h3 id="Day06"><a href="#Day06" class="headerlink" title="Day06"></a>Day06</h3><h4 id="TCP连接如何确保可靠性"><a href="#TCP连接如何确保可靠性" class="headerlink" title="TCP连接如何确保可靠性"></a>TCP连接如何确保可靠性</h4><ul>
<li><strong>连接管理</strong>：三次握手、四次挥手</li>
<li><strong>差错控制</strong>：<ul>
<li><strong>序列号和确认应答机制</strong>：<br>每个数据包都被赋予唯一的序列号，接收方通过发送确认包（ACK）来告知发送方数据已成功接收。<br>发送方根据确认包的序列号来确认哪些数据已经收到，哪些还需要重新发送。</li>
<li><strong>超时重传机制</strong>：<br>如果发送方在一定时间内没有收到接收方的确认（ACK），它会重新发送未确认的数据包。<br>这确保了数据在丢包时能够重新传输。</li>
</ul>
</li>
<li><strong>流量控制</strong>：<br>TCP使用滑动窗口机制进行流量控制，确保接收方的缓冲区不被溢出。<br>接收方在ACK包中告诉发送方它能够接收的最大数据量，发送方根据这一信息调整数据发送速度。</li>
<li><strong>拥塞控制</strong>：TCP使用拥塞控制机制来动态调整发送速率，防止网络过载，</li>
</ul>
<h4 id="TCP-拥塞控制机制"><a href="#TCP-拥塞控制机制" class="headerlink" title="TCP 拥塞控制机制"></a>TCP 拥塞控制机制</h4><ul>
<li><p><strong>慢启动</strong>：<br>发送方维护一个拥塞窗口，窗口初始设为一个小的值（通常为1个最大报文段大小MSS）<br>每一经过一RTT窗口大小翻倍，达到阈值后进入拥塞避免阶段</p>
</li>
<li><p><strong>拥塞避免</strong> ：拥塞窗口大小达到阈值之后，增长方式由指数级增长变为线性增长</p>
</li>
<li><p><strong>快重传</strong> ：<br>接收方收到失序数据包时<strong>重复发送上一个数据包的ACK</strong><br>发送方收到<strong>三个重复的ACK</strong>后，认为发生了丢包，直接重传丢失的数据包，而不是等待超时</p>
</li>
<li><p><strong>快恢复</strong> ：<br>快重传之后，TCP不会回到慢启动阶段，而是将窗口大小设置为阈值的一半，然后继续线性增长</p>
</li>
</ul>
<h4 id="TCP-流量控制机制"><a href="#TCP-流量控制机制" class="headerlink" title="TCP 流量控制机制"></a>TCP 流量控制机制</h4><p><strong>流量控制的目的</strong></p>
<ul>
<li><strong>防止接收方过载</strong>：接收方有一定的缓冲区，当发送数据过快而接收方处理不过来时，就可能造成缓冲区溢出，从而丢失数据。</li>
<li><strong>保障数据正确接收</strong>：确保数据传输双方的速率匹配，使得接收方能够及时处理和确认收到的数据。</li>
</ul>
<p>TCP采用<strong>滑动窗口机制</strong>实现流量控制，<strong>TCP报文头中有一个“窗口大小”字段（16位）</strong>，<br>它由接收方计算并告知发送方，表示接收方当前可用的缓冲区大小。</p>
<ul>
<li>发送方发送，接收方更新，协商窗口大小</li>
<li>接收方将接收数据存入缓冲区，向上层应用提供数据处理</li>
<li>接收方定期发送确认报文，缓冲区快满时、减少窗口大小，缓冲区剩余空间较大时，增大窗口大小</li>
</ul>
<p>TCP流量控制主要是为了确保发送方不会以超过接收方处理能力的速率发送数据，从而防止接收方的缓冲区溢出和数据丢失。其基本实现原理和关键组件如下：</p>
<p><strong>流量控制与拥塞控制的区别</strong></p>
<ul>
<li><strong>流量控制</strong>：主要是点对点的机制，关注的是发送方与接收方之间的数据速率匹配，防止接收方缓冲区溢出。</li>
<li><strong>拥塞控制</strong>：则是端到端的机制，目的是防止整个网络中某个环节因数据量过大而导致拥塞、丢包及延迟增加。</li>
<li>在实际传输中，发送方的发送速率受两个因素的限制：<br>接收方通告的窗口大小（流量控制）和网络状况下的拥塞窗口（拥塞控制），<br>实际允许发送的数据量为两者的最小值。</li>
</ul>
<h4 id="UDP怎么实现可靠传输"><a href="#UDP怎么实现可靠传输" class="headerlink" title="UDP怎么实现可靠传输"></a>UDP怎么实现可靠传输</h4><p><strong>选择UDP原因</strong>：TCP在<strong>传输层</strong>实现可靠连接，存在问题：连接延迟、队头阻塞、网络迁移需要重新建立连接</p>
<p>UDP本身是无连接、不可靠的协议，但在需要可靠传输的场景下，可以在<strong>应用层</strong>自行实现类似TCP的可靠性机制。一般可以从以下两方面实现：</p>
<ul>
<li><strong>超时重传</strong><ul>
<li>为每个UDP数据报设计一个自定义首部，其中包含时间戳，用于测量数据报的往返时间（RTT），从而计算合适的重传超时时间（RTO）。</li>
<li>采用“等停（stop-and-wait）”方式发送数据报，即发送一个数据报后等待对端确认，确认收到后再发送下一个；若超过RTO未收到确认，则进行重传，同时将RTO扩大为原来的两倍，再次启动计时。</li>
</ul>
</li>
<li><strong>确认和序列号机制</strong><ul>
<li>在UDP数据报首部中增加确认序列号字段，标识当前数据报的序号。</li>
<li>对端在收到数据报后，提取时间戳和序列号，并构造确认报文（ACK）返回给发送方。</li>
<li>发送方收到确认后，就知道该数据报已正确到达；同时，对端根据序列号对收到的数据报进行排序，并丢弃重复的数据报，保证数据按序交付给上层应用。</li>
</ul>
</li>
</ul>
<p><strong>QUIC协议</strong><br>基于UDP协议，在应用层实现可靠传输，通过三次握手协商ConnectionID建立连接<br>（网络迁移时只需要确认ConnectionID，可实现0RTT建立连接）</p>
<h3 id="Day08"><a href="#Day08" class="headerlink" title="Day08"></a>Day08</h3><h4 id="TCP连接三次握手的过程，为什么是三次"><a href="#TCP连接三次握手的过程，为什么是三次" class="headerlink" title="TCP连接三次握手的过程，为什么是三次"></a>TCP连接三次握手的过程，为什么是三次</h4><p>TCP 采用 <strong>三次握手</strong> 主要是为了<br><strong>确保双方的发送和接收能力都正常</strong>，<br><strong>同步初始序列号（ISN），保证数据有序传输</strong>，<br><strong>防止旧的连接请求影响新连接</strong></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>发送方</th>
<th>报文类型</th>
<th>关键字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第一次握手</strong></td>
<td>客户端</td>
<td><strong>SYN</strong></td>
<td><code>SYN=1, seq=x</code></td>
<td>请求建立连接</td>
</tr>
<tr>
<td><strong>第二次握手</strong></td>
<td>服务器</td>
<td><strong>SYN+ACK（SYN-ACK）</strong></td>
<td><code>SYN=1, ACK=1, seq=y, ack=x+1</code></td>
<td>服务器同意连接</td>
</tr>
<tr>
<td><strong>第三次握手</strong></td>
<td>客户端</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, seq=x+1, ack=y+1</code></td>
<td>确认连接建立</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>第一次握手（SYN）</strong>：客户端 → 服务器：发送 <code>SYN（seq=x）</code>，表示希望建立连接，并携带 <strong>初始序列号（ISN）</strong></p>
<ul>
<li>客户端确认自己<strong>能发送数据</strong>，请求建立连接。<ul>
<li>✔️ 客户端知道自己 <strong>能发送数据</strong>（但不知道服务器能否接收）</li>
<li>❌ 客户端还不知道服务器的状态、服务器也不知道客户端是否能正常接收数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第二次握手（SYN+ACK）</strong>：服务器 → 客户端：返回 <code>SYN+ACK（SYN=1, ACK=1, seq=y, ack=x+1）</code>，<br>表示：<strong>ACK&#x3D;x+1</strong>：确认收到了客户端的 SYN，表明服务器 <strong>能接收</strong> 数据。<br>        <strong>SYN&#x3D;y</strong>：服务器也发送自己的 SYN，请求客户端确认服务器的状态。</p>
<ul>
<li>服务器确认自己能<strong>接收并发送</strong>，并请求客户端确认。<ul>
<li>✔️ 服务器知道自己 <strong>能接收</strong> 客户端的数据。</li>
<li>✔️ 服务器知道客户端 <strong>能发送</strong> 数据。</li>
<li>❌ 服务器还不知道客户端是否能接收数据、客户端也不知道服务器的数据是否能被自己正确接收。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第三次握手（ACK）</strong>：客户端 → 服务器：发送 <code>ACK（ACK=1, seq=x+1, ack=y+1）</code><br>表示：<strong>ACK&#x3D;y+1</strong>：确认收到了服务器的 SYN，说明客户端 <strong>能接收</strong> 数据。<strong>这一步之后，双方都确认了收发能力，连接正式建立！</strong></p>
<ul>
<li>客户端最终确认服务器的<strong>发送能力</strong>，确保连接正常。<ul>
<li>✔️ 客户端&#x2F;服务器 知道对方 <strong>能收发</strong> 数据 ，成功建立连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>为什么不能用两次握手？</strong></p>
<p>如果只用 两次握手<code>（SYN → SYN+ACK）</code>，可能会遇到 <strong>旧 SYN 报文导致的错误连接问题</strong>。</p>
<p><strong>问题：旧 SYN 报文导致连接异常</strong></p>
<ol>
<li>客户端 A 发送 <code>SYN</code> 请求，但网络延迟，未到达服务器。</li>
<li>客户端 A 以为服务器无响应，放弃连接，重新发送新的 <code>SYN</code>。</li>
<li>服务器此时收到<strong>旧的</strong> <code>SYN </code>请求，并误以为客户端要建立新连接，返回 <code>SYN+ACK</code>。</li>
<li>客户端 A 没有预期这次握手，可能直接忽略或返回 RST，导致服务器错误建立连接。</li>
</ol>
<p> <strong>三次握手可以避免这个问题</strong>：</p>
<ul>
<li>只有客户端 收到服务器的 <code>SYN+ACK</code>，并主动发送 <code>ACK</code>，服务器才会确认连接建立，从而避免误连接。</li>
</ul>
<p><strong>为什么不能用四次或更多次握手？</strong></p>
<p>三次握手已经足够确保双方的收发能力正常，额外的握手只会增加开销，没有额外收益，因此三次是最合理的方案。</p>
<h4 id="TCP连接四次挥手的过程，为什么是四次？"><a href="#TCP连接四次挥手的过程，为什么是四次？" class="headerlink" title="TCP连接四次挥手的过程，为什么是四次？"></a>TCP连接四次挥手的过程，为什么是四次？</h4><p>TCP 采用 <strong>四次挥手</strong> 主要是为了<br><strong>确保双方都能正常断开连接</strong><br><strong>让双方的数据传输完全结束，避免丢失</strong><br><strong>保证全双工通信中，双方都能独立关闭发送方向</strong></p>
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>发送方</strong></th>
<th><strong>报文类型</strong></th>
<th><strong>关键字段</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>第一次挥手</strong></td>
<td>客户端</td>
<td><strong>FIN</strong></td>
<td><code>FIN=1, seq=x</code></td>
<td>请求关闭连接</td>
</tr>
<tr>
<td><strong>第二次挥手</strong></td>
<td>服务器</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, ack=x+1</code></td>
<td>确认关闭请求</td>
</tr>
<tr>
<td><strong>第三次挥手</strong></td>
<td>服务器</td>
<td><strong>FIN</strong></td>
<td><code>FIN=1, seq=y</code></td>
<td>服务器请求关闭</td>
</tr>
<tr>
<td><strong>第四次挥手</strong></td>
<td>客户端</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, ack=y+1</code></td>
<td>确认服务器关闭</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>第一次挥手（客户端 → 服务器：FIN）</strong></p>
<ul>
<li>客户端 发送 <code>FIN（seq=x）</code>，表示自己 没有数据要发送了，请求关闭 发送方向。<br>客户端进入 <strong>FIN-WAIT-1状态</strong>，等待服务器确认。</li>
<li>客户端 –&gt; 服务器: <code>FIN, seq=x</code></li>
</ul>
</li>
<li><p><strong>第二次挥手（服务器 → 客户端：ACK）</strong></p>
<ul>
<li>服务器 发送 <code>ACK（ack=x+1）</code>，表示 收到了客户端的关闭请求，但仍可能有数据要发送。<br>服务器进入 <strong>CLOSE-WAIT 状态</strong>，继续处理剩余数据。<br>客户端进入 <strong>FIN-WAIT-2 状态</strong>，等待服务器关闭。</li>
<li>服务器 –&gt; 客户端: <code>ACK, ack=x+1</code></li>
</ul>
</li>
<li><p><strong>第三次挥手（服务器 → 客户端：FIN）</strong></p>
<ul>
<li>服务器 处理完所有数据后，发送<code> FIN（seq=y）</code>，请求关闭 发送方向。<br>服务器进入 <strong>LAST-ACK 状态</strong>，等待客户端的确认。</li>
<li>服务器 –&gt; 客户端: <code>FIN, seq=y</code></li>
</ul>
</li>
<li><p><strong>第四次挥手（客户端 → 服务器：ACK）</strong></p>
<ul>
<li>客户端 发送 <code>ACK（ack=y+1）</code>，确认服务器的关闭请求。<br>客户端进入 <strong>TIME-WAIT 状态</strong>，等待 <strong>2MSL</strong>（最大报文生存时间），确保服务器收到 <code>ACK</code> 后才完全释放连接。<br>服务器收到 ACK 后，进入 <strong>CLOSED 状态</strong>，彻底关闭连接。</li>
<li>客户端 –&gt; 服务器: <code>ACK, ack=y+1</code></li>
</ul>
</li>
</ul>
<p><strong>为什么需要四次挥手，而不是三次？</strong></p>
<p>TCP 是 <strong>全双工通信</strong>，<strong>数据的 发送和接收是独立的，所以需要分别关闭：</strong></p>
<p>前两次挥手：客户端请求关闭 发送通道，服务器确认<br>后两次挥手：服务器处理完剩余数据后，主动关闭 发送通道，客户端确认</p>
<p><strong>如果只用 三次挥手：</strong></p>
<p>服务器如果 还未发送完数据 就直接关闭，可能导致<strong>数据丢失</strong>。</p>
<p><strong>TIME-WAIT 状态与 2MSL 等待期</strong><br>TIME-WAIT 作用</p>
<ul>
<li>确保服务器收到最终的 <code>ACK</code><br>如果服务器没有收到 <code>ACK</code>，它会超时重发<code> FIN</code>，<strong>TIME-WAIT</strong> 允许客户端 重新发送 <code>ACK</code>。</li>
<li>防止旧连接数据干扰新连接<br>旧连接的数据可能在网络中滞留，<strong>TIME-WAIT</strong> 确保这些数据在新连接建立前被丢弃。</li>
</ul>
<p><strong>为什么等待 2MSL？</strong></p>
<p><strong>MSL</strong>（Maximum Segment Lifetime） 是一个 TCP 报文在网络中的最长存活时间。<br>等待 2MSL 确保网络中 所有旧数据包都已消失，避免影响新连接。</p>
<h4 id="HTTP的Keep-Alive是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？"><a href="#HTTP的Keep-Alive是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？" class="headerlink" title="HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？"></a>HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</h4><ul>
<li><p><strong>HTTP Keep-Alive</strong>	 <strong>HTTP 应用层</strong>。</p>
<ul>
<li>HTTP 的 <strong>Keep-Alive</strong> 机制允许 <strong>在同一个 TCP 连接上发送多个 HTTP 请求和响应</strong>，而不是在每个请求后都关闭 TCP 连接。</li>
<li><strong>目的</strong><ul>
<li>减少 TCP 连接的建立和关闭开销**，避免频繁的三次握手（建立连接）和四次挥手（关闭连接）。**</li>
<li>提高 HTTP 请求的性能**，减少请求延迟，提高服务器的吞吐量。**</li>
<li>减少服务器资源消耗，降低 CPU 和内存开销。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>TCP Keepalive</strong>    <strong>TCP 传输层</strong></p>
<ul>
<li>TCP 的 <strong>Keepalive 机制不是用来复用连接的，而是用于检测 TCP 连接是否仍然存活</strong>。当一个 TCP 连接长时间没有数据传输时，TCP Keepalive <strong>定期发送探测包</strong>，检查对端是否仍然在线，以避免资源浪费。</li>
<li><strong>目的</strong><ul>
<li><strong>检测并清理无效的 TCP 连接</strong>，防止服务器资源被僵尸连接占用。</li>
<li><strong>保持 NAT 设备中的 TCP 连接映射有效</strong>，防止 NAT 设备因长时间无数据而丢弃连接。</li>
</ul>
</li>
<li><strong>TCP Keepalive 的工作方式</strong><ul>
<li><strong>TCP 连接长时间没有数据传输</strong>（默认 2 小时）。<strong>内核发送 Keepalive 探测包</strong>，询问对方是否存活。</li>
<li><strong>如果对方正常响应</strong>，连接继续保持。<strong>如果连续多次探测无响应</strong>（如 3 次），TCP 认为对端失效，关闭连接。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>HTTP Keep-Alive 和 TCP Keepalive 的区别</strong></p>
<ul>
<li><strong>核心区别</strong><ul>
<li><strong>HTTP Keep-Alive 解决的是“重复建立连接的问题”</strong>，避免 HTTP 请求频繁创建新 TCP 连接。</li>
<li><strong>TCP Keepalive 解决的是“连接是否还存活的问题”</strong>，防止僵尸连接占用系统资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>机制</th>
<th>作用</th>
<th>适用协议</th>
<th>作用层次</th>
<th>触发方式</th>
<th>典型使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HTTP Keep-Alive</strong></td>
<td>复用 TCP 连接，减少握手开销</td>
<td>HTTP</td>
<td><strong>应用层</strong></td>
<td>HTTP 头部 <code>Connection: Keep-Alive</code></td>
<td>加速 HTTP 访问，减少 TCP 连接消耗</td>
</tr>
<tr>
<td><strong>TCP Keepalive</strong></td>
<td>检测 TCP 连接是否存活，防止僵尸连接</td>
<td>TCP</td>
<td><strong>传输层</strong></td>
<td>操作系统定期发送探测包</td>
<td>服务器维护长连接，检测对端是否存活</td>
</tr>
</tbody></table>
<h3 id="Day09"><a href="#Day09" class="headerlink" title="Day09"></a>Day09</h3><h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><p>DNS基本概念</p>
<ul>
<li><strong>DNS是什么？</strong><br>域名系统（Domain Name System）是将易记的域名（例如 <a target="_blank" rel="noopener" href="http://www.example.com)转换为计算机能识别的ip地址(例如/">www.example.com）转换为计算机能识别的IP地址（例如</a> 192.0.2.1）的分布式数据库系统。它类似于互联网的“电话簿”，使我们无需记住数字地址即可访问网站。</li>
<li><strong>DNS的作用</strong><br>DNS使得互联网用户可以通过友好的域名访问网站、邮件服务器等，同时提供一定的负载均衡和容错能力。</li>
</ul>
<p><strong>DNS查询的基本流程</strong></p>
<p><strong>用户发起请求</strong><br>当你在浏览器中输入一个URL时，操作系统和浏览器会检查各自的DNS缓存（以及Hosts文件），<br>如果已经存在该域名对应的IP地址，解析过程会立即结束；<br>如果没有命中，则向配置的本地域名解析器（DNS Resolver）发送请求。</p>
<p><strong>本地域名解析器处理请求（递归查询）</strong><br>本地DNS服务器通常采用递归查询方式，它负责替客户端查找最终的IP地址。<br>（<strong>递归查询</strong>由本地域名解析器替客户端完成所有查询过程，简化了客户端的操作。）</p>
<p>若自身缓存中没有记录，它会依次向其他DNS服务器发起查询。</p>
<p><strong>迭代查询过程</strong><br>本地域名解析器会按照以下步骤依次查询：</p>
<ul>
<li><strong>查询根DNS服务器</strong>：<br>根服务器不会返回具体的IP地址，而是告诉解析器该查询应转发到哪个顶级域（如.com、.net、.org）的DNS服务器。</li>
<li><strong>查询顶级域名服务器</strong>：<br>利用根服务器返回的信息，本地解析器向对应的顶级域名服务器发出查询。<br>顶级域名服务器同样不会直接返回目标IP，而是指向负责该域名的权威DNS服务器。</li>
<li><strong>查询权威DNS服务器</strong>：<br>本地DNS解析器最终向权威DNS服务器发送查询请求，权威服务器并返回具体的IP地址。<br>（权威DNS服务器是负责存储特定域名和IP地址映射的服务器）</li>
</ul>
<p><strong>返回结果</strong><br>得到IP地址后，本地域名解析器将结果缓存（以便下次查询更快响应），并将IP地址返回给客户端，浏览器随后使用该IP地址发起HTTP请求访问网站。</p>
<h4 id="CDN是什么，有什么作用？"><a href="#CDN是什么，有什么作用？" class="headerlink" title="CDN是什么，有什么作用？"></a>CDN是什么，有什么作用？</h4><p>CDN（内容分发网络）是一种由遍布全球各地的边缘服务器组成的分布式网络系统，<br>其核心目的是将网站的静态资源（如图片、CSS、JavaScript文件等）缓存在离用户最近的节点上，从而加速内容加载，降低延迟，提高网站性能和用户体验。</p>
<p><strong>工作原理</strong></p>
<ol>
<li><strong>用户请求</strong><br> 当用户在浏览器中请求某个网站时，DNS系统会将请求解析到CDN网络中离用户最近的<strong>边缘服务器</strong>。<ul>
<li><strong>调度系统</strong><br>通过DNS解析或Anycast技术，把用户请求引导到最优的CDN节点</li>
<li><strong>边缘服务器&#x2F;PoP（Point of Presence）</strong><br>分布在各地的节点，负责缓存内容并快速响应用户请求。</li>
</ul>
</li>
<li><strong>缓存内容</strong><ul>
<li><strong>边缘缓存</strong>：如果该边缘服务器已缓存了所需内容，则直接返回给用户，无需每次都访问源站。</li>
<li><strong>回源请求</strong>：如果缓存中没有，则边缘服务器会向源站（Origin Server）请求内容，并将获取到的内容缓存起来，以便后续请求使用。<ul>
<li><strong>缓存策略</strong><ul>
<li><strong>TTL（生存时间）</strong>：决定缓存内容在边缘节点中存留多久。</li>
<li><strong>缓存失效与更新策略</strong>：确保内容及时更新，比如通过主动刷新、定时更新或基于内容变更的触发机制。</li>
<li><strong>分层缓存</strong>：结合多级缓存结构，使不同类型的内容（静态与动态）能够有效缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>可用性</strong>：即使某些节点出现问题，用户请求可以被重定向到其他健康的节点。</li>
</ol>
<p><strong>主要优势与作用</strong></p>
<ul>
<li><strong>提升访问速度</strong><br> 用户可以从最近的节点获取内容，大幅降低延迟，加快页面加载速度。</li>
<li><strong>减轻源站压力</strong><br> 大量静态资源由CDN节点分担，源站不需要处理所有流量，降低服务器负载。</li>
<li><strong>提高可靠性与可用性</strong><br> 多个节点分布在全球，即使部分节点发生故障，其他节点仍能提供服务，增强整体稳定性。</li>
<li><strong>防御DDoS攻击</strong><br> 分布式架构能够吸收并分散恶意流量，提升抗攻击能力。</li>
<li><strong>改善用户体验</strong><br> 快速加载和更稳定的连接使用户获得更流畅的浏览体验，进而提高网站转化率和满意度。</li>
</ul>
<h4 id="Cookie和Session是什么？有什么区别？"><a href="#Cookie和Session是什么？有什么区别？" class="headerlink" title="Cookie和Session是什么？有什么区别？"></a>Cookie和Session是什么？有什么区别？</h4><ul>
<li><p><strong>Cookie</strong></p>
<ul>
<li>客户端&#x2F;浏览器发起HTTP请求后服务器通过 HTTP 响应头设置<code>Set-Cookie</code>值，<br>由服务器将一个或多个<code> Cookie</code> 发送到用户浏览器，然后浏览器将这些 <code>Cookie</code> 存储在本地。<br>服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的<code>Cookie</code>得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</li>
<li><code>Cookie</code>  存储容量较小，一般为几 KB<br>生命周期由服务器设置，通过HTTP请求自动发送</li>
<li>易被窃取、篡改、有传输风险（中间人截获）—&gt; HTTPS</li>
<li>存储小量非敏感信息，如用户个性化设置，临时状态等</li>
</ul>
</li>
<li><p><strong>Session</strong></p>
<ul>
<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是<code>Session</code>。（<code>Session</code>  数据存储在服务器上）</li>
<li>存储容量较大，通常没有固定限制，取决于服务器的配置和资源。<br>生命周期由服务器管理（默认与会话相关，通常在浏览器关闭后失效）<br><code>Session ID</code>  通常通过<code> Cookie</code>  或 URL 参数传递</li>
<li>Session 数据存储在服务器上，更难被用户访问和修改<br>（攻击者获取Session后也有可能冒充用户）</li>
<li>Session主要用于存储用户登录状态及权限信息、保存敏感数据和状态管理（在多步操作或交易中，存储临时数据，确保数据一致性）等</li>
</ul>
</li>
</ul>
<h3 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h3><h4 id="进程和线程之间有什么区别"><a href="#进程和线程之间有什么区别" class="headerlink" title="进程和线程之间有什么区别"></a>进程和线程之间有什么区别</h4><ul>
<li><strong>进程</strong><ul>
<li>进程是<strong>操作系统进行资源分配和调度的基本单位</strong>，<br><strong>每个进程拥有独立的内存空间、代码段、数据段以及系统资源。</strong></li>
<li><strong>独立内存空间</strong>：每个进程都有自己独立的地址空间，因此在创建和销毁时需要分配或回收较多资源，开销较大。<br><strong>上下文切换开销</strong>：进程切换时需要保存和恢复整个进程的状态，导致上下文切换开销较高。</li>
<li><strong>进程间通信（IPC）</strong>：由于进程相互隔离，通信必须依赖专门的机制，如管道、消息队列、共享内存等，这使得进程间通信相对复杂。</li>
<li><strong>隔离性高</strong>：进程之间相互隔离，一个进程的崩溃一般不会影响到其他进程，因而整体安全性和稳定性较好。</li>
</ul>
</li>
<li><strong>线程</strong><ul>
<li>线程是<strong>程序执行的最小单位</strong>，是进程内的执行单元。<br><strong>一个进程至少包含一个线程，也可以拥有多个线程，这些线程共享进程内的内存空间和资源</strong></li>
<li><strong>共享内存空间</strong>：同一进程中的所有线程共享内存和其他资源，因此创建和销毁线程的成本较低。<br><strong>轻量级切换</strong>：线程之间的切换只需保存少量的上下文信息，上下文切换速度快。</li>
<li><strong>直接共享数据</strong>：同一进程内的线程可以直接访问共享内存，因此线程间通信更为方便。但这种共享也可能引发数据竞争，需要使用互斥锁、信号量等同步机制进行协调。</li>
<li><strong>风险共享</strong>：由于同一进程内的线程共享内存和资源，一个线程出现错误（如非法内存访问）可能导致整个进程崩溃，从而影响系统稳定性。</li>
</ul>
</li>
</ul>
<p>在实际应用中，<br>如果需要高度的安全性和资源隔离，使用进程会更合适；<br>而如果追求高效的并发和轻量级的切换，线程则是更好的选择。</p>
<h4 id="并行和并发有什么区别"><a href="#并行和并发有什么区别" class="headerlink" title="并行和并发有什么区别"></a>并行和并发有什么区别</h4><p><strong>并行</strong>：</p>
<ul>
<li>同一时刻执行多个任务，在<strong>物理上</strong>同时执行。</li>
<li>需要多核 CPU 或多台计算机，每个核心或计算节点独立执行不同的任务。</li>
<li>并行旨在缩短任务的执行时间。</li>
<li>并行通过增加处理单元、同时执行多个任务来提高处理能力，<br>显著缩短总的执行时间，但需要考虑任务间的同步和通信开销。</li>
<li><strong>应用场景</strong>：适用于计算密集型任务，如科学计算、图像处理等，需要将大任务分解为可并行执行的子任务。</li>
<li>需要将任务有效地分解为独立的子任务，并处理任务间的协调和数据共享，增加了编程的复杂性。</li>
</ul>
<p><strong>并发</strong>：</p>
<ul>
<li>相同的时间段内执行多个任务，任务可能交替执行，通过调度实现，在<strong>逻辑上</strong>同时处理。</li>
<li>不要求物理上真正同时执行。例如，单核 CPU 通过任务切换来执行多个任务，使其看起来是同时运行的。</li>
<li>并发旨在提高资源利用率和系统吞吐量</li>
<li>通过共享资源（如CPU时间）、减少任务的等待时间，来提高系统的响应速度，<br>但频繁的上下文切换可能带来开销。</li>
<li><strong>应用场景</strong>：适用于需要同时处理大量任务且任务之间可能存在交互的场景，如Web服务器需要同时处理多个客户端请求。</li>
<li>需要处理任务间的同步和资源竞争问题，可能导致死锁、竞态条件等复杂情况。</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>并发（Concurrency）</th>
<th>并行（Parallelism）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>任务<strong>交替执行</strong>，宏观上同时进行</td>
<td>任务<strong>真正同时执行</strong></td>
</tr>
<tr>
<td><strong>依赖硬件</strong></td>
<td>不需要多核，单核也能并发</td>
<td>需要多核或多机</td>
</tr>
<tr>
<td><strong>执行方式</strong></td>
<td>任务<strong>切换</strong>执行</td>
<td>任务<strong>同时</strong>执行</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>I&#x2F;O 密集型任务，如 Web 服务器处理多个请求</td>
<td>CPU 密集型任务，如深度学习计算</td>
</tr>
<tr>
<td><strong>实现难度</strong></td>
<td>需要线程管理、同步机制</td>
<td>需要高性能硬件、数据分割</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Python 中的 <code>asyncio</code>，Java 多线程</td>
<td>OpenMP、CUDA 并行计算</td>
</tr>
</tbody></table>
<ul>
<li><strong>并发可以实现并行</strong>：在多核 CPU 或分布式环境下，并发任务可以被调度到不同核心或机器上，形成真正的并行执行。</li>
<li><strong>并行通常包含并发</strong>：并行任务可能需要协调、通信，而协调机制通常涉及并发编程。</li>
</ul>
<h4 id="解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？"><a href="#解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？" class="headerlink" title="解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？"></a>解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？</h4><p>用户态和内核态是 CPU 的两种运行模式，主要用于<strong>保护系统资源和控制访问权限</strong>。</p>
<ul>
<li><strong>用户态</strong>：<ul>
<li>普通应用程序运行的环境，权限受限，不能直接访问硬件。</li>
<li>只能执行普通指令，若需要访问操作系统资源，必须通过<strong>系统调用</strong>进入内核态。</li>
</ul>
</li>
<li><strong>内核态</strong>：<ul>
<li>操作系统内核运行的环境，拥有最高权限，可直接管理<strong>进程、内存、I&#x2F;O 设备</strong>等。</li>
<li>允许执行特权指令，如<strong>控制硬件、修改内存管理单元（MMU）状态</strong>等。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>用户态（User Mode）</th>
<th>内核态（Kernel Mode）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>特权级别</strong></td>
<td>低（受限制）</td>
<td>高（完全访问权限）</td>
</tr>
<tr>
<td><strong>执行主体</strong></td>
<td>应用程序</td>
<td>操作系统内核</td>
</tr>
<tr>
<td><strong>访问硬件</strong></td>
<td>不能直接访问</td>
<td>可直接操作硬件</td>
</tr>
<tr>
<td><strong>指令权限</strong></td>
<td>仅普通指令</td>
<td>可执行特权指令</td>
</tr>
<tr>
<td><strong>稳定性</strong></td>
<td>高（程序崩溃不影响系统）</td>
<td>低（内核崩溃导致系统崩溃）</td>
</tr>
</tbody></table>
<p><strong>用户态和内核态的切换场景</strong></p>
<p>CPU 运行时，可能因以下原因从用户态切换到内核态：</p>
<ol>
<li><strong>系统调用（System Call）</strong><ul>
<li>当用户进程需要操作文件、访问网络、分配内存等，需要调用操作系统提供的服务。<br>例如 <code>read()</code>, <code>write()</code>, <code>open()</code> 等函数，最终会触发软中断（Trap），CPU 切换到内核态执行内核代码。</li>
</ul>
</li>
<li><strong>异常（Exception）</strong><ul>
<li>当用户程序执行非法操作（如除零、访问非法内存）时，CPU 触发异常，进入内核态，交由操作系统处理。</li>
</ul>
</li>
<li><strong>中断（Interrupt）</strong><ul>
<li>外设（键盘、网络、磁盘等）发送中断信号，CPU 停止当前任务，切换到内核态执行中断处理程序（ISR）。</li>
<li>例如：<ul>
<li>键盘输入触发中断，CPU 进入内核态读取输入数据。</li>
<li>磁盘 I&#x2F;O 完成后触发中断，通知操作系统数据已准备就绪。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><strong>用户态：</strong> 运行普通应用，权限受限，不能直接访问硬件。</li>
<li><strong>内核态：</strong> 运行操作系统，完全控制系统资源，可直接访问硬件。</li>
<li><strong>切换场景：</strong> 通过<strong>系统调用、异常、中断</strong>切换到内核态。</li>
</ul>
<h3 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h3><h4 id="进程调度算法你了解多少"><a href="#进程调度算法你了解多少" class="headerlink" title="进程调度算法你了解多少"></a>进程调度算法你了解多少</h4><ol>
<li><strong>先来先服务（FCFS）</strong>：<ul>
<li><strong>特点</strong>：按照进程的到达顺序进行调度，最简单的调度算法。</li>
<li><strong>缺点</strong>：由于没有考虑进程的运行时间，可能会导致长作业占用CPU较长时间，导致短作业的等待时间过长，产生“convoy effect”。</li>
</ul>
</li>
<li><strong>最短作业优先（SJF）</strong>：<ul>
<li><strong>特点</strong>：非抢占式调度，优先调度估计运行时间最短的进程。</li>
<li><strong>缺点</strong>：需要知道进程的运行时间，且可能导致长作业永远得不到调度，出现“饥饿”现象。实际系统中通常采用估算方法来解决这个问题。</li>
</ul>
</li>
<li><strong>最短剩余时间优先（SRTF）</strong>：<ul>
<li><strong>特点</strong>：基于最短作业优先（SJF）的抢占式调度算法。每当一个新的进程到达时，比较其剩余运行时间与当前正在执行进程的剩余时间。如果新进程的剩余时间更短，当前进程被挂起，转而执行新进程。</li>
<li><strong>缺点</strong>：可能导致频繁的上下文切换，增加系统开销。</li>
</ul>
</li>
<li><strong>优先级调度（Priority Scheduling）</strong>：<ul>
<li><strong>特点</strong>：每个进程都有一个优先级，系统根据优先级来决定调度顺序。高优先级的进程会优先执行。</li>
<li><strong>缺点</strong>：可能会导致低优先级进程“饥饿”，即长时间无法获得调度。为了解决这个问题，通常会引入优先级提升机制，使等待时间过长的进程逐渐获得更高的优先级。</li>
</ul>
</li>
<li><strong>时间片轮转（RR）</strong>：<ul>
<li><strong>特点</strong>：每个进程轮流执行，分配一个固定的时间片。当时间片用完后，进程会被挂起，调度下一个进程执行，直到所有进程执行完毕。</li>
<li><strong>缺点</strong>：如果时间片设置过大，可能导致响应时间较长；如果时间片设置过小，频繁的上下文切换会增加系统开销。</li>
</ul>
</li>
<li><strong>多级队列（Multilevel Queue Scheduling）</strong>：<ul>
<li><strong>特点</strong>：将进程按照优先级分为多个队列，不同队列使用不同的调度算法。例如，高优先级队列使用时间片轮转调度，而低优先级队列使用先来先服务（FCFS）等。</li>
<li><strong>优点</strong>：可以在不同类型的任务间进行合理的调度，确保高优先级任务不会被低优先级任务干扰。</li>
<li><strong>缺点</strong>：由于每个队列使用不同的调度算法，可能导致进程之间的切换较为复杂。</li>
</ul>
</li>
</ol>
<h4 id="进程间有哪些通信方式-进程间通信（IPC）"><a href="#进程间有哪些通信方式-进程间通信（IPC）" class="headerlink" title="进程间有哪些通信方式 &#x2F; 进程间通信（IPC）"></a>进程间有哪些通信方式 &#x2F; 进程间通信（IPC）</h4><ol>
<li><strong>管道（Pipe）</strong><ul>
<li>半双工，只能实现单向数据流动；用于父子进程或具有血缘关系的进程间通信。<br>常见于命令行中多个命令的连接，例如 <code>ls | grep txt</code>。<ul>
<li>半双工（Half-duplex）通信方式：<br>通信双方都能发送和接收数据，但同一时间只能有一个方向在传输数据，不能同时进行双向通信。</li>
</ul>
</li>
</ul>
</li>
<li><strong>命名管道（FIFO）</strong><ul>
<li>与管道类似，同样是半双工，但由于它有名字，可以在不相关的进程之间通信（无需进程之间的血缘关系）<br>常用于需要临时建立进程间数据传递通道的场景</li>
</ul>
</li>
<li><strong>消息队列</strong><ul>
<li>内核维护一个消息链表，允许进程发送格式化的消息，并支持消息优先级；通信是异步的。<br>适用于客户端—服务器模式和复杂的事件传递场景。</li>
</ul>
</li>
<li><strong>信号</strong><ul>
<li>用于向进程发送异步通知，告知某种事件的发生，通常只传递信号编号；处理函数要求尽可能简单。<br>处理用户中断（例如Ctrl+C）、定时器事件或其他异常情况。</li>
</ul>
</li>
<li><strong>信号量</strong><ul>
<li>作为计数器使用，控制多个进程或线程对共享资源的访问，通常用来实现互斥和同步。<br>解决<strong>生产者-消费者问题</strong>、资源管理和进程同步问题。</li>
</ul>
</li>
<li><strong>共享内存</strong><ul>
<li>将一段内存映射到多个进程的地址空间中，实现高速数据共享；<br>但必须借助同步机制（如互斥锁、信号量）避免竞态条件。<br>适用于大数据量、高性能的通信场景，如实时数据处理和数据库缓存。</li>
</ul>
</li>
<li><strong>Socket套接字</strong><ul>
<li>全双工，支持TCP&#x2F;IP 的网络通信的基本操作单元，<br>主要用于在客户端和服务器之间通过网络进行通信、网络应用开发以及分布式系统</li>
</ul>
</li>
</ol>
<p><strong>安全问题与预防</strong></p>
<ul>
<li><strong>竞态条件</strong>：多个进程同时访问共享数据时，若没有适当的同步机制（如互斥锁或信号量），数据可能会因操作顺序不确定而出错。<br><strong>预防</strong>：在共享内存等方式中使用锁机制或原子操作，确保临界区内操作互斥执行。</li>
<li><strong>死锁</strong>：当多个进程相互等待对方释放资源时，会导致所有进程永远阻塞。<br> <strong>预防</strong>：<ul>
<li>遵循固定顺序申请资源，避免循环等待；</li>
<li>使用超时机制，在无法获取资源时及时放弃重试；</li>
<li>尽量缩小临界区，减少持锁时间。</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li><strong>简单数据传输</strong>：使用<strong>管道</strong>或<strong>命名管道</strong>。</li>
<li><strong>异步消息传递</strong>：使用<strong>消息队列</strong>进行复杂的进程间通信。</li>
<li><strong>高性能数据共享</strong>：<strong>共享内存</strong>是最快的方式，但需要额外的同步控制。</li>
<li><strong>网络通信</strong>：使用<strong>Socket</strong>进行客户端与服务器间的数据交换。</li>
</ul>
<h4 id="解释一下进程同步和互斥，以及如何实现进程同步和互斥"><a href="#解释一下进程同步和互斥，以及如何实现进程同步和互斥" class="headerlink" title="解释一下进程同步和互斥，以及如何实现进程同步和互斥"></a>解释一下进程同步和互斥，以及如何实现进程同步和互斥</h4><p>进程同步和互斥是确保多个并发执行的进程或线程在访问共享资源时<br>不会产生数据错误和逻辑冲突的两种关键机制。</p>
<p><strong>进程同步</strong></p>
<ul>
<li>进程同步指的是多个并发执行的进程之间协调和管理它们的执行顺序或执行时机，<br> 以保证它们按照预期的顺序或时间间隔执行。<br> 这对于一些依赖于前后顺序的操作（例如生产者消费者问题）尤为重要。</li>
<li>主要目的是保证<strong>数据一致性</strong>和<strong>程序正确性</strong>，即确保在某些操作发生前，必须满足特定条件或顺序。<br> 例如，消费者在取出数据之前，必须等待生产者将数据写入缓冲区。</li>
</ul>
<p><strong>互斥</strong></p>
<ul>
<li>互斥指的是在某一时刻只允许一个进程（或线程）访问某个共享资源，<br> 防止多个进程同时进入临界区，从而避免数据竞争（Race Condition）。</li>
<li>主要是保证共享资源（如共享内存、全局变量、文件等）在同一时间内不被多个进程同时修改，确保<strong>操作的原子性</strong>和<strong>数据的完整性</strong>。</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li><p><strong>信号量和 PV 操作</strong></p>
<ul>
<li><p><strong>信号量</strong>：特殊的变量，用来表示系统中某种资源的数量或状态。</p>
</li>
<li><p><strong>PV操作</strong></p>
<ul>
<li><strong>P操作（“检查”信号量）</strong>：进入临界区前。如果信号量的值大于0，则将其减1并允许进程进入；若为0，则进程将被阻塞，等待资源释放。</li>
<li><strong>V操作（“归还”资源）</strong>：退出临界区时，将信号量的值加1，并唤醒因P操作而阻塞的进程。</li>
</ul>
</li>
<li><p>这种机制既可以实现<strong>互斥</strong>（当信号量初始值为1时，相当于互斥锁），也可以<strong>控制有限资源的访问</strong>（计数信号量）。</p>
</li>
</ul>
</li>
<li><p><strong>临界区与互斥锁（Mutex）</strong></p>
<ul>
<li><strong>临界区</strong>：<br>访问共享资源的代码段 &#x2F; 可能引发互斥问题的代码。<br>在进入临界区前，必须先获取相应的锁（互斥锁）；离开时释放锁，<br>从而保证同一时刻只有一个进程能够执行临界区内的代码。</li>
<li><strong>互斥锁</strong>：<br>每个共享资源都关联一个互斥锁，只有获得该锁的进程才能进入临界区访问资源。<br>互斥锁是一种常用的实现互斥的方法，其工作原理简单且直观。</li>
</ul>
</li>
<li><p><strong>条件变量</strong></p>
<ul>
<li><strong>条件变量</strong>：<br>条件变量通常与互斥锁配合使用，并采用<code>while循环</code>检查条件以防止假唤醒。<br>用于让进程在特定条件下（例如缓冲区非空或非满）<strong>等待&#x2F;进入阻塞状态</strong> 或 被<strong>唤醒</strong>。</li>
<li>在临界区内，进程检查某一条件是否满足，如果不满足，则调用等待操作（例如<code>wait()</code>），这会自动释放互斥锁并将进程挂起；<br>当其他进程改变了共享状态后，调用通知操作（例如<code>signal()</code>或<code>notify()</code>），唤醒等待的进程，然后重新获得互斥锁继续执行。</li>
</ul>
</li>
</ul>
<h3 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h3><h4 id="什么是死锁，如何避免死锁？"><a href="#什么是死锁，如何避免死锁？" class="headerlink" title="什么是死锁，如何避免死锁？"></a>什么是死锁，如何避免死锁？</h4><p>系统中多个进程&#x2F;线程分别持有部分资源，且<strong>相互等待</strong>其他进程释放它们所需的资源而造成的一种僵局</p>
<p><strong>死锁同时满足四个条件，破坏其一即可预防</strong></p>
<ul>
<li><strong>互斥条件</strong>：资源不能被多个进程共享<ul>
<li>某些资源（如读操作）可以设计为共享模式，降低互斥资源的使用场景</li>
</ul>
</li>
<li><strong>请求保持条件</strong>：进程在等待新的资源而阻塞时不会释放自己的资源。<ul>
<li>采用一次性申请策略：<br>进程在开始执行前一次性申请所有需要的资源；<br>若无法全部获得，则不占有任何资源，待所有资源可用时再执行。</li>
<li>或者采用动态释放策略：<br>在申请资源时如果发现无法一次性满足所有资源要求，<br>则释放当前已占用资源，等待一段时间后重试。</li>
</ul>
</li>
<li><strong>不可剥夺条件</strong>：资源在未使用完之前，不能被操作系统&#x2F;其他进程强制收回，只能由进程自己释放。<ul>
<li>资源分配时允许抢占：<br>进程请求新资源而系统检测到可能发生死锁时，可暂时剥夺其他进程占用的部分资源分配给请求者</li>
</ul>
</li>
<li><strong>循环等待条件</strong>：系统中存在进程循环链，每个进程都在等待链中下一个进程所占有的资源，形成闭环。<ul>
<li>为所有资源设定一个全局的顺序：<br>要求所有进程按照相同顺序申请资源，防止形成循环等待。<br>例如，规定进程申请资源时必须先申请编号较小的，再申请编号较大的资源，避免出现闭环等待。</li>
</ul>
</li>
</ul>
<p><strong>无法完全预防死锁的情况下，系统可以采用检测与恢复机制</strong></p>
<ul>
<li><p><strong>死锁检测</strong></p>
<ul>
<li><strong>资源分配图检测</strong>：构建资源分配图或等待图，定期检查是否存在环路。若存在闭环，则说明可能发生了死锁。</li>
<li><strong>银行家算法</strong>：通过模拟资源分配过程来判断系统是否进入不安全状态。</li>
</ul>
</li>
<li><p><strong>死锁解除</strong>：一旦检测到死锁，可以采取如下措施解除：</p>
<ul>
<li><strong>进程中止</strong>：选择中止一个或多个处于死锁状态的进程，以打破循环等待。</li>
<li><strong>资源抢占</strong>：强制收回某些进程已经占用的资源，使系统重新恢复到安全状态。</li>
<li><strong>回滚机制</strong>：事务性系统中，通过回滚部分操作来释放资源，重新执行操作，确保系统数据一致性。</li>
</ul>
</li>
</ul>
<h4 id="介绍一下几种典型的锁"><a href="#介绍一下几种典型的锁" class="headerlink" title="介绍一下几种典型的锁"></a>介绍一下几种典型的锁</h4><p><strong>互斥锁</strong>：</p>
<ul>
<li><p>任何时刻只有一个线程能够进入临界区访问&#x2F;修改资源。<br>其他线程等待该锁释放后获取，保证<strong>资源的一致性</strong>。</p>
</li>
<li><p><strong>优点</strong>：实现简单，能有效防止数据并发修改引发的不一致问题。<br><strong>缺点</strong>：但在高并发场景下容易引起线程阻塞和上下文切换，进而影响系统性能。</p>
</li>
<li><p><strong>适用场景</strong></p>
<ul>
<li>需要独占访问共享数据的场合（如写操作）、</li>
<li>数据竞争较严重的环境。</li>
</ul>
</li>
</ul>
<p><strong>自旋锁</strong></p>
<ul>
<li>自旋锁与互斥锁的作用类似，都用于保护共享资源。<br>但自旋锁获取不到锁时不会让线程进入睡眠状态，<br>而是采用忙等待（busy waiting）的方式<strong>不断轮询</strong>锁的状态，直到锁可用。</li>
<li><strong>优点</strong>：避免了线程切换带来的开销，延迟较低。<br><strong>缺点</strong>：如果锁等待时间较长，会占用CPU资源，导致资源浪费；在单核系统上效果较差。</li>
<li><strong>适用场景</strong><ul>
<li>持锁时间非常短的临界区，能降低线程切换的开销、</li>
<li>多核处理器环境中，适合使用自旋锁，因为忙等待期间其他线程可在其他核上执行。</li>
</ul>
</li>
</ul>
<p><strong><code>互斥锁</code>和<code>自旋锁</code>是最基本的两种锁机制。</strong><br><strong>高级锁（如读写锁、悲观锁和乐观锁）的实现往往是基于这两种基本机制的扩展或改进</strong></p>
<p><strong>读写锁</strong></p>
<ul>
<li>在互斥锁基础上的扩展，特点是允许多个线程同时执行<strong>读操作</strong>，但在执行<strong>写操作</strong>时要求<strong>独占访问</strong>。<br>即在<strong>写操作</strong>进行时，不允许其他线程进行读或写操作，从而保证<strong>数据的完整性</strong>。</li>
<li><strong>优点</strong>：能显著提高读密集型应用的并发性能，减少锁竞争。<br><strong>缺点</strong>：如果写操作频繁，可能会出现写饥饿或整体性能下降的情况，同时实现上比互斥锁复杂。</li>
<li><strong>适用场景</strong><ul>
<li>读操作远多于写操作的场合，如缓存系统或配置文件的读取、</li>
<li>需要在保证数据一致性的同时提高系统并发度。</li>
</ul>
</li>
</ul>
<p><strong>悲观锁</strong></p>
<ul>
<li>悲观锁 假定 <code>在并发环境下数据冲突 / 多线程同时修改共享资源</code> 的概率比较高<br>在访问共享资源时一律上锁，确保在操作过程中不会发生并发冲突（如数据库中常见的行级锁和表级锁）</li>
<li><strong>优点</strong>：安全性高，能有效防止并发冲突。<br><strong>缺点</strong>：加锁时间较长可能会降低系统吞吐量，引发较多的阻塞等待。</li>
<li><strong>适用场景</strong><ul>
<li>多线程或多进程写操作较多、冲突频繁的场景，如金融系统中的账户转账。</li>
<li>数据一致性要求非常高的业务逻辑。</li>
</ul>
</li>
</ul>
<p><strong>乐观锁</strong></p>
<ul>
<li>乐观锁基于“冲突较少”的假设，在操作共享资源时不立即加锁，而是在更新时检测数据是否被其他线程修改。<br>常见的实现方式有基于版本号（versioning）或时间戳的比较，在冲突检测到时，放弃本次修改或者重试操作。</li>
<li><strong>优点</strong>：无需长时间持有锁，可以极大地提高并发性能。<br><strong>缺点</strong>：在高冲突环境下，频繁的冲突检测和重试会影响整体效率，同时实现逻辑较为复杂。</li>
<li><strong>适用场景</strong><ul>
<li>读操作远多于写操作的场景，如用户信息更新、库存扣减等。</li>
<li>并发冲突发生概率较低的系统中，能最大限度地减少锁竞争。</li>
</ul>
</li>
</ul>
<p><strong>选择策略</strong></p>
<ul>
<li><strong>互斥锁</strong>适用于简单的独占访问场景；<strong>自旋锁</strong>适用于临界区操作短、上下文切换成本较高的场合；</li>
<li><strong>读写锁</strong>在读多写少的场景中能显著提升并发性能；</li>
<li><strong>悲观锁</strong>在高冲突、高一致性要求的场合较为稳妥；<strong>乐观锁</strong>则适合冲突较少、追求高并发性能的场景。</li>
</ul>
<h4 id="讲一讲你理解的虚拟内存"><a href="#讲一讲你理解的虚拟内存" class="headerlink" title="讲一讲你理解的虚拟内存"></a>讲一讲你理解的虚拟内存</h4><ul>
<li><strong>定义和工作原理</strong><ul>
<li>虚拟内存为每个进程提供一个看似连续的虚拟地址空间，其实际<strong>映射</strong>关系由页表维护，<br>利用内存管理单元（MMU）完成虚拟地址到物理地址的转换。</li>
<li>当某个虚拟页面不在物理内存中时，会触发缺页异常，操作系统负责将该页面从硬盘（交换区）调入内存。</li>
</ul>
</li>
<li><strong>页置换算法的作用</strong><ul>
<li>当物理内存资源不足时，操作系统会采用页置换算法（例如FIFO、LRU等）来决定哪些页面需要被换出，从而为新加载的页面腾出内存空间。</li>
</ul>
</li>
<li><strong>虚拟内存的优点与可能的性能问题</strong><ul>
<li>优点<ul>
<li>扩展内存容量，使程序能够使用超过实际物理内存大小的内存空间。</li>
<li>提供内存隔离，确保各进程之间的内存安全。</li>
<li>通过内存映射文件技术，实现高效的文件I&#x2F;O操作。</li>
</ul>
</li>
<li>性能问题<ul>
<li>频繁的缺页异常和页面交换可能引发I&#x2F;O瓶颈，从而降低系统性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h3><h4 id="你知道的线程同步的方式有哪些？"><a href="#你知道的线程同步的方式有哪些？" class="headerlink" title="你知道的线程同步的方式有哪些？"></a>你知道的线程同步的方式有哪些？</h4><p>线程同步机制：多线程编程中保证线程之间的互不干扰的机制</p>
<ul>
<li><p><strong>互斥锁</strong></p>
<ul>
<li>用于保护共享资源，使任一时刻只有一个线程能进入临界区，防止多个线程同时修改数据，确保数据一致性。</li>
<li><strong>优点</strong>：实现简单、适用性广。<br><strong>缺点</strong>：如果使用不当可能会导致线程长时间等待甚至死锁，锁粒度过大时会降低并发性能。</li>
</ul>
</li>
<li><p><strong>自旋锁</strong></p>
<ul>
<li>自旋锁在等待锁时不会挂起线程，而是通过忙等待（不断循环检测锁状态）保持对锁的占用，适用于临界区执行时间非常短的情况。</li>
<li><strong>优点</strong>：避免线程挂起与上下文切换，适合多核系统中短时竞争场景。<br><strong>缺点</strong>：如果等待时间较长，自旋会占用大量CPU资源，可能导致效率低下。</li>
</ul>
</li>
<li><p><strong>读写锁</strong></p>
<ul>
<li>读写锁允许多个线程并发读取共享数据，但写操作时要求独占访问。<br>这种机制在读操作远多于写操作时能显著提高并发性能。</li>
<li><strong>优点</strong>：在读多写少的场景下能提高系统整体并发性。<br><strong>缺点</strong>：实现较复杂，可能出现写者饥饿（长时间等待写入）的情况。</li>
</ul>
</li>
<li><p><strong>条件变量</strong></p>
<ul>
<li>条件变量允许线程在等待特定条件（如队列不为空、资源可用等）时进入睡眠状态，<br>避免忙等待。通常需要与互斥锁结合使用，确保状态检查与等待操作的原子性。</li>
<li><strong>优点</strong>：有效降低CPU空转，适合事件触发和生产者-消费者模型。<br><strong>缺点</strong>：使用时逻辑较复杂，容易出错，必须保证条件的正确性和通知的及时性。</li>
</ul>
</li>
<li><p><strong>信号量</strong></p>
<ul>
<li>信号量是一种基于计数器的同步机制，用于控制对共享资源的访问数量。<br>二值信号量（值为1）可用于实现互斥，而计数信号量允许多个线程同时访问有限的资源（如连接池）。</li>
<li><strong>优点</strong>：灵活控制并发访问的数量，适用于有限资源的管理。<br><strong>缺点</strong>：管理和调试较复杂，容易因计数错误导致资源泄露或竞争问题。</li>
</ul>
</li>
</ul>
<p><strong>如何选择合适的线程同步机制</strong></p>
<ul>
<li><strong>资源访问方式</strong>：  <ul>
<li>需要严格互斥时优先使用<strong>互斥锁</strong>；  </li>
<li>临界区执行时间非常短且竞争不激烈时，<strong>自旋锁</strong>可以减少上下文切换；  </li>
<li>对共享数据的读操作远多于写操作时，使用<strong>读写锁</strong>能提高并发度。</li>
</ul>
</li>
<li><strong>线程间通信</strong>：  <ul>
<li>当线程需要等待某个条件满足时，<strong>条件变量</strong>是理想的选择；  </li>
<li>对于管理有限资源访问，<strong>信号量</strong>能有效控制同时访问的线程数。</li>
</ul>
</li>
</ul>
<h4 id="有哪些页面置换算法"><a href="#有哪些页面置换算法" class="headerlink" title="有哪些页面置换算法"></a>有哪些页面置换算法</h4><ul>
<li><p><strong>最佳置换算法（OPT）</strong></p>
<ul>
<li>根据未来页面访问情况，选择最长时间内不会被访问的页面进行淘汰。</li>
<li>理论上缺页率最低，常作为性能下界参考；<br>实际中无法实现，因为操作系统无法预知未来的页面访问序列。</li>
<li><strong>适用场景</strong>：理论研究和算法性能比较时使用。</li>
</ul>
</li>
<li><p><strong>先进先出算法（FIFO）</strong></p>
<ul>
<li>按照页面进入内存的顺序，最早进入的页面先被淘汰。</li>
<li>实现简单，但可能会淘汰仍在被频繁使用的页面，<br>容易出现“Belady 异常”（增加内存反而缺页率上升）。</li>
<li><strong>适用场景</strong>：<br>对实现要求简单且不追求最优性能的场景。</li>
</ul>
</li>
<li><p><strong>最近最久未使用算法（LRU）</strong></p>
<ul>
<li>利用页面历史访问记录，淘汰最长时间未被访问的页面。</li>
<li>符合程序时间局部性原理，缺页率较低；<br>但需要维护访问顺序或时间戳，开销相对较大。</li>
<li><strong>适用场景</strong>：应用于大部分实际系统，尤其适合访问模式具有明显时间局部性的场景。</li>
</ul>
</li>
<li><p><strong>时钟算法（Clock）</strong></p>
<ul>
<li>利用环形队列和页面的引用位来近似实现 LRU。时钟指针遍历页面，<br>当遇到引用位为 0 的页面时进行置换；若引用位为 1，则清零后继续查找。</li>
<li>实现较简单，开销低，能够较好地平衡实现复杂性和性能，是 LRU 的一种高效近似算法。</li>
<li><strong>适用场景</strong>：实际操作系统中广泛采用，特别是在硬件资源有限、需要降低实现成本的场景。</li>
</ul>
</li>
<li><p><strong>最不经常使用算法（LFU）</strong></p>
</li>
<li><p>记录页面访问频率，淘汰访问次数最少的页面。</p>
</li>
<li><p>能反映页面的长期使用情况，适用于访问模式相对稳定的环境；<br>但对突发性或短期变化响应不够敏感，维护访问计数也会增加额外开销。</p>
</li>
<li><p><strong>适用场景</strong>：用于那些页面访问频率变化较小的系统，但在动态环境下可能不够灵活。</p>
</li>
</ul>
<p><strong>如何选择</strong></p>
<ul>
<li><strong>理论与实际折中</strong>：<br> 虽然最佳置换算法（<strong>OPT</strong>）理论上最优，但实际中无法实现，<br>因此常用 <strong>LRU</strong> 或其近似算法（如 <strong>Clock</strong>）来兼顾性能和实现复杂度。</li>
<li><strong>实现复杂度与系统特性</strong>：<br><strong>FIFO</strong> 实现简单，但在某些场景下可能性能不佳；<br>而 <strong>LRU</strong> 和 <strong>LFU</strong> 虽然性能较优，但开销较大，需要额外的数据结构支持。</li>
<li><strong>工作负载特点</strong>：<br>根据系统的内存容量、访问局部性（时间或频率）以及实际工作负载，<br>选择合适的算法可以在资源利用和系统响应之间取得平衡。</li>
</ul>
<h3 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h3><h4 id="熟悉哪些Linux命令"><a href="#熟悉哪些Linux命令" class="headerlink" title="熟悉哪些Linux命令"></a>熟悉哪些Linux命令</h4><p><strong>文件操作：</strong></p>
<ul>
<li><code>ls</code>：列出目录内容、<code>cd</code>：更改当前工作目录、<br><code>pwd</code>：显示当前工作目录路径。</li>
<li><code>cp</code>：复制文件或目录、<br><code>mv</code>：移动或重命名文件或目录、<code>rm</code>：删除文件或目录。</li>
<li><code>touch</code>：创建空文件或更新文件的时间戳。</li>
<li><code>mkdir</code>：创建新目录、<code>rmdir</code>：删除空目录。</li>
</ul>
<p><strong>文件内容查看：</strong></p>
<ul>
<li><code>cat</code>：连接并显示文件内容。<br><code>head</code>：显示文件的前几行。<br><code>tail</code>：显示文件的后几行，常用于查看日志文件。</li>
<li><code>more</code>：分页显示文件内容。<br><code>less</code>：与 <code>more</code> 类似，但提供更强大的导航功能。</li>
</ul>
<p><strong>权限管理：</strong></p>
<ul>
<li><code>chmod</code>：更改文件或目录的访问权限。<br><code>chown</code>：更改文件或目录的所有者和&#x2F;或所属组。</li>
</ul>
<p><strong>磁盘管理：</strong></p>
<ul>
<li><code>df</code>：显示文件系统的磁盘空间使用情况。<br><code>du</code>：估算文件和目录的磁盘使用情况。</li>
<li><code>fdisk</code>：用于磁盘分区的管理工具。</li>
<li><code>mount</code>：挂载文件系统。<br><code>umount</code>：卸载已挂载的文件系统。</li>
</ul>
<p><strong>网络管理：</strong></p>
<ul>
<li><code>ifconfig</code>&#x2F;<code>ip addr</code>：显示或配置网络接口。</li>
<li><code>ping</code>：测试与主机的网络连接。</li>
<li><code>netstat</code>：显示网络连接、路由表和接口统计信息。</li>
<li><code>ssh</code>：通过安全外壳协议远程登录。<br><code>scp</code>：通过 SSH 进行安全的文件复制。<br><code>ftp</code>：文件传输协议客户端，用于在网络上传输文件。</li>
</ul>
<p><strong>进程管理：</strong></p>
<ul>
<li><code>ps</code>：显示当前进程的快照。<br><code>top</code>：实时显示系统中各个进程的资源使用情况。</li>
<li><code>kill</code>：向进程发送信号（通常用于终止进程）。<br><code>killall</code>：通过进程名终止所有匹配的进程。</li>
<li><code>bg</code>：将进程放到后台运行、<code>fg</code>：将后台进程带到前台运行。</li>
</ul>
<p><strong>软件包管理：</strong></p>
<ul>
<li><code>apt-get</code>：Debian 系列发行版的包管理工具，用于安装、更新和删除软件包。<br><code>yum</code>：Red Hat 系列发行版的包管理工具，用于安装、更新和删除软件包。</li>
<li><code>rpm</code>：Red Hat Package Manager，用于安装、查询、验证、更新和卸载 RPM 包。<br><code>dpkg</code>：Debian 包管理器，用于安装、构建、删除和管理 Debian 软件包。</li>
</ul>
<h4 id="Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用"><a href="#Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用" class="headerlink" title="Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用"></a>Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用</h4><p><strong>1. 查看进程</strong></p>
<ul>
<li>方法：<ul>
<li>使用 <code>ps aux</code> 或 <code>ps -ef</code> 命令列出当前所有进程及详细信息。</li>
<li>使用 <code>top</code> 或 <code>htop</code> 命令实时监控进程的运行状态和资源占用情况。</li>
</ul>
</li>
</ul>
<p><strong>2. 杀死进程</strong></p>
<ul>
<li>方法：<ul>
<li>首先使用 <code>ps</code> 或 <code>top</code> 命令查找目标进程的 PID（进程ID）。</li>
<li>然后使用 <code>kill PID</code> 命令发送终止信号（默认 SIGTERM）来请求进程结束。</li>
<li>如果进程无法正常退出，可使用 <code>kill -9 PID</code> 强制终止进程。</li>
</ul>
</li>
</ul>
<p><strong>3. 查看端口占用</strong></p>
<ul>
<li>方法：<ul>
<li>使用 <code>lsof -i:端口号</code> 命令可以列出占用特定端口的进程信息。</li>
<li>或者使用 <code>netstat -tulnp | grep 端口号</code> 命令查看该端口的监听状态和相关进程ID。</li>
<li>另外，<code>ss -tulnp | grep 端口号</code> 也是常用的工具，输出信息类似于 netstat，但速度更快。</li>
</ul>
</li>
</ul>
<h4 id="说一下-select、poll、epoll"><a href="#说一下-select、poll、epoll" class="headerlink" title="说一下 select、poll、epoll"></a>说一下 select、poll、epoll</h4><ul>
<li><strong>select</strong><ul>
<li><strong>原理</strong>：传入一个固定大小的文件描述符集合，内核逐一检查这些描述符是否有可读、可写或异常事件。</li>
<li><strong>特点与限制</strong>：实现简单、兼容性好，但受限于最大描述符数（通常为1024）且每次调用都需要遍历整个集合，效率随描述符数量增加而下降。</li>
</ul>
</li>
<li><strong>poll</strong><ul>
<li><strong>原理</strong>：使用动态数组（pollfd数组）来监控多个文件描述符，避免了select固定数量的限制。</li>
<li><strong>特点与限制</strong>：克服了文件描述符数量的限制，但同样需要遍历整个数组，性能随描述符数量线性下降，拷贝开销较大。</li>
</ul>
</li>
<li><strong>epoll</strong><ul>
<li><strong>原理</strong>：将感兴趣的文件描述符注册到内核中，内核维护一个事件表，并在文件描述符就绪时通过事件通知给应用程序。支持水平触发和边缘触发模式。</li>
<li><strong>特点与限制</strong>：在处理大量文件描述符时效率高，时间复杂度接近 O(1)；但仅适用于 Linux 平台，且在活动连接非常频繁的情况下，边缘触发模式下的处理需要开发者额外注意，可能使优势不那么明显。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：<br><strong>select</strong> 是最早的 I&#x2F;O 多路复用技术，但存在文件描述符数量和效率上的限制；</p>
<p><strong>poll</strong> 改进了数量限制的问题，但在大量连接时性能仍然不足；</p>
<p>而 <strong>epoll</strong> 则通过事件驱动方式显著提高了性能，尤其适用于高并发场景，<br>不过仅在 Linux 平台可用，并且在某些特殊情况下（如活动连接频繁）其优势可能会减弱。</p>
<h3 id="Day16"><a href="#Day16" class="headerlink" title="Day16"></a>Day16</h3><h4 id="一条SQL查询语句是如何执行的？"><a href="#一条SQL查询语句是如何执行的？" class="headerlink" title="一条SQL查询语句是如何执行的？"></a>一条SQL查询语句是如何执行的？</h4><ul>
<li><strong>连接器</strong>：<br>负责与客户端建立连接、进行权限认证，并维持和管理整个会话。</li>
<li><strong>查询缓存</strong>：<br> 当接收到查询请求后，MySQL 首先检查查询缓存，判断是否存在相同语句的执行结果；如果存在，则直接返回缓存中的结果，节省解析和执行的开销。</li>
<li><strong>分析器</strong>：<br> 将输入的 SQL 语句拆分成多个字符串和标记，识别各部分的含义，构建解析树（或抽象语法树），确保语句符合语法和语义规则。</li>
<li><strong>优化器</strong>：<br> 根据解析器输出的语法树以及数据库中的索引、统计信息等，决定最优的执行计划。比如在多索引或多表关联时，选择合适的索引和连接顺序，以降低查询成本。</li>
<li><strong>执行器</strong>：<br> 根据优化器生成的执行计划，实际执行查询操作，读取数据、进行计算和转换，最后将结果返回给客户端。</li>
</ul>
<p>这种分层设计使得 MySQL 在处理查询请求时能够高效地完成从连接建立、缓存检查、语句解析、执行计划优化到最终数据检索的全过程。</p>
<h4 id="事务的四大特性-ACID-属性-有哪些？"><a href="#事务的四大特性-ACID-属性-有哪些？" class="headerlink" title="事务的四大特性 &#x2F; ACID 属性 有哪些？"></a>事务的<code>四大特性</code> &#x2F; <code>ACID 属性</code> 有哪些？</h4><ul>
<li><p><strong>原子性（Atomicity）</strong></p>
<ul>
<li>一个事务中的所有操作<strong>要么全部成功，要么全部失败</strong>。</li>
<li>确保<strong>数据操作的不可分割性</strong>，避免部分提交导致数据不一致。</li>
<li>举例：在银行转账中，扣款和加款必须同时完成；如果其中一步失败，则整个转账操作都会回滚，保证账户状态不出现部分更新的情况。</li>
</ul>
</li>
<li><p><strong>一致性（Consistency）</strong></p>
<ul>
<li>事务必须使数据库从一个一致性状态转换到另一个一致性状态。</li>
<li>保证业务规则和约束始终得到遵守，防止数据错误。</li>
<li>举例：在订单处理系统中，订单总金额与库存数量之间的关系在事务执行前后必须保持业务规则的一致性。</li>
</ul>
</li>
<li><p><strong>隔离性（Isolation）</strong></p>
<ul>
<li><strong>并发执行的事务之间互不干扰，执行结果应该与串行执行相同</strong>。</li>
<li>防止并发事务间的相互干扰，确保数据的正确性。</li>
<li>举例：当两个用户同时更新同一条记录时，通过隔离机制避免数据竞争，确保每个事务看到的数据都是正确且独立的。</li>
<li><strong>现代技术</strong>：多版本并发控制（MVCC）就是一种实现隔离性的机制，通过保存数据的多个版本来减少锁竞争，提高并发性能。</li>
</ul>
</li>
<li><p><strong>持久性（Durability）</strong></p>
<ul>
<li><p>一旦<strong>事务提交，其对数据库的修改将永久保存</strong>，即使系统出现故障也不会丢失。</p>
</li>
<li><p>保证事务结果的长期可靠性和数据安全性。</p>
</li>
<li><p>举例：在订单提交后，即使数据库发生崩溃，已提交的订单信息也应该在恢复后依然存在。</p>
</li>
</ul>
</li>
</ul>
<h4 id="数据库的事务隔离级别有哪些？"><a href="#数据库的事务隔离级别有哪些？" class="headerlink" title="数据库的事务隔离级别有哪些？"></a>数据库的事务隔离级别有哪些？</h4><ul>
<li><p><strong>读未提交</strong></p>
<ul>
<li>允许一个事务读取其他事务尚未提交的修改数据，<strong>并发性能最高</strong></li>
<li>是最低的隔离级别，因此会存在<strong>脏读</strong>、<strong>不可重复读</strong>和<strong>幻读</strong>的问题。<strong>数据一致性较弱</strong></li>
</ul>
</li>
<li><p><strong>读已提交</strong></p>
<ul>
<li>一个事务只能读取其他事务已经提交的数据，未提交的数据对当前事务不可见。是<strong>大多数系统的默认选择</strong></li>
<li>能够解决<strong>脏读问题</strong>，适合大部分应用场景。<br>但由于在同一事务中多次读取可能遇到其他事务提交的数据，所以仍可能发生<strong>不可重复读</strong>和<strong>幻读</strong>。</li>
</ul>
</li>
<li><p><strong>可重复读</strong></p>
<ul>
<li>保证在事务执行期间，多次读取同一数据得到的结果一致。</li>
<li>在事务开始后和结束前，其他事务对数据的修改对当前事务不可见，从而解决了不可重复读的问题。提高了<strong>事务内数据一致性</strong><br>不过，在某些情况下可能仍然会遇到<strong>幻读</strong>（例如插入新的符合查询条件的数据）。</li>
</ul>
</li>
<li><p><strong>序列化</strong></p>
<ul>
<li>最高的隔离级别，通过强制事务串行化执行，使得并发事务的执行结果与串行执行的效果完全一致。提供<strong>最严格的数据一致性保证</strong></li>
<li><strong>从根本上避免了脏读、不可重复读和幻读问题。</strong><br>由于严格的并发控制，可能会对性能产生较大的影响，适用于对数据一致性要求极高的场景。</li>
</ul>
</li>
</ul>
<h3 id="Day17"><a href="#Day17" class="headerlink" title="Day17"></a>Day17</h3><h4 id="MySQL的执行引擎有哪些？"><a href="#MySQL的执行引擎有哪些？" class="headerlink" title="MySQL的执行引擎有哪些？"></a>MySQL的执行引擎有哪些？</h4><p>MySQL 提供多种存储引擎来满足不同业务需求，<br>最常用的有 InnoDB 和 MyISAM，<br>此外还有 Memory、Archive、CSV、Blackhole、NDB Cluster 等。</p>
<ul>
<li><p><strong>InnoDB</strong></p>
<ul>
<li>目前MySQL的默认存储引擎，适用于需要事务和高并发的应用。<ul>
<li>OLTP（联机事务处理）应用，如银行、电子商务系统，要求数据一致性和高并发写入。</li>
</ul>
</li>
<li><strong>事务支持</strong>：完全支持 ACID 事务，保证数据一致性。</li>
<li><strong>锁机制</strong>：采用行级锁，能有效支持高并发写操作。<br><strong>外键支持</strong>：支持外键约束，有助于维护数据完整性。</li>
<li><strong>崩溃恢复</strong>：具有良好的崩溃恢复能力，数据安全性高。</li>
</ul>
</li>
<li><p><strong>MyISAM</strong></p>
<ul>
<li>早期的默认存储引擎，支持全文索引，但是不支持事务，也不支持行级锁和外键约束，适用于快速读取且数据量不大的场景。<ul>
<li>读密集型应用、数据仓库或数据分析场景，不需要事务支持和复杂的并发控制。</li>
</ul>
</li>
<li><strong>非事务性</strong>：不支持事务，数据一致性保障较弱。</li>
<li><strong>锁机制</strong>：使用表级锁，读写操作并发性较低，但在读密集型场景下表现优秀。</li>
<li><strong>索引和全文搜索</strong>：支持全文索引，适合搜索应用。</li>
<li><strong>存储效率</strong>：通常存储空间占用较小，适合静态数据或日志存储。</li>
</ul>
</li>
<li><p><strong>其他存储引擎</strong></p>
<ul>
<li><strong>Memory</strong>：<br>数据存储在内存中，查询速度极快。<br>数据会在服务器重启后丢失，适合用于临时表或缓存数据。</li>
<li><strong>Archive</strong>：<br>优化了高速数据插入和数据压缩，适合存放归档数据或日志。<br>只支持 INSERT 和 SELECT，索引功能有限。</li>
<li><strong>CSV</strong>：数据以 CSV 格式存储，便于与其他系统交换数据，但不适合复杂查询和高性能需求。</li>
<li><strong>Blackhole</strong>：数据写入后即被丢弃，常用于复制中充当中转站。</li>
<li><strong>NDB Cluster</strong>：用于构建高可用、高扩展性的分布式集群，适合要求高容错和实时处理的场景。</li>
</ul>
</li>
<li><p><strong>选择</strong></p>
<ul>
<li><strong>事务性与数据一致性</strong>：如果应用要求支持事务、行级锁和外键约束，则应选择 <strong>InnoDB</strong>。</li>
<li><strong>高读取性能</strong>：对于以读为主且对事务要求不高的场景，<strong>MyISAM</strong> 是一个不错的选择。</li>
<li><strong>临时高速存取</strong>：当需要快速访问数据且不关心持久性时，可以使用 <strong>Memory</strong> 引擎。</li>
</ul>
</li>
</ul>
<h4 id="MySQL为什么使用B-树来作索引"><a href="#MySQL为什么使用B-树来作索引" class="headerlink" title="MySQL为什么使用B+树来作索引"></a>MySQL为什么使用B+树来作索引</h4><p> B+树 能够提供高效且稳定的查询性能，同时大大减少磁盘 I&#x2F;O 操作，并支持高效的范围查询。</p>
<p><strong>什么是 B树？</strong></p>
<ul>
<li><strong>B树</strong> 是一种多路平衡查找树，所有节点都保持有序，并且所有叶子节点都处于同一深度。</li>
<li>在 B树中，每个节点既存储索引键也存储数据（记录）。这样，在进行单点查找时，可能在非叶节点就能直接返回结果。</li>
<li>B树支持高效的查找、插入和删除操作，但由于每个节点同时存储数据和索引，其存储空间利用率和树的高度可能不是最优的。</li>
</ul>
<p><strong>为什么 MySQL 使用 B+树 作为索引？</strong></p>
<ul>
<li><strong>专门用于索引</strong>：<ul>
<li>B+树是 B树 的变种，其非叶子节点只存储索引键，所有实际数据都存放在叶子节点中。</li>
<li>这种设计使得同样大小的节点可以存储更多的索引键，从而降低树的高度，减少磁盘访问次数，提高查询效率。</li>
</ul>
</li>
<li><strong>范围查询效率高</strong>：<ul>
<li>B+树的所有叶子节点通过链表串联，支持顺序遍历。</li>
<li>在进行范围查询时，只需定位到起始叶子节点后，依次顺序扫描即可，无需在多个不连续节点间跳跃查找。</li>
</ul>
</li>
<li><strong>磁盘 I&#x2F;O 减少</strong>：<ul>
<li>由于树的高度较低，查询时需要读取的磁盘页更少，从而显著减少了 I&#x2F;O 操作，提升了整体性能。</li>
</ul>
</li>
<li><strong>高效的插入和删除</strong>：<ul>
<li>大部分更新操作仅影响叶子节点，减少了对整体树结构的调整，提升了插入和删除的效率。</li>
</ul>
</li>
<li><strong>适合高并发</strong>：<ul>
<li>B+树的结构更适合缓存机制，能更好地利用内存缓存热点数据，从而提高高并发场景下的访问性能。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong>B树</strong> 是一种既存索引又存记录的平衡查找树，<br>而 <strong>B+树</strong> 则将所有数据都存放在叶子节点，通过链表实现叶子节点的顺序访问。</li>
<li>MySQL 之所以选择 B+树 作为索引，是因为它能使索引结构“矮胖”，<br>降低树高，减少磁盘 I&#x2F;O，同时大大提升范围查询和更新操作的效率，<br>适合高并发数据库应用场景。</li>
</ul>
<h4 id="说一下索引失效的场景？"><a href="#说一下索引失效的场景？" class="headerlink" title="说一下索引失效的场景？"></a>说一下索引失效的场景？</h4><p>索引失效意味着查询操作不能有效利用索引进行数据检索，从而导致数据库必须进行全表扫描或大量数据页的读取，严重影响查询性能。常见的索引失效场景包括：</p>
<ul>
<li><strong>使用 OR 条件</strong><br> 当查询条件中使用 OR 连接多个条件时，如果各条件分别作用于不同的列（且这些列各自有索引），MySQL 可能无法将各个索引联合利用，从而导致索引失效。</li>
<li><strong>使用非等值查询</strong><br> 对于使用 !&#x3D; 或 &lt;&gt; 这类非等值操作符的条件，尤其是当条件在 WHERE 子句的起始部分时，索引往往无法发挥作用。</li>
<li><strong>对列进行类型转换</strong><br> 如果在查询中对索引列进行了数据类型转换（如将字符转换为数字或日期），MySQL 需要对每行数据进行转换，导致索引无法直接使用。</li>
<li><strong>使用 LIKE 语句</strong><br> 当 LIKE 查询以通配符 % 开头（例如 LIKE ‘%abc’）时，由于无法确定匹配起始位置，索引也难以发挥作用。</li>
<li><strong>在列上使用函数或表达式</strong><br> 在查询条件中对索引列使用函数（如 UPPER()、SUBSTR() 等）或其他表达式，都会破坏索引的原有顺序，从而使索引失效。</li>
<li><strong>表连接中的列类型不匹配</strong><br> 如果在表连接时涉及的列数据类型不一致（例如一个表的列是整数，另一个表的列是字符串），MySQL 可能需要进行隐式类型转换，导致无法利用原有索引。</li>
</ul>
<h3 id="Day18"><a href="#Day18" class="headerlink" title="Day18"></a>Day18</h3><h4 id="什么是慢查询？原因是什么？可以怎么优化？"><a href="#什么是慢查询？原因是什么？可以怎么优化？" class="headerlink" title="什么是慢查询？原因是什么？可以怎么优化？"></a>什么是慢查询？原因是什么？可以怎么优化？</h4><ul>
<li><p>**什么是慢查询？**数据库查询的执行时间超过预设的超时时间时，就被称为慢查询。这通常意味着 SQL 执行耗时较长，会影响系统性能和响应速度。</p>
</li>
<li><p><strong>慢查询产生的原因</strong></p>
<ul>
<li><strong>查询语句复杂</strong>：涉及多个表的连接和子查询，使执行过程更复杂。</li>
<li><strong>查询数据量大</strong>：数据量庞大时，即使查询本身逻辑简单，遍历数据也会耗时较长。</li>
<li><strong>缺少合适的索引</strong>：无法利用索引导致全表扫描，查询效率大幅下降。</li>
<li><strong>数据库设计不合理</strong>：表结构设计臃肿或冗余，查询时需要处理更多无关数据。</li>
<li><strong>并发冲突</strong>：多个查询同时访问同一资源时可能产生锁等待或资源争用，从而延长响应时间。</li>
<li><strong>硬件资源不足</strong>：服务器负载过高、CPU、内存或磁盘 IO 性能不够，都会使查询变慢。</li>
</ul>
</li>
<li><p><strong>优化慢查询的方法</strong></p>
<ul>
<li><strong>定位慢查询</strong>：运行 SQL，使用慢查询日志（例如 MySQL 的 <code>slow_query_log</code>）找到耗时较长的 SQL。</li>
<li><strong>利用 EXPLAIN 分析执行计划</strong>：查看 SQL 是如何利用索引进行查询的，确定是否存在全表扫描或不合理的连接方式。</li>
<li><strong>选择区分度最高的字段建索引</strong>：针对查询条件中最具选择性的字段建立索引，可大幅减少扫描行数。</li>
<li><strong>调整查询方式</strong>：<ul>
<li>尽量避免 <code>SELECT *</code>，只查询需要的字段；</li>
<li>对于 <code>ORDER BY LIMIT</code> 的查询，尽量让排序的数据量尽早减小；</li>
<li>重写过于复杂的查询，简化子查询和多表连接。</li>
</ul>
</li>
<li><strong>遵循索引建立原则</strong><ul>
<li>注意联合索引的最左前缀匹配；</li>
<li>避免对索引列进行函数或类型转换，确保索引能生效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="undo-log、redo-log、binlog-有什么用？"><a href="#undo-log、redo-log、binlog-有什么用？" class="headerlink" title="undo log、redo log、binlog 有什么用？"></a>undo log、redo log、binlog 有什么用？</h4><table>
<thead>
<tr>
<th>日志类型</th>
<th>作用</th>
<th>记录内容</th>
<th>存储位置</th>
<th>主要应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Undo Log</strong></td>
<td>事务回滚 &amp; MVCC</td>
<td><strong>修改前的数据</strong>（逻辑日志）</td>
<td>InnoDB 存储引擎层</td>
<td>事务回滚、MVCC</td>
</tr>
<tr>
<td><strong>Redo Log</strong></td>
<td>事务持久化 &amp; 崩溃恢复</td>
<td><strong>数据页的变更</strong>（物理日志）</td>
<td>InnoDB 存储引擎层</td>
<td>事务提交、崩溃恢复</td>
</tr>
<tr>
<td><strong>Binlog</strong></td>
<td>数据备份 &amp; 主从复制</td>
<td><strong>SQL 语句</strong>（逻辑日志）</td>
<td>MySQL Server 层</td>
<td>备份恢复、主从复制</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>Undo Log（回滚日志）—— 事务回滚 &amp; MVCC</strong></p>
<ul>
<li><strong>作用</strong>：保证事务的<strong>原子性（A）和一致性（C）</strong>，用于<strong>事务回滚</strong>和<strong>MVCC（多版本并发控制）</strong>。</li>
<li><strong>记录内容</strong>：数据被修改前的值（逻辑日志）。</li>
<li><strong>存储位置</strong>：InnoDB 存储引擎层。</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>事务回滚</strong>：如果事务失败或需要撤销，Undo Log 可恢复原始数据。</li>
<li><strong>MVCC</strong>：在可重复读（Repeatable Read）等隔离级别下，提供数据的历史版本，支持一致性读。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Redo Log（重做日志）—— 事务持久化 &amp; 崩溃恢复</strong></p>
<ul>
<li><strong>作用</strong>：保证事务的<strong>持久性（D）</strong>，防止数据库崩溃导致已提交事务丢失。</li>
<li><strong>记录内容</strong>：物理日志，记录数据页的变更（写入了什么修改）。</li>
<li><strong>存储位置</strong>：InnoDB 存储引擎层（<code>ib_logfile</code>）。</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>崩溃恢复</strong>：数据库重启时，通过 Redo Log 重新应用未落盘的数据，确保已提交事务不丢失。</li>
<li><strong>WAL 机制（Write-Ahead Logging）</strong>：事务提交时，先写 Redo Log，再更新数据，提高写入性能。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Binlog（归档日志）—— 数据备份 &amp; 主从复制</strong></p>
<ul>
<li><strong>作用</strong>：用于<strong>数据恢复</strong>和<strong>主从复制</strong>，在 MySQL Server 层记录 SQL 操作。</li>
<li><strong>记录内容</strong>：逻辑日志，记录所有 DML 语句（INSERT、UPDATE、DELETE）。</li>
<li><strong>存储位置</strong>：Server 层（<code>mysql-bin</code> 文件）。</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>主从复制</strong>：主库将 Binlog 发送给从库，从库回放日志，实现数据同步。</li>
<li><strong>数据恢复</strong>：误删数据时，可通过 Binlog 进行基于时间点的恢复。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>一句话概括</strong></p>
<ul>
<li><strong>Undo Log</strong> 让事务可回滚，支持 MVCC。</li>
<li><strong>Redo Log</strong> 让事务提交后数据不丢失，即使数据库崩溃也能恢复。</li>
<li><strong>Binlog</strong> 让数据可复制、可备份，实现增量恢复和主从同步。</li>
</ul>
<h3 id="Day19"><a href="#Day19" class="headerlink" title="Day19"></a>Day19</h3><h4 id="MySQL和Redis的区别是什么"><a href="#MySQL和Redis的区别是什么" class="headerlink" title="MySQL和Redis的区别是什么"></a>MySQL和Redis的区别是什么</h4><ul>
<li><strong>MySQL</strong>：<br>关系型数据库管理系统（RDBMS），以表格形式存储数据，支持 SQL 查询语言。<ul>
<li><strong>数据存储</strong>：将数据存储在<strong>磁盘</strong>上，提供持久化存储，适合处理需要持久保存的数据。</li>
<li><strong>性能</strong>：适用于复杂查询和事务处理，但读写速度相对较慢，受磁盘 I&#x2F;O 影响。</li>
<li><strong>数据一致性</strong>：支持 ACID 事务，保证数据的一致性和完整性。</li>
<li><strong>适用场景</strong>：适用于需要<strong>复杂查询</strong>、<strong>事务支持</strong>和<strong>持久化存储</strong>的应用，如金融系统、企业级应用等。</li>
</ul>
</li>
<li><strong>Redis</strong>：<br>键值存储系统（NoSQL），以键值对形式存储数据，<br>支持多种数据结构，如字符串、列表、哈希表、集合等。<ul>
<li><strong>数据存储</strong>：将数据存储在<strong>内存</strong>中，读写速度快，适合需要快速访问的数据。</li>
<li><strong>性能</strong>：读写性能极高，适用于高并发场景，但由于基于内存，数据量过大时需要考虑内存容量限制。</li>
<li><strong>数据一致性</strong>：提供简单的事务功能，但在数据一致性方面相对较弱，适用于对一致性要求不高的场景。</li>
<li><strong>适用场景</strong>：更适合处理<strong>高速</strong>、<strong>高并发</strong>和需要<strong>缓存</strong>的数据访问，以及需要<strong>复杂数据结构</strong>和功能的场景，如实时数据分析、实时推荐、消息队列等。</li>
</ul>
</li>
</ul>
<h4 id="Redis有什么优缺点？为什么用Redis查询会比较快"><a href="#Redis有什么优缺点？为什么用Redis查询会比较快" class="headerlink" title="Redis有什么优缺点？为什么用Redis查询会比较快"></a>Redis有什么优缺点？为什么用Redis查询会比较快</h4><ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><strong>高性能</strong>：Redis 将数据存储在内存中，读写速度极快，每秒可处理超过 10 万次读写操作。 </li>
<li><strong>丰富的数据结构</strong>：支持多种数据类型，如字符串、哈希、列表、集合、有序集合等，满足各种应用场景的需求。</li>
<li><strong>高可用性</strong>：提供了<strong>分布式</strong>特性，可以将数据分布在多个节点上，<br>               支持主从复制、哨兵模式和集群模式，确保系统的高可用性和可扩展性。</li>
<li>持久化：提供 RDB（Redis Database）和 AOF（Append Only File）两种持久化方式，确保数据的安全性和可靠性。<br>            但持久化操作可能增加 I&#x2F;O 开销，影响性能。</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li><strong>内存限制</strong>：由于数据存储在内存中，数据库容量受到物理内存的限制， 相比磁盘存储成本更高，不适合存储海量数据。</li>
</ul>
</li>
<li><p><strong>查询速度快的原因：</strong></p>
<ul>
<li><strong>基于内存操作</strong>：数据存储在内存中，减少了磁盘 I&#x2F;O 操作，提高了操作速度。 </li>
<li><strong>高效的数据结构</strong>：底层多种数据结构支持不同的数据类型，优化了数据的读写效率。 </li>
<li><strong>单线程模型</strong>：采用单线程模型，避免了多线程上下文切换带来的开销和资源竞争，提高了性能。 </li>
<li><strong>I&#x2F;O 多路复用</strong>：使用 I&#x2F;O 多路复用机制，同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。</li>
</ul>
</li>
</ul>
<h3 id="Day20"><a href="#Day20" class="headerlink" title="Day20"></a>Day20</h3><h4 id="Redis的数据类型有那些？"><a href="#Redis的数据类型有那些？" class="headerlink" title="Redis的数据类型有那些？"></a>Redis的数据类型有那些？</h4><p>常见的五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）及 Zset(sorted set：有序集合)</strong>。</p>
<ul>
<li>字符串<code>STRING</code>：存储字符串数据，最基本的数据类型。</li>
<li>哈希表<code>HASH</code>：存储字段和值的映射，用于存储对象。</li>
<li>列表<code>LIST</code>：存储有序的字符串元素列表。</li>
<li>集合<code>SET</code>：存储唯一的字符串元素，无序。</li>
<li>有序集合<code>ZSET</code>：类似于集合，但每个元素都关联一个分数，可以按分数进行排序。</li>
</ul>
<p>Redis版本更新后增加了几种数据类型，</p>
<ul>
<li><code>BitMap</code>: 存储位的数据结构，可以用于处理一些位运算操作。</li>
<li><code>HyperLogLog</code>：用于基数估算的数据结构，用于统计元素的唯一数量。</li>
<li><code>GEO</code>： 存储地理位置信息的数据结构。</li>
<li><code>Stream</code>：专门为消息队列设计的数据类型。</li>
</ul>
<h4 id="Redis是单线程的还是多线程的，为什么？"><a href="#Redis是单线程的还是多线程的，为什么？" class="headerlink" title="Redis是单线程的还是多线程的，为什么？"></a>Redis是单线程的还是多线程的，为什么？</h4><p>Redis 的线程模型经历了从单线程到多线程的演进。<br>在 Redis 6.0 之前，主要采用单线程模型，这意味着所有客户端请求都由一个主线程处理。这种设计有以下优点：</p>
<ul>
<li><strong>简化模型</strong>：单线程模型简化了并发控制，避免了多线程同步问题，降低了开发复杂性。</li>
<li><strong>性能优化</strong>：由于操作主要在内存中进行，单线程避免了线程切换和锁竞争的开销。</li>
<li><strong>原子性保证</strong>：单线程执行确保了操作的原子性，简化了事务和持久化的实现。</li>
<li><strong>顺序执行</strong>：单线程保证了请求的顺序执行。</li>
</ul>
<p>但是Redis的单线程模型并不意味着它在处理客户端请求时不高效。实际上，由于其操作主要在内存中进行，Redis能够提供极高的吞吐量和低延迟的响应。</p>
<p>然而，随着业务需求的增长和技术的演进，Redis 在 6.0 版本引入了多线程模型。<br>新的多线程模型将网络 I&#x2F;O 操作分担到多个线程中，提升了处理高并发请求的能力，但核心数据操作仍然是单线程执行，以保持其原子性和一致性。</p>
<h4 id="说一说Redis持久化机制有哪些"><a href="#说一说Redis持久化机制有哪些" class="headerlink" title="说一说Redis持久化机制有哪些"></a>说一说Redis持久化机制有哪些</h4><p>Redis 提供了两种主要的持久化机制：<strong>RDB（Redis Database）</strong> 和 <strong>AOF（Append Only File）</strong>。<br>此外，从 Redis 4.0 开始，引入了<strong>混合持久化</strong>方式。</p>
<ul>
<li><p><strong>RDB（Redis Database）快照</strong></p>
<ul>
<li><p><strong>将某一时刻的内存数据，以二进制的方式写入磁盘；</strong></p>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>紧凑性</strong>：RDB 文件为紧凑的二进制文件，适合备份和传输。</li>
<li><strong>快速恢复</strong>：使用 RDB 文件恢复数据比 AOF 更快。</li>
<li><strong>性能影响小</strong>：RDB 通过子进程执行快照操作，主进程不进行 I&#x2F;O 操作，确保高性能。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>数据丢失风险</strong>：由于快照在特定时间点生成，如果 Redis 意外宕机，可能会丢失最近一次快照后的数据。</li>
<li><strong>阻塞问题</strong>：在执行 <code>SAVE</code> 命令时，Redis 会阻塞，可能影响性能。</li>
</ul>
</li>
<li><p><strong>触发方式</strong>：</p>
<ul>
<li><strong>手动触发</strong>：使用 <code>SAVE</code>（同步阻塞）或 <code>BGSAVE</code>（后台异步）命令。</li>
<li><strong>自动触发</strong>：通过配置文件设置条件，如 <code>save &lt;seconds&gt; &lt;changes&gt;</code>，在指定时间内发生指定次数的写操作时触发。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>AOF（Append Only File）日志</strong></p>
<ul>
<li><strong>每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里</strong></li>
<li><strong>优点</strong>：<ul>
<li><strong>更高的数据安全性</strong>：AOF 可以根据配置实现更频繁的持久化，减少数据丢失风险。</li>
<li><strong>可读性强</strong>：AOF 文件以文本形式记录命令，便于审查和修改。</li>
<li><strong>可修复性</strong>：即使 AOF 文件末尾损坏，Redis 也能通过内置工具修复。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>文件体积大</strong>：相比 RDB，AOF 文件通常更大。</li>
<li><strong>恢复速度慢</strong>：由于需要重放所有写操作，AOF 恢复数据的速度比 RDB 慢。</li>
<li><strong>性能影响</strong>：频繁的写操作可能影响 Redis 性能。</li>
</ul>
</li>
<li><strong>触发方式</strong>：<ul>
<li><strong>配置文件设置</strong>：通过 <code>appendonly yes</code> 启用 AOF，并设置 <code>appendfsync</code> 参数来控制持久化频率，如 <code>always</code>（每次写操作后）、<code>everysec</code>（每秒）或 <code>no</code>（由操作系统决定）。</li>
<li><strong>手动触发</strong>：使用 <code>BGREWRITEAOF</code> 命令对 AOF 文件进行重写，以压缩文件大小。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>混合持久化</strong></p>
<ul>
<li><strong>概念</strong>：从 Redis 4.0 开始，支持将 <strong>RDB 快照和 AOF 日志结合</strong>起来的混合持久化方式。</li>
<li><strong>优点</strong>：<ul>
<li><strong>兼具 RDB 和 AOF 的优点</strong>：既有 RDB 的快速恢复能力，又有 AOF 的高数据安全性。</li>
<li><strong>减少 AOF 文件大小</strong>：通过将 RDB 快照作为 AOF 文件的开头，减少了 AOF 文件的体积。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>实现复杂性增加</strong>：混合持久化的实现增加了系统的复杂性。</li>
</ul>
</li>
<li><strong>触发方式</strong>：<ul>
<li><strong>配置文件设置</strong>：通过设置 <code>aof-use-rdb-preamble yes</code> 启用混合持久化。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>RDB</strong> 适合需要快速恢复和对数据一致性要求不高的场景，而 <strong>AOF</strong> 更适合需要高数据安全性的场景。<br><strong>混合持久化方式</strong>则兼顾了两者的优点，适用于对数据安全性和恢复速度都有较高要求的场景。</p>
<h3 id="Day22"><a href="#Day22" class="headerlink" title="Day22"></a>Day22</h3><h4 id="介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？"><a href="#介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？" class="headerlink" title="介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？"></a>介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？</h4><p>在使用 Redis 作为缓存时，可能会遇到 <strong>缓存雪崩</strong>、<strong>缓存击穿</strong> 和 <strong>缓存穿透</strong> 三种问题。了解它们的定义、成因及解决方案，有助于保障系统的稳定性和性能。</p>
<p><strong>1. 缓存雪崩</strong></p>
<ul>
<li><strong>定义</strong>：缓存雪崩是指在某一时间点，缓存中大量数据同时失效，导致大量请求直接访问数据库，造成数据库压力骤增，甚至可能引发系统崩溃。</li>
<li><strong>原因</strong>：<ul>
<li>大量缓存设置了相同的过期时间，导致它们在同一时间失效。</li>
<li>缓存服务器宕机或不可用，导致所有请求直接访问数据库。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>设置不同的过期时间</strong>：为缓存添加随机的过期时间，避免大量缓存同时失效。例如，在原有过期时间基础上增加一个随机值，使缓存失效时间分散。</li>
<li><strong>缓存预热</strong>：在系统上线前，将热点数据提前加载到缓存中，避免在高并发访问时直接请求数据库。</li>
<li><strong>构建高可用缓存集群</strong>：通过主从复制、哨兵模式或集群模式，提升缓存系统的可用性，避免因缓存服务器宕机导致的雪崩。</li>
<li><strong>请求限流或熔断</strong>：在缓存失效或不可用时，对请求进行限流或熔断，防止大量请求涌向数据库，保护数据库的稳定性。</li>
</ul>
</li>
</ul>
<p><strong>2. 缓存击穿</strong></p>
<ul>
<li><strong>定义</strong>：缓存击穿是指缓存中某个热点数据在高并发访问下突然失效，导致大量请求直接访问数据库，增加数据库的负载。</li>
<li><strong>原因</strong>：<ul>
<li>热点数据在缓存中失效，而此时有大量并发请求访问该数据，导致请求直接访问数据库。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>设置热点数据永不过期</strong>：对热点数据设置为永不过期，避免缓存失效引发的击穿问题。</li>
<li><strong>使用互斥锁</strong>：在缓存失效时，通过加锁机制控制只有一个线程从数据库加载数据并回填缓存，其他线程等待或返回默认值，避免大量并发请求直接访问数据库。</li>
</ul>
</li>
</ul>
<p><strong>3. 缓存穿透</strong></p>
<ul>
<li><strong>定义</strong>：缓存穿透是指查询一个在缓存和数据库中都不存在的数据，这个数据始终无法被缓存，导致每次请求都直接访问数据库，增加数据库的负载。</li>
<li><strong>原因</strong>：<ul>
<li>用户请求的数据在缓存和数据库中都不存在，每次请求都绕过缓存直接查询数据库。</li>
<li>恶意攻击者故意请求不存在的数据，导致大量请求穿透缓存，直接打到数据库。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>使用布隆过滤器</strong>：在缓存之前增加布隆过滤器，用于快速判断请求的数据是否存在。如果布隆过滤器判断数据不存在，则直接返回，避免访问数据库。</li>
<li><strong>缓存空值</strong>：当数据库中查询不到数据时，将空结果也缓存起来，并设置一个较短的过期时间，防止同样的请求频繁访问数据库。</li>
<li><strong>参数校验</strong>：对用户的请求参数进行校验，过滤掉非法或明显不存在的请求，减少对数据库的无效访问。</li>
</ul>
</li>
</ul>
<p>针对不同的业务场景，需要选择合适的解决方案。例如，对于可能出现大量缓存同时失效的场景，可以采用设置不同过期时间和缓存预热等策略；而对于可能遭受恶意请求的场景，则可以采用布隆过滤器和参数校验等策略。综合运用多种策略，可以有效保障系统的稳定性和性能。</p>
<h4 id="如何保证数据库和缓存的一致性"><a href="#如何保证数据库和缓存的一致性" class="headerlink" title="如何保证数据库和缓存的一致性"></a>如何保证数据库和缓存的一致性</h4><p>在使用缓存（如 Redis）来提升系统性能时，由于数据库和缓存之间存在数据同步的延迟或操作顺序问题，可能导致两者数据不一致。</p>
<p><strong>可能遇到的问题：</strong></p>
<ol>
<li><strong>缓存更新延迟</strong>：在更新数据库后，未及时更新或删除缓存，导致缓存中的数据与数据库不一致。</li>
<li><strong>缓存提前失效</strong>：缓存中的数据在数据库更新前被删除，导致新的缓存数据基于旧的数据库数据生成。</li>
<li><strong>并发操作冲突</strong>：多个并发操作同时修改数据库和缓存，可能导致数据不一致。</li>
</ol>
<p><strong>保证数据库和缓存一致性的常用策略：</strong></p>
<ul>
<li><p><strong>Cache Aside（旁路缓存）</strong></p>
<ul>
<li><strong>原理</strong>：<br>应用程序首先尝试从缓存读取数据；<br>如果缓存未命中，则从数据库读取数据，并将数据写入缓存。<br>更新数据时，先更新数据库，然后使缓存失效。</li>
<li><strong>问题</strong>：在高并发场景下，可能出现以下情况：<ul>
<li><strong>脏读</strong>：一个线程更新数据库后，尚未删除缓存，另一个线程读取到旧的缓存数据。</li>
<li><strong>缓存污染</strong>：一个线程在缓存未命中时从数据库读取数据，期间另一个线程更新了数据库并使缓存失效，前一个线程可能将旧数据写入缓存，导致缓存数据不一致。</li>
</ul>
</li>
<li><strong>可行性</strong>：上述问题发生的概率较低，因为需要同时满足缓存失效和并发写操作的条件。由于数据库读写速度通常慢于缓存，读操作在写操作之前进入数据库，并在写操作之后更新的概率较低。</li>
</ul>
</li>
<li><p><strong>Read&#x2F;Write Through（读写直通）</strong></p>
<ul>
<li><strong>原理</strong>：缓存代理负责更新数据库，应用程序视后端为单一存储，存储系统自行维护缓存。</li>
<li><strong>Read Through</strong>：在查询操作中更新缓存，即当缓存失效时，由缓存服务自行加载数据，对调用方透明。</li>
<li><strong>Write Through</strong>：当数据更新时，如果未命中缓存，直接更新数据库并返回；如果命中缓存，则先更新缓存，然后由缓存自行同步更新数据库（同步操作）。</li>
<li><strong>问题</strong>：Write Through策略可能导致写操作延迟增加，因为每次写操作都需要同步更新数据库，可能影响系统性能。</li>
</ul>
</li>
<li><p><strong>Write Behind（写回）</strong></p>
<ul>
<li><strong>原理</strong>：更新数据时，仅更新缓存，不立即更新数据库，缓存会异步批量更新数据库。</li>
<li><strong>问题</strong>：此设计使数据的I&#x2F;O操作非常快，但带来的问题是数据不是强一致性的，且可能会导致数据丢失。</li>
<li><strong>可行性</strong>：适用于对数据一致性要求不高的场景，但需要设计可靠的异步批量更新机制，以减少数据丢失的风险。</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"># 八股</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/17/2025-02-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/" rel="prev" title="数据结构-数组相关算法题">
      <i class="fa fa-chevron-left"></i> 数据结构-数组相关算法题
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/20/2025-02-20-%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/" rel="next" title="从零开始搭建仿牛客论坛项目">
      从零开始搭建仿牛客论坛项目 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Day01"><span class="nav-number">1.</span> <span class="nav-text">Day01</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BTCP-IP%E6%A8%A1%E5%9E%8B%E5%92%8COSI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">介绍一下TCP&#x2F;IP模型和OSI模型的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">从输入 URL 到页面展示到底发生了什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day02"><span class="nav-number">2.</span> <span class="nav-text">Day02</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">HTTP请求报文和响应报文是怎样的，有哪些常见的字段？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="nav-number">2.1.1.</span> <span class="nav-text">请求报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="nav-number">2.1.2.</span> <span class="nav-text">响应报文</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">HTTP有哪些请求方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.</span> <span class="nav-text">GET请求和POST请求的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day03"><span class="nav-number">3.</span> <span class="nav-text">Day03</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">3.1.</span> <span class="nav-text">HTTP请求中常见的状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-number">3.2.</span> <span class="nav-text">什么是强缓存和协商缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="nav-number">3.2.1.</span> <span class="nav-text">强缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-number">3.2.2.</span> <span class="nav-text">协商缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day04"><span class="nav-number">4.</span> <span class="nav-text">Day04</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP1-0%E5%92%8CHTTP1-1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text">HTTP1.0和HTTP1.1的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP2-0%E4%B8%8EHTTP1-1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">HTTP2.0与HTTP1.1的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP3-0%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">HTTP3.0有了解过吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day05"><span class="nav-number">5.</span> <span class="nav-text">Day05</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E5%92%8CHTTP%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">HTTPS和HTTP有哪些区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-HTTPS%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">HTTPS的工作原理(HTTPS建立连接的过程）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">TCP和UDP的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day06"><span class="nav-number">6.</span> <span class="nav-text">Day06</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">6.1.</span> <span class="nav-text">TCP连接如何确保可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">6.2.</span> <span class="nav-text">TCP 拥塞控制机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">6.3.</span> <span class="nav-text">TCP 流量控制机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">6.4.</span> <span class="nav-text">UDP怎么实现可靠传输</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day08"><span class="nav-number">7.</span> <span class="nav-text">Day08</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1"><span class="nav-number">7.1.</span> <span class="nav-text">TCP连接三次握手的过程，为什么是三次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">TCP连接四次挥手的过程，为什么是四次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E7%9A%84Keep-Alive%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FTCP-%E7%9A%84-Keepalive-%E5%92%8C-HTTP-%E7%9A%84-Keep-Alive-%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%E5%90%97%EF%BC%9F"><span class="nav-number">7.3.</span> <span class="nav-text">HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day09"><span class="nav-number">8.</span> <span class="nav-text">Day09</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">8.1.</span> <span class="nav-text">DNS查询过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CDN%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">CDN是什么，有什么作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie%E5%92%8CSession%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">Cookie和Session是什么？有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day10"><span class="nav-number">9.</span> <span class="nav-text">Day10</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">9.1.</span> <span class="nav-text">进程和线程之间有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">9.2.</span> <span class="nav-text">并行和并发有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E6%A0%B8%E5%BF%83%E6%80%81%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="nav-number">9.3.</span> <span class="nav-text">解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day11"><span class="nav-number">10.</span> <span class="nav-text">Day11</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91"><span class="nav-number">10.1.</span> <span class="nav-text">进程调度算法你了解多少</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89"><span class="nav-number">10.2.</span> <span class="nav-text">进程间有哪些通信方式 &#x2F; 进程间通信（IPC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="nav-number">10.3.</span> <span class="nav-text">解释一下进程同步和互斥，以及如何实现进程同步和互斥</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day12"><span class="nav-number">11.</span> <span class="nav-text">Day12</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">11.1.</span> <span class="nav-text">什么是死锁，如何避免死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81"><span class="nav-number">11.2.</span> <span class="nav-text">介绍一下几种典型的锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E8%AE%B2%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">11.3.</span> <span class="nav-text">讲一讲你理解的虚拟内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day13"><span class="nav-number">12.</span> <span class="nav-text">Day13</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">12.1.</span> <span class="nav-text">你知道的线程同步的方式有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">12.2.</span> <span class="nav-text">有哪些页面置换算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day15"><span class="nav-number">13.</span> <span class="nav-text">Day15</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%86%9F%E6%82%89%E5%93%AA%E4%BA%9BLinux%E5%91%BD%E4%BB%A4"><span class="nav-number">13.1.</span> <span class="nav-text">熟悉哪些Linux命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9D%80%E6%AD%BB%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E6%9C%89%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%8D%A0%E7%94%A8"><span class="nav-number">13.2.</span> <span class="nav-text">Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-select%E3%80%81poll%E3%80%81epoll"><span class="nav-number">13.3.</span> <span class="nav-text">说一下 select、poll、epoll</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day16"><span class="nav-number">14.</span> <span class="nav-text">Day16</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="nav-number">14.1.</span> <span class="nav-text">一条SQL查询语句是如何执行的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7-ACID-%E5%B1%9E%E6%80%A7-%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">14.2.</span> <span class="nav-text">事务的四大特性 &#x2F; ACID 属性 有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">14.3.</span> <span class="nav-text">数据库的事务隔离级别有哪些？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day17"><span class="nav-number">15.</span> <span class="nav-text">Day17</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E7%9A%84%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">15.1.</span> <span class="nav-text">MySQL的执行引擎有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%E6%9D%A5%E4%BD%9C%E7%B4%A2%E5%BC%95"><span class="nav-number">15.2.</span> <span class="nav-text">MySQL为什么使用B+树来作索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">15.3.</span> <span class="nav-text">说一下索引失效的场景？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day18"><span class="nav-number">16.</span> <span class="nav-text">Day18</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%85%A2%E6%9F%A5%E8%AF%A2%EF%BC%9F%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">16.1.</span> <span class="nav-text">什么是慢查询？原因是什么？可以怎么优化？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undo-log%E3%80%81redo-log%E3%80%81binlog-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">16.2.</span> <span class="nav-text">undo log、redo log、binlog 有什么用？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day19"><span class="nav-number">17.</span> <span class="nav-text">Day19</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E5%92%8CRedis%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">17.1.</span> <span class="nav-text">MySQL和Redis的区别是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Redis%E6%9F%A5%E8%AF%A2%E4%BC%9A%E6%AF%94%E8%BE%83%E5%BF%AB"><span class="nav-number">17.2.</span> <span class="nav-text">Redis有什么优缺点？为什么用Redis查询会比较快</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day20"><span class="nav-number">18.</span> <span class="nav-text">Day20</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="nav-number">18.1.</span> <span class="nav-text">Redis的数据类型有那些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">18.2.</span> <span class="nav-text">Redis是单线程的还是多线程的，为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">18.3.</span> <span class="nav-text">说一说Redis持久化机制有哪些</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day22"><span class="nav-number">19.</span> <span class="nav-text">Day22</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BRedis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">19.1.</span> <span class="nav-text">介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">19.2.</span> <span class="nav-text">如何保证数据库和缓存的一致性</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="间"
      src="/images/new_avatar.png">
  <p class="site-author-name" itemprop="name">间</p>
  <div class="site-description" itemprop="description">面向就业学习，Java相关技术栈、面试八股文和算法题中...</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">间</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/',]
      });
      });
  </script>

</body>
</html>
