<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/web-app-manifest-192x192.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-96x96.png">
  <link rel="mask-icon" href="/images/favicon/favicon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"souls5.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Day01介绍一下TCP&#x2F;IP模型和OSI模型的区别TCP&#x2F;IP 模型与 OSI 模型的区别    对比项 OSI 模型（七层） TCP&#x2F;IP 模型（四层）    层次划分 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 应用层、传输层、网络层、网络接口层   设计理念 理想化、理论性强，定义清晰的层次关系，每层独立 结合实际网络设计，更符合互联网协议">
<meta property="og:type" content="article">
<meta property="og:title" content="卡码八股训练营记录">
<meta property="og:url" content="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="不是不是">
<meta property="og:description" content="Day01介绍一下TCP&#x2F;IP模型和OSI模型的区别TCP&#x2F;IP 模型与 OSI 模型的区别    对比项 OSI 模型（七层） TCP&#x2F;IP 模型（四层）    层次划分 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 应用层、传输层、网络层、网络接口层   设计理念 理想化、理论性强，定义清晰的层次关系，每层独立 结合实际网络设计，更符合互联网协议">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/1.png">
<meta property="article:published_time" content="2025-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-04T06:06:59.365Z">
<meta property="article:author" content="间">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/1.png">

<link rel="canonical" href="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>卡码八股训练营记录 | 不是不是</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不是不是</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习、挣扎和一些无关紧要的琐事...大概</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          卡码八股训练营记录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-19T00:00:00+08:00">2025-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-04 14:06:59" itemprop="dateModified" datetime="2025-03-04T14:06:59+08:00">2025-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h3><h4 id="介绍一下TCP-IP模型和OSI模型的区别"><a href="#介绍一下TCP-IP模型和OSI模型的区别" class="headerlink" title="介绍一下TCP&#x2F;IP模型和OSI模型的区别"></a>介绍一下TCP&#x2F;IP模型和OSI模型的区别</h4><p><strong>TCP&#x2F;IP 模型与 OSI 模型的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>OSI 模型（七层）</strong></th>
<th><strong>TCP&#x2F;IP 模型（四层）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>层次划分</strong></td>
<td>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</td>
<td>应用层、传输层、网络层、网络接口层</td>
</tr>
<tr>
<td><strong>设计理念</strong></td>
<td>理想化、理论性强，定义清晰的层次关系，每层独立</td>
<td>结合实际网络设计，更符合互联网协议</td>
</tr>
<tr>
<td><strong>协议示例</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>应用层</strong></td>
<td>HTTP、FTP、SMTP、DNS 等</td>
<td>HTTP、FTP、SMTP、DNS 等（合并 OSI 的应用层、表示层、会话层）</td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td>TCP、UDP</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td>IP、ICMP、ARP</td>
<td>IP、ICMP、ARP</td>
</tr>
<tr>
<td><strong>数据链路层 &#x2F; 物理层</strong></td>
<td>以太网、Wi-Fi、PPP</td>
<td>以太网、Wi-Fi、PPP（合并 OSI 的数据链路层、物理层）</td>
</tr>
<tr>
<td><strong>适用范围</strong></td>
<td>理论上更全面</td>
<td>实际网络通信中更为实用。</td>
</tr>
<tr>
<td><strong>数据封装单位</strong></td>
<td><strong>比特流（物理层） → 帧（数据链路层） → 数据包（网络层） → 段（传输层） → 数据（应用层）</strong></td>
<td><strong>比特流 → 帧 → 数据包 → 段 → 数据</strong></td>
</tr>
</tbody></table>
<p>TCP&#x2F;IP 模型的<strong>应用层</strong>相当于 OSI 的 <strong>应用层 + 表示层 + 会话层</strong>，<br>而 TCP&#x2F;IP 的<strong>网络接口层</strong>相当于 OSI 的 <strong>数据链路层 + 物理层</strong>。</p>
<h4 id="从输入-URL-到页面展示到底发生了什么？"><a href="#从输入-URL-到页面展示到底发生了什么？" class="headerlink" title="从输入 URL 到页面展示到底发生了什么？"></a>从输入 URL 到页面展示到底发生了什么？</h4><ul>
<li><strong>浏览器网络请求</strong><ul>
<li><strong>输入网址，解析 URL 信息</strong><ul>
<li>解析 URL，提取协议（<code>https</code>）、域名（<code>www.example.com</code>）、路径（<code>/</code>）</li>
</ul>
</li>
<li><strong>检查浏览器缓存</strong><ul>
<li>有缓存并且仍然有效，则直接加载页面</li>
</ul>
</li>
<li><strong>DNS 解析 （域名 → IP 地址）</strong><ul>
<li>浏览器缓存 —&gt; 本地 <code>hosts</code> 文件 —&gt; 本地 DNS 服务器（ISP 提供）—&gt;权威 DNS 服务器（根 DNS → 顶级域名 DNS → 权威 DNS）</li>
</ul>
</li>
<li><strong>建立 TCP 连接（三次握手）</strong><ul>
<li><strong>第一步</strong>：客户端发送 SYN 报文请求连接。</li>
<li><strong>第二步</strong>：服务器回复 SYN-ACK 报文，确认连接请求。</li>
<li><strong>第三步</strong>：客户端回复 ACK，连接建立成功。</li>
</ul>
</li>
<li><strong>发送 HTTP 请求</strong><ul>
<li>浏览器构造 HTTP 请求：<ul>
<li><strong>请求行</strong>（请求方法 <code>GET</code>、请求路径 <code>/</code>、协议版本 <code>HTTP/1.1</code>）</li>
<li><strong>请求头</strong>（包含 <code>User-Agent</code>、<code>Cookie</code> 等）</li>
</ul>
</li>
<li>如果是 HTTPS，还涉及 <strong>TLS 握手</strong> 进行加密通信。</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务器处理请求</strong><ul>
<li><strong>服务器解析HTTP请求</strong><ul>
<li>接收 HTTP 请求，解析 URL 和请求头，查询静态资源和数据库、渲染动态页面</li>
</ul>
</li>
<li><strong>服务器返回HTTP响应</strong><ul>
<li><strong>响应状态码</strong>（如 <code>200 OK</code>，<code>404 Not Found</code>）</li>
<li><strong>响应头</strong>（<code>Content-Type: text/html</code>）</li>
<li><strong>响应体</strong>（HTML、CSS、JavaScript）</li>
</ul>
</li>
<li><strong>TCP 连接断开（四次挥手）</strong><ul>
<li><strong>客户端发送 FIN</strong>（请求关闭连接）</li>
<li><strong>服务器回复 ACK</strong>  此时若有剩余数据则继续发送</li>
<li><strong>服务器发送 FIN</strong>（服务器准备关闭）</li>
<li><strong>客户端回复 ACK</strong>（最终确认关闭）</li>
</ul>
</li>
</ul>
</li>
<li><strong>浏览器解析并渲染页面</strong><ul>
<li><strong>解析响应头</strong><ul>
<li>301，302重定向，为字节流则下载，为HTML文件则解析html文件</li>
</ul>
</li>
<li><strong>解析HTML 并渲染页面</strong><ul>
<li><strong>解析 HTML</strong>，构建 <strong>DOM 树</strong>    <strong>解析 CSS</strong>，构建 <strong>CSSOM 树</strong>，进行 <strong>样式计算</strong></li>
<li><strong>合成渲染树</strong>（DOM + CSSOM），<strong>布局（Layout）</strong> 计算元素的具体位置，<strong>绘制（Painting）</strong> 将页面渲染到屏幕上</li>
<li><strong>执行 JavaScript</strong>，更新页面内容</li>
</ul>
</li>
<li><strong>页面显示</strong><ul>
<li>页面最终呈现给用户，加载其他资源（图片、视频、异步数据等）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h3><h4 id="HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"><a href="#HTTP请求报文和响应报文是怎样的，有哪些常见的字段？" class="headerlink" title="HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"></a>HTTP请求报文和响应报文是怎样的，有哪些常见的字段？</h4><h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><ul>
<li><p><strong>请求行</strong>（Request Line）</p>
<ul>
<li><p><strong>请求方法（Method）</strong>：如 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等</p>
</li>
<li><p><strong>资源路径（Resource Path）</strong>：要访问的资源地址</p>
</li>
<li><p><strong>HTTP 版本（HTTP Version）</strong>：如 <code>HTTP/1.1</code>、<code>HTTP/2.0</code></p>
</li>
<li><p>例如：<code>GET /index.html HTTP/1.1</code></p>
</li>
</ul>
</li>
<li><p><strong>请求头</strong>（Request Headers）：提供额外的信息，例如浏览器类型、缓存策略等</p>
<ul>
<li><p>常见请求头字段：</p>
<ul>
<li><p><strong>客户端环境&#x2F;请求资源</strong></p>
<ul>
<li><code>Host</code>：请求的服务器域名（必须字段）</li>
<li><code>User-Agent</code>：客户端信息（如浏览器、操作系统）</li>
<li><code>Accept</code>：客户端能接受的数据类型（如 <code>text/html</code>）</li>
<li><code>Accept-Encoding</code>：支持的压缩格式（如 <code>gzip</code>）</li>
</ul>
</li>
<li><p><strong>身份认证与安全</strong></p>
<ul>
<li><code>Authorization</code>：身份认证信息（如 <code>Bearer Token</code>）</li>
</ul>
</li>
<li><p><strong>缓存控制</strong></p>
<ul>
<li><code>If-None-Match </code> &#x2F; <code> If-Modified-Since</code>：资源的ETag &#x2F; 最后修改时间 值，用于缓存控制。</li>
</ul>
</li>
<li><p><strong>请求内容描述</strong></p>
<ul>
<li><code>Content-Length</code>：请求体的长度（仅适用于带请求体的方法）</li>
<li><code>Content-Type</code>：请求体的媒体类型（如 <code>application/json</code>）</li>
<li><code>Cookie</code>：发送存储在客户端的 Cookie</li>
</ul>
</li>
<li><p><code>Connection</code>：管理连接的选项，如 keep-alive</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>空行</strong>：用于分隔请求头和请求体。</p>
</li>
<li><p><strong>请求体</strong>（Request Body）：用于 <code>POST</code>、<code>PUT</code> 请求，包含要发送的数据（如 JSON、表单数据等）。</p>
</li>
</ul>
<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><ul>
<li><p><strong>状态行</strong>（Status Line）：包含 HTTP 版本、状态码、状态描述</p>
<ul>
<li><p><strong>HTTP 版本</strong>：如 <code>HTTP/1.1</code></p>
</li>
<li><p><strong>状态码</strong>（Status Code）</p>
<ul>
<li><code>2xx</code>（成功）：<code>200 OK</code>、<code>201 Created</code></li>
<li><code>3xx</code>（重定向）：<code>301 Moved Permanently</code>、<code>302 Found</code></li>
<li><code>4xx</code>（客户端错误）：<code>400 Bad Request</code>、<code>404 Not Found</code></li>
<li><code>5xx</code>（服务器错误）：<code>500 Internal Server Error</code></li>
</ul>
</li>
<li><p><strong>状态描述</strong>：对状态码的解释（如 <code>OK</code>、<code>Not Found</code>）</p>
</li>
<li><p>例如：<code>HTTP/1.1 200 OK</code></p>
</li>
</ul>
</li>
<li><p><strong>响应头</strong>（Response Headers）：提供额外信息，如内容类型、缓存控制等</p>
<ul>
<li><p>常见响应头字段</p>
<ul>
<li><p><strong>重定向</strong></p>
<ul>
<li><code>Location</code>：重定向地址（适用于 301、302）</li>
</ul>
</li>
<li><p><strong>描述响应内容</strong></p>
<ul>
<li><code>Content-Type</code>：返回数据的 MIME 类型（如 <code>text/html</code>）</li>
<li><code>Content-Length</code>：响应体长度（字节）</li>
</ul>
</li>
<li><p><strong>控制缓存</strong></p>
<ul>
<li><code>Expires</code>：指定响应的过期时间，用于缓存控制。</li>
<li><code>ETag</code>：资源的实体标签，用于缓存验证。</li>
<li><code>Last-Modified</code>：资源最后修改的日期和时间。</li>
</ul>
</li>
<li><p><strong>管理连接和安全</strong></p>
<ul>
<li><code>Server</code>：服务器软件信息（如 <code>nginx/1.18.0</code>）</li>
<li><code>Set-Cookie</code>：设置 Cookie</li>
<li><code>Access-Control-Allow-Origin</code>：指示哪些域名可以访问资源，涉及跨域资源共享（CORS）策略</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>空行</strong>：用于分隔响应头和响应体。</p>
</li>
<li><p><strong>响应体</strong>（Response Body）：实际的返回数据，如 HTML 页面、JSON 数据、图片等。</p>
</li>
</ul>
<h4 id="HTTP有哪些请求方式？"><a href="#HTTP有哪些请求方式？" class="headerlink" title="HTTP有哪些请求方式？"></a>HTTP有哪些请求方式？</h4><p><strong>幂等性</strong>：表示多次执行相同请求，服务器状态不变。</p>
<p><strong>安全性</strong>：表示请求不会修改服务器数据（如 <code>GET</code>、<code>HEAD</code>、<code>OPTIONS</code>）。</p>
<p>HTTP 定义了多种请求方法，每种方法适用于不同的场景。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>用途</strong></th>
<th><strong>幂等性</strong></th>
<th><strong>安全性</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>GET</strong></td>
<td>获取资源</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>POST</strong></td>
<td>提交数据</td>
<td>❌ 非幂等</td>
<td>❌ 不安全（数据在请求体中）</td>
</tr>
<tr>
<td><strong>PUT</strong></td>
<td>更新资源（完整更新）</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>DELETE</strong></td>
<td>删除资源</td>
<td>✅ 幂等</td>
<td>❌ 不安全（改变服务器状态）</td>
</tr>
<tr>
<td><strong>HEAD</strong></td>
<td>获取资源的头部信息</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>OPTIONS</strong></td>
<td>获取服务器支持的请求方法</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>TRACE</strong></td>
<td>回显请求，用于调试</td>
<td>✅ 幂等</td>
<td>❌ 不安全（容易被攻击）</td>
</tr>
<tr>
<td><strong>CONNECT</strong></td>
<td>建立隧道连接（如 HTTPS 代理）</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
</tbody></table>
<h4 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h4><ul>
<li><code>GET</code> <strong>适用于获取数据</strong>，参数放在 URL，容易被缓存，幂等且安全。</li>
<li><code>POST</code> <strong>适用于提交数据</strong>，参数放在请求体，不容易被缓存，不幂等。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>参数位置</strong></td>
<td>URL 查询参数（<code>?key=value</code>）</td>
<td>请求体</td>
</tr>
<tr>
<td><strong>参数长度</strong></td>
<td>受 URL 长度限制</td>
<td>理论上无限制</td>
</tr>
<tr>
<td><strong>缓存</strong></td>
<td>可被缓存</td>
<td>不会被浏览器缓存</td>
</tr>
<tr>
<td><strong>可见性</strong></td>
<td>参数暴露在 URL 中</td>
<td>参数在请求体，不易暴露</td>
</tr>
<tr>
<td><strong>幂等性</strong></td>
<td>✅ 幂等</td>
<td>❌ 非幂等</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>查询数据（如获取用户信息）</td>
<td>提交数据（如用户注册、登录）</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>❌ 不适合传输敏感信息（如密码）</td>
<td>✅ 相对更安全，但仍需 HTTPS</td>
</tr>
</tbody></table>
<h3 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h3><h4 id="HTTP请求中常见的状态码"><a href="#HTTP请求中常见的状态码" class="headerlink" title="HTTP请求中常见的状态码"></a><strong>HTTP请求中常见的状态码</strong></h4><p>HTTP 状态码用于指示服务器对请求的处理结果，按照功能分为 5 类</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>分类名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1xx</strong></td>
<td><strong>信息性状态码</strong></td>
<td>服务器已收到请求，正在继续处理</td>
</tr>
<tr>
<td><strong>2xx</strong></td>
<td><strong>成功状态码</strong></td>
<td>请求成功并返回预期的响应</td>
</tr>
<tr>
<td><strong>3xx</strong></td>
<td><strong>重定向状态码</strong></td>
<td>需要客户端执行进一步操作（重定向）</td>
</tr>
<tr>
<td><strong>4xx</strong></td>
<td><strong>客户端错误码</strong></td>
<td>客户端请求有错误（参数错误、权限不足等）</td>
</tr>
<tr>
<td><strong>5xx</strong></td>
<td><strong>服务器错误码</strong></td>
<td>服务器端发生错误，无法处理请求</td>
</tr>
</tbody></table>
<p><strong>常见状态码</strong></p>
<ul>
<li><p>**2xx：**请求成功</p>
<ul>
<li><strong>200 OK</strong>：常用于 <code>GET</code>、<code>POST</code>、<code>PUT</code> 等请求。</li>
<li><strong>201 Created</strong>：服务器创建了新资源（常用于 <code>POST</code>）。</li>
<li><strong>204 No Content</strong>：服务器无返回内容（常用于 <code>DELETE</code>）。</li>
</ul>
</li>
<li><p><strong>3xx：</strong></p>
<ul>
<li><strong>301 Moved Permanently</strong>：资源永久移动，后续请求应使用新 URL（SEO 友好）。</li>
<li><strong>302 Found</strong>（临时重定向）：资源暂时移动，后续请求仍可使用原 URL。</li>
<li><strong>304 Not Modified</strong>（缓存优化）：客户端缓存资源仍然有效，无需重新下载（结合 <code>ETag</code>、<code>Last-Modified</code> 头使用）。<ul>
<li><strong>缓存相关：</strong></li>
<li>浏览器在接收到 <code>304 Not Modified</code> 后，不会下载新资源，而是从本地缓存加载，提升性能。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>4xx：</strong></p>
<ul>
<li><strong>400 Bad Request</strong>：请求格式错误或参数无效，服务器无法解析。</li>
<li><strong>401 Unauthorized</strong>：身份认证失败，需要提供有效凭证（如未登录）。</li>
<li><strong>403 Forbidden</strong>：服务器拒绝请求。（如权限不够）</li>
<li><strong>404 Not Found</strong>：请求的资源不存在（常见于访问错误的 URL）。</li>
</ul>
</li>
<li><p><strong>5xx：</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong>：服务器内部错误（代码异常、数据库崩溃等）。</li>
<li><strong>502 Bad Gateway</strong>：服务器作为网关&#x2F;代理，收到无效响应（上游服务器问题）。</li>
<li><strong>503 Service Unavailable</strong>：服务器暂时不可用（维护、超载等）。</li>
</ul>
</li>
</ul>
<p><strong>状态码使用案例</strong></p>
<ol>
<li><strong>用户访问网站首页</strong><ul>
<li>正常加载：返回 <code>200 OK</code></li>
<li>页面不存在：返回 <code>404 Not Found</code></li>
<li>需要登录：返回 <code>401 Unauthorized</code></li>
</ul>
</li>
<li><strong>API 接口</strong><ul>
<li>获取数据成功：返回 <code>200 OK</code></li>
<li>没有权限：返回 <code>403 Forbidden</code></li>
<li>请求参数错误：返回 <code>400 Bad Request</code></li>
</ul>
</li>
<li><strong>重定向</strong><ul>
<li>旧网站迁移到新域名：返回 <code>301 Moved Permanently</code></li>
<li>用户登录后跳转到主页：返回 <code>302 Found</code></li>
<li>资源未修改：返回 &#96;304 Not Modified</li>
</ul>
</li>
</ol>
<h4 id="什么是强缓存和协商缓存"><a href="#什么是强缓存和协商缓存" class="headerlink" title="什么是强缓存和协商缓存"></a><strong>什么是强缓存和协商缓存</strong></h4><p>HTTP 协议中，缓存机制主要用于减轻服务器负担，加快页面加载速度</p>
<ol>
<li>浏览器第一次访问时访问服务器时需要下载资源</li>
<li>后续访问时，只要强缓存没有失效就直接从缓存中获取，不需要将获取资源的请求包含在请求报文中</li>
<li>当强缓存失效后，浏览器会使用协商缓存机制来验证资源是否被修改</li>
</ol>
<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><ul>
<li><strong>Expires</strong><br> <code>Expires</code> 是一个 HTTP 响应头，指定资源的过期时间（绝对时间），表示在该时间之前资源都是有效的，可以直接使用缓存，不需要向服务器重新请求。<br> 用于设置强缓存。当客户端收到带有 <code>Expires</code> 头的响应后，在当前时间早于 <code>Expires</code> 指定时间内，浏览器直接从本地缓存中读取资源。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 21 Oct 2025 07:28:00 GMT</span><br><span class="line"><span class="comment">## 表示在 2025 年 10 月 21 日 07:28:00 GMT 之前，资源均可直接使用缓存。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>Cache-Control</strong></p>
<p><code>Cache-Control</code> 是 HTTP&#x2F;1.1 提供的用于控制缓存行为的通用头部，可以用于请求和响应中。它提供了多种指令来精细控制资源如何被缓存。<br>用于替代或补充 <code>Expires</code>，提供更灵活的缓存控制。服务器可以根据业务需求，准确控制资源的缓存策略</p>
<ul>
<li><strong>常见指令</strong>：<ul>
<li><strong>max-age</strong>：指定资源在客户端缓存的最大时间（秒），例如 <code>max-age=3600</code> 表示缓存有效期为 3600 秒。</li>
<li><strong>no-cache</strong>：表示缓存必须在使用前进行重新验证，即使缓存仍在有效期内。</li>
<li><strong>no-store</strong>：禁止缓存，确保每次请求都从服务器获取最新数据。</li>
<li><strong>public</strong> 和 <strong>private</strong>：分别指示资源可以被所有用户缓存，或仅供单个用户缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=3600, public</span><br><span class="line"><span class="comment">## 表示资源可以被缓存 3600 秒，并允许任何缓存设备缓存此资源。</span></span><br></pre></td></tr></table></figure>



<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><ul>
<li><p><strong>Last-Modified</strong></p>
<p> <code>Last-Modified</code> 是服务器在响应中返回的头部字段，用来指示资源的最后修改时间。它通常以 GMT 时间格式表示。</p>
<p> 客户端在后续请求时，可以使用 <code>If-Modified-Since</code> 请求头将之前获取的 <code>Last-Modified</code> 值发送给服务器。如果资源自该时间之后没有更新，服务器可以返回 <code>304 Not Modified</code> 状态，从而避免不必要的数据传输。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Tue, 20 Apr 2025 12:00:00 GMT</span><br><span class="line"><span class="comment">## 表示资源在该时间之后没有发生变化，客户端可据此进行缓存验证。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>ETag</strong></p>
<p> <code>ETag</code>（实体标签）是服务器为特定资源生成的唯一标识符，它反映了资源的版本。当资源内容发生变化时，ETag 值也会改变。</p>
<p> 客户端在后续请求时，可以在请求头中使用 <code>If-None-Match</code> 将之前收到的 ETag 值发送给服务器。服务器比对后，如果发现资源没有变化，则返回 <code>304 Not Modified</code>，让客户端继续使用缓存数据。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ETag: <span class="string">&quot;686897696a7c876b7e&quot;</span></span><br><span class="line"><span class="comment">## 表示该资源当前的版本标识符，后续可以利用此值进行缓存验证。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>浏览器使用缓存流程</code><br><img src="/2025/02/19/2025-02-19-卡码八股训练营记录/1.png"  alt="1" style="zoom:67%;" /></p>
<h3 id="Day04"><a href="#Day04" class="headerlink" title="Day04"></a>Day04</h3><h4 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h4><ul>
<li><strong>连接管理</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：默认使用<strong>短连接</strong>，每次请求&#x2F;响应后关闭 TCP 连接；<br>可以通过 <code>Connection: keep-alive</code> 来实现持久连接</li>
<li><em>HTTP&#x2F;1.1</em>：默认启用<strong>持久连接</strong>（<code>Connection</code>字段值默认为<code>keep-alive</code>），<br>在同一 TCP 连接上可以连续发送多个请求和响应，减少了连接建立和关闭的开销。</li>
</ul>
</li>
<li><strong>管道化</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：客户端的每次请求都需要在上一次请求的响应到达之后发送，请求发送有等待时间</li>
<li><em>HTTP&#x2F;1.1</em>：支持<strong>管道化</strong>，即同一连接上可以连续发送多个请求，<br>但由于服务器必须按顺序返回响应（队头阻塞问题），实际效果有限</li>
</ul>
</li>
<li><strong>缓存控制</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：主要依赖 <code>Expires</code> 头来指定资源的绝对过期时间，没有协商缓存机制</li>
<li><em>HTTP&#x2F;1.1</em>：引入了 <code>Cache-Control </code>头提供更精细的缓存指令,通过 <code>If-Modified-Since </code>和 <code>If-None-Match </code>等头实现协商缓存</li>
</ul>
</li>
<li><strong>错误处理和状态码</strong><br><strong>HTTP&#x2F;1.1</strong>增加了状态码（如 <code>100 Continue</code>）用于中间响应和更精细的错误处理，<br>使客户端能更好地管理请求过程和错误恢复</li>
<li><strong>请求头要求</strong><br><strong>HTTP&#x2F;1.1</strong>要求所有请求必须包含 <code>Host</code> 头  —&gt;  一台服务器&#x2F;一个IP 上可托管多个 域名&#x2F;网站</li>
<li><strong>带宽优化</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：不支持断点续传功能，客户端只需要某个对象的一部分时，服务器也会将整个对象发送过来</li>
<li><em>HTTP&#x2F;1.1</em>：在请求头引入了<code>range</code>头域，允许只请求资源的某个部分，此时服务器返回状态码<code>206</code></li>
</ul>
</li>
</ul>
<h4 id="HTTP2-0与HTTP1-1的区别？"><a href="#HTTP2-0与HTTP1-1的区别？" class="headerlink" title="HTTP2.0与HTTP1.1的区别？"></a>HTTP2.0与HTTP1.1的区别？</h4><ul>
<li><p><strong>二进制协议</strong></p>
<ul>
<li>HTTP&#x2F;1.1：请求和响应内容都是以纯文本方式发送的，解析时开销较大且容易出错。</li>
<li>HTTP&#x2F;2.0：采用二进制格式，将数据分割为小的帧，解析更高效、可靠</li>
</ul>
</li>
<li><p><strong>多路复用</strong></p>
<ul>
<li>HTTP&#x2F;1.1：支持持久连接，但请求在同一连接上串行发送，容易出现队头阻塞<ul>
<li>可以连续发送多个请求，但服务器必须按顺序返回响应</li>
</ul>
</li>
<li>HTTP&#x2F;2.0：支持多路复用，允许在单个TCP连接上并行交错发送多个请求和响应<ul>
<li>请求和响应报文被拆分为更小的帧<ul>
<li>帧类型包括 DATA、HEADERS、PRIORITY 等，每种类型的帧都有特定的用途。</li>
<li>流的状态管理涉及多种状态，如“已打开”、“已关闭”等，客户端和服务器可以通过发送特定的帧（如 RST_STREAM）来管理流的生命周期</li>
</ul>
</li>
<li>帧被分配到不同的流（Stream），每个流都有唯一的标识符</li>
<li>接收方根据帧头中的流标识符将属于同一流的帧重新组装为完整的请求或响应</li>
</ul>
</li>
<li>HTTP&#x2F;2.0 基于 TCP 协议来传输数据，发生了丢包现象时，就会触发 TCP 的重传机制，<br>这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来</li>
</ul>
</li>
<li><p><strong>头部压缩</strong></p>
<ul>
<li>HTTP&#x2F;1.1：头部信息以纯文本发送，冗余较多</li>
<li>HTTP&#x2F;2.0：引入 HPACK 算法对头部进行压缩，显著减少传输数据量<br><strong>HPACK 算法</strong>：<ul>
<li><strong>静态表和动态表</strong>：<br>客户端和服务器各自维护一个<strong>静态表</strong>和<strong>动态表</strong>，用于存储常见的头部字段。<br>静态表包含预定义的常用头部，动态表则在通信过程中动态更新，记录已发送的头部字段。<br>通过引用这些表中的索引，可以避免重复传输相同的头部信息。</li>
<li><strong>哈夫曼编码</strong>：<br>HPACK 使用哈夫曼编码对头部字段进行压缩，将常用字符编码为更短的二进制序列，从而减少头部的大小。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器推送</strong></p>
<p><code>HTTP/2.0</code> 允许服务器主动推送页面相关资源给客户端，而不需要客户端明确请求，<br>避免了客户端请求和服务器响应之间的延迟，可以减少页面加载时间</p>
<ul>
<li>例如，客户端请求一个 HTML 页面时，服务器可以主动推送相关的 CSS、JavaScript 文件等资源，从而加快页面渲染速度</li>
</ul>
</li>
<li><p><strong>优先级和依赖</strong></p>
<p><code>HTTP/2.0</code> 允许客户端为请求设置优先级，并表达请求之间的依赖关系，资源加载更加有序</p>
</li>
</ul>
<h4 id="HTTP3-0有了解过吗？"><a href="#HTTP3-0有了解过吗？" class="headerlink" title="HTTP3.0有了解过吗？"></a>HTTP3.0有了解过吗？</h4><p>HTTP3.0基于 QUIC 协议，运行在UDP上，整合了TCP和TLS协议</p>
<p>应用层数据直接被封装成QUIC帧，<br>整合一个或多个帧，加上信息（<strong>连接 ID</strong>&#x2F;<code>Connection ID</code>）后被封装成一个 QUIC 数据包<br>QUIC 数据包被封装在 UDP 数据报中，通过网络传输</p>
<ul>
<li><strong>无队头阻塞</strong><ul>
<li>HTTP&#x2F;1.1没有解决响应的队头阻塞、HTTP&#x2F;2基于TCP 协议，<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong></li>
<li>HTTP3.0基于UDP 协议发送，<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong></li>
</ul>
</li>
<li><strong>零 RTT 连接建立</strong><ul>
<li>传输数据前的 QUIC 协议握手只需要 1 RTT，目的是为确认双方的「连接 ID」</li>
<li>QUIC 内部包含了 TLS</li>
<li>第二次连接时，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</li>
</ul>
</li>
<li><strong>连接迁移</strong><ul>
<li>网络环境发送改变（如Wifi—&gt;移动网络）时，通过确认<code>Connection ID</code>实现<strong>零 RTT 连接</strong></li>
</ul>
</li>
<li><strong>向前纠错机制</strong><ul>
<li>每个数据包还包括了部分其他数据包的数据，少量丢包无需重传</li>
</ul>
</li>
<li><strong>安全性</strong><ul>
<li>默认使用TLS加密</li>
</ul>
</li>
</ul>
<h3 id="Day05"><a href="#Day05" class="headerlink" title="Day05"></a>Day05</h3><h4 id="HTTPS和HTTP有哪些区别"><a href="#HTTPS和HTTP有哪些区别" class="headerlink" title="HTTPS和HTTP有哪些区别"></a>HTTPS和HTTP有哪些区别</h4><ul>
<li>HTTP 明文传输、TCP三次握手后建立连接传输报文，默认工作在80端口</li>
<li>HTTPS TCP三次握手后还需要进行SSL&#x2F;TLS的握手过程才能进入加密报文传输，默认工作在443端口<ul>
<li>需要向CA（证书权威机构）申请数字证书，来保证服务器身份可信</li>
</ul>
</li>
</ul>
<h4 id="HTTPS的工作原理-HTTPS建立连接的过程）"><a href="#HTTPS的工作原理-HTTPS建立连接的过程）" class="headerlink" title="HTTPS的工作原理(HTTPS建立连接的过程）"></a>HTTPS的工作原理(HTTPS建立连接的过程）</h4><p><code>HTTPS</code> 主要基于<code>SSL/TLS</code> 协议，确保数据传输的安全性和完整性</p>
<ol>
<li><p><strong>客户端向服务器请求加密通信</strong></p>
<ul>
<li>请求报文包括：<ul>
<li>客户端支持的TLS版本、支持的加密算法、随机数1（Client Random）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器选择一个客户端支持的加密算法</strong></p>
<ul>
<li>响应报文包括：<ul>
<li>CA证书：服务器的数字证书，由受信任的CA签发、<br>随机数2（Server Random）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>客户端验证证书合法性</strong></p>
<ul>
<li>使用数字证书中的公钥<strong>加密</strong>报文<br>报文内容包括：<ul>
<li>随机数3（预主密钥 Pre-Master Secret）：三个随机数生成 <strong>会话密钥&#x2F;主密钥（Master Secret）</strong></li>
<li>加密算法改变通知：之前使用会话密钥加密通话</li>
<li>结束握手通知、之前消息摘要校验值（用于服务器验证数据完整性）<ul>
<li>“加密算法改变通知”通常是通过<strong>ChangeCipherSpec</strong>消息发送，<br>而<strong>Finished</strong>消息则包含了整个握手过程的摘要，用于双方确认握手数据未被篡改。<br>这两个消息实际上是分开的，而不是合并在一个报文中。<ol>
<li>客户端生成并发送加密后的预主密钥（即ClientKeyExchange消息）。</li>
<li>客户端随后发送ChangeCipherSpec和Finished消息。</li>
<li><code>Tips</code>：<br>消息通常指应用层的数据单位，而报文是网络层的数据传输单位。<br>消息在传输过程中可能被分割成多个报文进行传输。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器生成会话密钥</strong></p>
<ul>
<li><p>服务器使用自己的私钥解密客户端发送的预主密钥，随后与客户端共同计算出主密钥，再派生出对称加密所需的各个子密钥。</p>
</li>
<li><p>发送内容：通知服务器后续加密、结束握手通知、之前消息摘要校验值（用于客户端验证数据完整性）</p>
<ul>
<li>后续加密的通知、结束握手通知和之前消息摘要校验值同样是两个消息分别发送的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据传输完成后销毁密钥</strong></p>
<ul>
<li>通信结束后双方应销毁会话密钥以防止长期使用造成安全风险。</li>
</ul>
</li>
</ol>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><ul>
<li><strong>TCP</strong> <ul>
<li><strong>面向连接</strong>：数据传输前需要建立连接（三次握手），确保通信双方的可靠连接</li>
<li><strong>可靠数据传输</strong>（保证顺序、完整性）：通过序列号、确认应答、重传机制等<ul>
<li>检测并重传丢失数据包</li>
</ul>
</li>
<li><strong>拥塞控制机制</strong>：根据网络状况调整发送速率</li>
<li><strong>滑动窗口机制</strong>：流量控制，保证对端能够处理发送的数据</li>
<li>报文头部复杂：TCP头部通常为20字节，包含序列号、确认号、窗口大小等多个字段</li>
</ul>
</li>
<li><strong>UDP</strong> <ul>
<li><strong>无连接</strong>：数据传输前不需要建立连接，发送方直接将数据包发送出去，接收方无需确认</li>
<li><strong>不可靠</strong>：UDP不提供数据包的确认、重传等机制，无法保证数据的顺序性和完整性，<br>           适用于对实时性要求高且能容忍一定数据丢失的应用。</li>
<li>发送速率恒定</li>
<li>头部报文相对简单，开销较小 ：<br>UDP头部只有8字节，包含源端口、目的端口、长度和校验和等基本信息，适合对速度和效率要求高的应用。</li>
</ul>
</li>
</ul>
<h3 id="Day06"><a href="#Day06" class="headerlink" title="Day06"></a>Day06</h3><h4 id="TCP连接如何确保可靠性"><a href="#TCP连接如何确保可靠性" class="headerlink" title="TCP连接如何确保可靠性"></a>TCP连接如何确保可靠性</h4><ul>
<li><strong>连接管理</strong>：三次握手、四次挥手</li>
<li><strong>差错控制</strong>：<ul>
<li><strong>序列号和确认应答机制</strong>：<br>每个数据包都被赋予唯一的序列号，接收方通过发送确认包（ACK）来告知发送方数据已成功接收。<br>发送方根据确认包的序列号来确认哪些数据已经收到，哪些还需要重新发送。</li>
<li><strong>超时重传机制</strong>：<br>如果发送方在一定时间内没有收到接收方的确认（ACK），它会重新发送未确认的数据包。<br>这确保了数据在丢包时能够重新传输。</li>
</ul>
</li>
<li><strong>流量控制</strong>：<br>TCP使用滑动窗口机制进行流量控制，确保接收方的缓冲区不被溢出。<br>接收方在ACK包中告诉发送方它能够接收的最大数据量，发送方根据这一信息调整数据发送速度。</li>
<li><strong>拥塞控制</strong>：TCP使用拥塞控制机制来动态调整发送速率，防止网络过载，</li>
</ul>
<h4 id="TCP-拥塞控制机制"><a href="#TCP-拥塞控制机制" class="headerlink" title="TCP 拥塞控制机制"></a>TCP 拥塞控制机制</h4><ul>
<li><p><strong>慢启动</strong>：<br>发送方维护一个拥塞窗口，窗口初始设为一个小的值（通常为1个最大报文段大小MSS）<br>每一经过一RTT窗口大小翻倍，达到阈值后进入拥塞避免阶段</p>
</li>
<li><p><strong>拥塞避免</strong> ：拥塞窗口大小达到阈值之后，增长方式由指数级增长变为线性增长</p>
</li>
<li><p><strong>快重传</strong> ：<br>接收方收到失序数据包时<strong>重复发送上一个数据包的ACK</strong><br>发送方收到<strong>三个重复的ACK</strong>后，认为发生了丢包，直接重传丢失的数据包，而不是等待超时</p>
</li>
<li><p><strong>快恢复</strong> ：<br>快重传之后，TCP不会回到慢启动阶段，而是将窗口大小设置为阈值的一半，然后继续线性增长</p>
</li>
</ul>
<h4 id="TCP-流量控制机制"><a href="#TCP-流量控制机制" class="headerlink" title="TCP 流量控制机制"></a>TCP 流量控制机制</h4><p><strong>流量控制的目的</strong></p>
<ul>
<li><strong>防止接收方过载</strong>：接收方有一定的缓冲区，当发送数据过快而接收方处理不过来时，就可能造成缓冲区溢出，从而丢失数据。</li>
<li><strong>保障数据正确接收</strong>：确保数据传输双方的速率匹配，使得接收方能够及时处理和确认收到的数据。</li>
</ul>
<p>TCP采用<strong>滑动窗口机制</strong>实现流量控制，<strong>TCP报文头中有一个“窗口大小”字段（16位）</strong>，<br>它由接收方计算并告知发送方，表示接收方当前可用的缓冲区大小。</p>
<ul>
<li>发送方发送，接收方更新，协商窗口大小</li>
<li>接收方将接收数据存入缓冲区，向上层应用提供数据处理</li>
<li>接收方定期发送确认报文，缓冲区快满时、减少窗口大小，缓冲区剩余空间较大时，增大窗口大小</li>
</ul>
<p>TCP流量控制主要是为了确保发送方不会以超过接收方处理能力的速率发送数据，从而防止接收方的缓冲区溢出和数据丢失。其基本实现原理和关键组件如下：</p>
<p><strong>流量控制与拥塞控制的区别</strong></p>
<ul>
<li><strong>流量控制</strong>：主要是点对点的机制，关注的是发送方与接收方之间的数据速率匹配，防止接收方缓冲区溢出。</li>
<li><strong>拥塞控制</strong>：则是端到端的机制，目的是防止整个网络中某个环节因数据量过大而导致拥塞、丢包及延迟增加。</li>
<li>在实际传输中，发送方的发送速率受两个因素的限制：<br>接收方通告的窗口大小（流量控制）和网络状况下的拥塞窗口（拥塞控制），<br>实际允许发送的数据量为两者的最小值。</li>
</ul>
<h4 id="UDP怎么实现可靠传输"><a href="#UDP怎么实现可靠传输" class="headerlink" title="UDP怎么实现可靠传输"></a>UDP怎么实现可靠传输</h4><p><strong>选择UDP原因</strong>：TCP在<strong>传输层</strong>实现可靠连接，存在问题：连接延迟、队头阻塞、网络迁移需要重新建立连接</p>
<p>UDP本身是无连接、不可靠的协议，但在需要可靠传输的场景下，可以在<strong>应用层</strong>自行实现类似TCP的可靠性机制。一般可以从以下两方面实现：</p>
<ul>
<li><strong>超时重传</strong><ul>
<li>为每个UDP数据报设计一个自定义首部，其中包含时间戳，用于测量数据报的往返时间（RTT），从而计算合适的重传超时时间（RTO）。</li>
<li>采用“等停（stop-and-wait）”方式发送数据报，即发送一个数据报后等待对端确认，确认收到后再发送下一个；若超过RTO未收到确认，则进行重传，同时将RTO扩大为原来的两倍，再次启动计时。</li>
</ul>
</li>
<li><strong>确认和序列号机制</strong><ul>
<li>在UDP数据报首部中增加确认序列号字段，标识当前数据报的序号。</li>
<li>对端在收到数据报后，提取时间戳和序列号，并构造确认报文（ACK）返回给发送方。</li>
<li>发送方收到确认后，就知道该数据报已正确到达；同时，对端根据序列号对收到的数据报进行排序，并丢弃重复的数据报，保证数据按序交付给上层应用。</li>
</ul>
</li>
</ul>
<p><strong>QUIC协议</strong><br>基于UDP协议，在应用层实现可靠传输，通过三次握手协商ConnectionID建立连接<br>（网络迁移时只需要确认ConnectionID，可实现0RTT建立连接）</p>
<h3 id="Day08"><a href="#Day08" class="headerlink" title="Day08"></a>Day08</h3><h4 id="TCP连接三次握手的过程，为什么是三次"><a href="#TCP连接三次握手的过程，为什么是三次" class="headerlink" title="TCP连接三次握手的过程，为什么是三次"></a>TCP连接三次握手的过程，为什么是三次</h4><p>TCP 采用 <strong>三次握手</strong> 主要是为了<br><strong>确保双方的发送和接收能力都正常</strong>，<br><strong>同步初始序列号（ISN），保证数据有序传输</strong>，<br><strong>防止旧的连接请求影响新连接</strong></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>发送方</th>
<th>报文类型</th>
<th>关键字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第一次握手</strong></td>
<td>客户端</td>
<td><strong>SYN</strong></td>
<td><code>SYN=1, seq=x</code></td>
<td>请求建立连接</td>
</tr>
<tr>
<td><strong>第二次握手</strong></td>
<td>服务器</td>
<td><strong>SYN+ACK（SYN-ACK）</strong></td>
<td><code>SYN=1, ACK=1, seq=y, ack=x+1</code></td>
<td>服务器同意连接</td>
</tr>
<tr>
<td><strong>第三次握手</strong></td>
<td>客户端</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, seq=x+1, ack=y+1</code></td>
<td>确认连接建立</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>第一次握手（SYN）</strong>：客户端 → 服务器：发送 <code>SYN（seq=x）</code>，表示希望建立连接，并携带 <strong>初始序列号（ISN）</strong></p>
<ul>
<li>客户端确认自己<strong>能发送数据</strong>，请求建立连接。<ul>
<li>✔️ 客户端知道自己 <strong>能发送数据</strong>（但不知道服务器能否接收）</li>
<li>❌ 客户端还不知道服务器的状态、服务器也不知道客户端是否能正常接收数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第二次握手（SYN+ACK）</strong>：服务器 → 客户端：返回 <code>SYN+ACK（SYN=1, ACK=1, seq=y, ack=x+1）</code>，<br>表示：<strong>ACK&#x3D;x+1</strong>：确认收到了客户端的 SYN，表明服务器 <strong>能接收</strong> 数据。<br>        <strong>SYN&#x3D;y</strong>：服务器也发送自己的 SYN，请求客户端确认服务器的状态。</p>
<ul>
<li>服务器确认自己能<strong>接收并发送</strong>，并请求客户端确认。<ul>
<li>✔️ 服务器知道自己 <strong>能接收</strong> 客户端的数据。</li>
<li>✔️ 服务器知道客户端 <strong>能发送</strong> 数据。</li>
<li>❌ 服务器还不知道客户端是否能接收数据、客户端也不知道服务器的数据是否能被自己正确接收。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第三次握手（ACK）</strong>：客户端 → 服务器：发送 <code>ACK（ACK=1, seq=x+1, ack=y+1）</code><br>表示：<strong>ACK&#x3D;y+1</strong>：确认收到了服务器的 SYN，说明客户端 <strong>能接收</strong> 数据。<strong>这一步之后，双方都确认了收发能力，连接正式建立！</strong></p>
<ul>
<li>客户端最终确认服务器的<strong>发送能力</strong>，确保连接正常。<ul>
<li>✔️ 客户端&#x2F;服务器 知道对方 <strong>能收发</strong> 数据 ，成功建立连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>为什么不能用两次握手？</strong></p>
<p>如果只用 两次握手<code>（SYN → SYN+ACK）</code>，可能会遇到 <strong>旧 SYN 报文导致的错误连接问题</strong>。</p>
<p><strong>问题：旧 SYN 报文导致连接异常</strong></p>
<ol>
<li>客户端 A 发送 <code>SYN</code> 请求，但网络延迟，未到达服务器。</li>
<li>客户端 A 以为服务器无响应，放弃连接，重新发送新的 <code>SYN</code>。</li>
<li>服务器此时收到<strong>旧的</strong> <code>SYN </code>请求，并误以为客户端要建立新连接，返回 <code>SYN+ACK</code>。</li>
<li>客户端 A 没有预期这次握手，可能直接忽略或返回 RST，导致服务器错误建立连接。</li>
</ol>
<p> <strong>三次握手可以避免这个问题</strong>：</p>
<ul>
<li>只有客户端 收到服务器的 <code>SYN+ACK</code>，并主动发送 <code>ACK</code>，服务器才会确认连接建立，从而避免误连接。</li>
</ul>
<p><strong>为什么不能用四次或更多次握手？</strong></p>
<p>三次握手已经足够确保双方的收发能力正常，额外的握手只会增加开销，没有额外收益，因此三次是最合理的方案。</p>
<h4 id="TCP连接四次挥手的过程，为什么是四次？"><a href="#TCP连接四次挥手的过程，为什么是四次？" class="headerlink" title="TCP连接四次挥手的过程，为什么是四次？"></a>TCP连接四次挥手的过程，为什么是四次？</h4><p>TCP 采用 <strong>四次挥手</strong> 主要是为了<br><strong>确保双方都能正常断开连接</strong><br><strong>让双方的数据传输完全结束，避免丢失</strong><br><strong>保证全双工通信中，双方都能独立关闭发送方向</strong></p>
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>发送方</strong></th>
<th><strong>报文类型</strong></th>
<th><strong>关键字段</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>第一次挥手</strong></td>
<td>客户端</td>
<td><strong>FIN</strong></td>
<td><code>FIN=1, seq=x</code></td>
<td>请求关闭连接</td>
</tr>
<tr>
<td><strong>第二次挥手</strong></td>
<td>服务器</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, ack=x+1</code></td>
<td>确认关闭请求</td>
</tr>
<tr>
<td><strong>第三次挥手</strong></td>
<td>服务器</td>
<td><strong>FIN</strong></td>
<td><code>FIN=1, seq=y</code></td>
<td>服务器请求关闭</td>
</tr>
<tr>
<td><strong>第四次挥手</strong></td>
<td>客户端</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, ack=y+1</code></td>
<td>确认服务器关闭</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>第一次挥手（客户端 → 服务器：FIN）</strong></p>
<ul>
<li>客户端 发送 <code>FIN（seq=x）</code>，表示自己 没有数据要发送了，请求关闭 发送方向。<br>客户端进入 <strong>FIN-WAIT-1状态</strong>，等待服务器确认。</li>
<li>客户端 –&gt; 服务器: <code>FIN, seq=x</code></li>
</ul>
</li>
<li><p><strong>第二次挥手（服务器 → 客户端：ACK）</strong></p>
<ul>
<li>服务器 发送 <code>ACK（ack=x+1）</code>，表示 收到了客户端的关闭请求，但仍可能有数据要发送。<br>服务器进入 <strong>CLOSE-WAIT 状态</strong>，继续处理剩余数据。<br>客户端进入 <strong>FIN-WAIT-2 状态</strong>，等待服务器关闭。</li>
<li>服务器 –&gt; 客户端: <code>ACK, ack=x+1</code></li>
</ul>
</li>
<li><p><strong>第三次挥手（服务器 → 客户端：FIN）</strong></p>
<ul>
<li>服务器 处理完所有数据后，发送<code> FIN（seq=y）</code>，请求关闭 发送方向。<br>服务器进入 <strong>LAST-ACK 状态</strong>，等待客户端的确认。</li>
<li>服务器 –&gt; 客户端: <code>FIN, seq=y</code></li>
</ul>
</li>
<li><p><strong>第四次挥手（客户端 → 服务器：ACK）</strong></p>
<ul>
<li>客户端 发送 <code>ACK（ack=y+1）</code>，确认服务器的关闭请求。<br>客户端进入 <strong>TIME-WAIT 状态</strong>，等待 <strong>2MSL</strong>（最大报文生存时间），确保服务器收到 <code>ACK</code> 后才完全释放连接。<br>服务器收到 ACK 后，进入 <strong>CLOSED 状态</strong>，彻底关闭连接。</li>
<li>客户端 –&gt; 服务器: <code>ACK, ack=y+1</code></li>
</ul>
</li>
</ul>
<p><strong>为什么需要四次挥手，而不是三次？</strong></p>
<p>TCP 是 <strong>全双工通信</strong>，<strong>数据的 发送和接收是独立的，所以需要分别关闭：</strong></p>
<p>前两次挥手：客户端请求关闭 发送通道，服务器确认<br>后两次挥手：服务器处理完剩余数据后，主动关闭 发送通道，客户端确认</p>
<p><strong>如果只用 三次挥手：</strong></p>
<p>服务器如果 还未发送完数据 就直接关闭，可能导致<strong>数据丢失</strong>。</p>
<p><strong>TIME-WAIT 状态与 2MSL 等待期</strong><br>TIME-WAIT 作用</p>
<ul>
<li>确保服务器收到最终的 <code>ACK</code><br>如果服务器没有收到 <code>ACK</code>，它会超时重发<code> FIN</code>，<strong>TIME-WAIT</strong> 允许客户端 重新发送 <code>ACK</code>。</li>
<li>防止旧连接数据干扰新连接<br>旧连接的数据可能在网络中滞留，<strong>TIME-WAIT</strong> 确保这些数据在新连接建立前被丢弃。</li>
</ul>
<p><strong>为什么等待 2MSL？</strong></p>
<p><strong>MSL</strong>（Maximum Segment Lifetime） 是一个 TCP 报文在网络中的最长存活时间。<br>等待 2MSL 确保网络中 所有旧数据包都已消失，避免影响新连接。</p>
<h4 id="HTTP的Keep-Alive是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？"><a href="#HTTP的Keep-Alive是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？" class="headerlink" title="HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？"></a>HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</h4><ul>
<li><p><strong>HTTP Keep-Alive</strong>	 <strong>HTTP 应用层</strong>。</p>
<ul>
<li>HTTP 的 <strong>Keep-Alive</strong> 机制允许 <strong>在同一个 TCP 连接上发送多个 HTTP 请求和响应</strong>，而不是在每个请求后都关闭 TCP 连接。</li>
<li><strong>目的</strong><ul>
<li>减少 TCP 连接的建立和关闭开销**，避免频繁的三次握手（建立连接）和四次挥手（关闭连接）。**</li>
<li>提高 HTTP 请求的性能**，减少请求延迟，提高服务器的吞吐量。**</li>
<li>减少服务器资源消耗，降低 CPU 和内存开销。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>TCP Keepalive</strong>    <strong>TCP 传输层</strong></p>
<ul>
<li>TCP 的 <strong>Keepalive 机制不是用来复用连接的，而是用于检测 TCP 连接是否仍然存活</strong>。当一个 TCP 连接长时间没有数据传输时，TCP Keepalive <strong>定期发送探测包</strong>，检查对端是否仍然在线，以避免资源浪费。</li>
<li><strong>目的</strong><ul>
<li><strong>检测并清理无效的 TCP 连接</strong>，防止服务器资源被僵尸连接占用。</li>
<li><strong>保持 NAT 设备中的 TCP 连接映射有效</strong>，防止 NAT 设备因长时间无数据而丢弃连接。</li>
</ul>
</li>
<li><strong>TCP Keepalive 的工作方式</strong><ul>
<li><strong>TCP 连接长时间没有数据传输</strong>（默认 2 小时）。<strong>内核发送 Keepalive 探测包</strong>，询问对方是否存活。</li>
<li><strong>如果对方正常响应</strong>，连接继续保持。<strong>如果连续多次探测无响应</strong>（如 3 次），TCP 认为对端失效，关闭连接。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>HTTP Keep-Alive 和 TCP Keepalive 的区别</strong></p>
<ul>
<li><strong>核心区别</strong><ul>
<li><strong>HTTP Keep-Alive 解决的是“重复建立连接的问题”</strong>，避免 HTTP 请求频繁创建新 TCP 连接。</li>
<li><strong>TCP Keepalive 解决的是“连接是否还存活的问题”</strong>，防止僵尸连接占用系统资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>机制</th>
<th>作用</th>
<th>适用协议</th>
<th>作用层次</th>
<th>触发方式</th>
<th>典型使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HTTP Keep-Alive</strong></td>
<td>复用 TCP 连接，减少握手开销</td>
<td>HTTP</td>
<td><strong>应用层</strong></td>
<td>HTTP 头部 <code>Connection: Keep-Alive</code></td>
<td>加速 HTTP 访问，减少 TCP 连接消耗</td>
</tr>
<tr>
<td><strong>TCP Keepalive</strong></td>
<td>检测 TCP 连接是否存活，防止僵尸连接</td>
<td>TCP</td>
<td><strong>传输层</strong></td>
<td>操作系统定期发送探测包</td>
<td>服务器维护长连接，检测对端是否存活</td>
</tr>
</tbody></table>
<h3 id="Day09"><a href="#Day09" class="headerlink" title="Day09"></a>Day09</h3><h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><p>DNS基本概念</p>
<ul>
<li><strong>DNS是什么？</strong><br>域名系统（Domain Name System）是将易记的域名（例如 <a target="_blank" rel="noopener" href="http://www.example.com)转换为计算机能识别的ip地址(例如/">www.example.com）转换为计算机能识别的IP地址（例如</a> 192.0.2.1）的分布式数据库系统。它类似于互联网的“电话簿”，使我们无需记住数字地址即可访问网站。</li>
<li><strong>DNS的作用</strong><br>DNS使得互联网用户可以通过友好的域名访问网站、邮件服务器等，同时提供一定的负载均衡和容错能力。</li>
</ul>
<p><strong>DNS查询的基本流程</strong></p>
<p><strong>用户发起请求</strong><br>当你在浏览器中输入一个URL时，操作系统和浏览器会检查各自的DNS缓存（以及Hosts文件），<br>如果已经存在该域名对应的IP地址，解析过程会立即结束；<br>如果没有命中，则向配置的本地域名解析器（DNS Resolver）发送请求。</p>
<p><strong>本地域名解析器处理请求（递归查询）</strong><br>本地DNS服务器通常采用递归查询方式，它负责替客户端查找最终的IP地址。<br>（<strong>递归查询</strong>由本地域名解析器替客户端完成所有查询过程，简化了客户端的操作。）</p>
<p>若自身缓存中没有记录，它会依次向其他DNS服务器发起查询。</p>
<p><strong>迭代查询过程</strong><br>本地域名解析器会按照以下步骤依次查询：</p>
<ul>
<li><strong>查询根DNS服务器</strong>：<br>根服务器不会返回具体的IP地址，而是告诉解析器该查询应转发到哪个顶级域（如.com、.net、.org）的DNS服务器。</li>
<li><strong>查询顶级域名服务器</strong>：<br>利用根服务器返回的信息，本地解析器向对应的顶级域名服务器发出查询。<br>顶级域名服务器同样不会直接返回目标IP，而是指向负责该域名的权威DNS服务器。</li>
<li><strong>查询权威DNS服务器</strong>：<br>本地DNS解析器最终向权威DNS服务器发送查询请求，权威服务器并返回具体的IP地址。<br>（权威DNS服务器是负责存储特定域名和IP地址映射的服务器）</li>
</ul>
<p><strong>返回结果</strong><br>得到IP地址后，本地域名解析器将结果缓存（以便下次查询更快响应），并将IP地址返回给客户端，浏览器随后使用该IP地址发起HTTP请求访问网站。</p>
<h4 id="CDN是什么，有什么作用？"><a href="#CDN是什么，有什么作用？" class="headerlink" title="CDN是什么，有什么作用？"></a>CDN是什么，有什么作用？</h4><p>CDN（内容分发网络）是一种由遍布全球各地的边缘服务器组成的分布式网络系统，<br>其核心目的是将网站的静态资源（如图片、CSS、JavaScript文件等）缓存在离用户最近的节点上，从而加速内容加载，降低延迟，提高网站性能和用户体验。</p>
<p><strong>工作原理</strong></p>
<ol>
<li><strong>用户请求</strong><br> 当用户在浏览器中请求某个网站时，DNS系统会将请求解析到CDN网络中离用户最近的<strong>边缘服务器</strong>。<ul>
<li><strong>调度系统</strong><br>通过DNS解析或Anycast技术，把用户请求引导到最优的CDN节点</li>
<li><strong>边缘服务器&#x2F;PoP（Point of Presence）</strong><br>分布在各地的节点，负责缓存内容并快速响应用户请求。</li>
</ul>
</li>
<li><strong>缓存内容</strong><ul>
<li><strong>边缘缓存</strong>：如果该边缘服务器已缓存了所需内容，则直接返回给用户，无需每次都访问源站。</li>
<li><strong>回源请求</strong>：如果缓存中没有，则边缘服务器会向源站（Origin Server）请求内容，并将获取到的内容缓存起来，以便后续请求使用。<ul>
<li><strong>缓存策略</strong><ul>
<li><strong>TTL（生存时间）</strong>：决定缓存内容在边缘节点中存留多久。</li>
<li><strong>缓存失效与更新策略</strong>：确保内容及时更新，比如通过主动刷新、定时更新或基于内容变更的触发机制。</li>
<li><strong>分层缓存</strong>：结合多级缓存结构，使不同类型的内容（静态与动态）能够有效缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>可用性</strong>：即使某些节点出现问题，用户请求可以被重定向到其他健康的节点。</li>
</ol>
<p><strong>主要优势与作用</strong></p>
<ul>
<li><strong>提升访问速度</strong><br> 用户可以从最近的节点获取内容，大幅降低延迟，加快页面加载速度。</li>
<li><strong>减轻源站压力</strong><br> 大量静态资源由CDN节点分担，源站不需要处理所有流量，降低服务器负载。</li>
<li><strong>提高可靠性与可用性</strong><br> 多个节点分布在全球，即使部分节点发生故障，其他节点仍能提供服务，增强整体稳定性。</li>
<li><strong>防御DDoS攻击</strong><br> 分布式架构能够吸收并分散恶意流量，提升抗攻击能力。</li>
<li><strong>改善用户体验</strong><br> 快速加载和更稳定的连接使用户获得更流畅的浏览体验，进而提高网站转化率和满意度。</li>
</ul>
<h4 id="Cookie和Session是什么？有什么区别？"><a href="#Cookie和Session是什么？有什么区别？" class="headerlink" title="Cookie和Session是什么？有什么区别？"></a>Cookie和Session是什么？有什么区别？</h4><ul>
<li><p><strong>Cookie</strong></p>
<ul>
<li>客户端&#x2F;浏览器发起HTTP请求后服务器通过 HTTP 响应头设置<code>Set-Cookie</code>值，<br>由服务器将一个或多个<code> Cookie</code> 发送到用户浏览器，然后浏览器将这些 <code>Cookie</code> 存储在本地。<br>服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的<code>Cookie</code>得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</li>
<li><code>Cookie</code>  存储容量较小，一般为几 KB<br>生命周期由服务器设置，通过HTTP请求自动发送</li>
<li>易被窃取、篡改、有传输风险（中间人截获）—&gt; HTTPS</li>
<li>存储小量非敏感信息，如用户个性化设置，临时状态等</li>
</ul>
</li>
<li><p><strong>Session</strong></p>
<ul>
<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是<code>Session</code>。（<code>Session</code>  数据存储在服务器上）</li>
<li>存储容量较大，通常没有固定限制，取决于服务器的配置和资源。<br>生命周期由服务器管理（默认与会话相关，通常在浏览器关闭后失效）<br><code>Session ID</code>  通常通过<code> Cookie</code>  或 URL 参数传递</li>
<li>Session 数据存储在服务器上，更难被用户访问和修改<br>（攻击者获取Session后也有可能冒充用户）</li>
<li>Session主要用于存储用户登录状态及权限信息、保存敏感数据和状态管理（在多步操作或交易中，存储临时数据，确保数据一致性）等</li>
</ul>
</li>
</ul>
<h3 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h3><h4 id="进程和线程之间有什么区别"><a href="#进程和线程之间有什么区别" class="headerlink" title="进程和线程之间有什么区别"></a>进程和线程之间有什么区别</h4><ul>
<li><strong>进程</strong><ul>
<li>进程是<strong>操作系统进行资源分配和调度的基本单位</strong>，<br><strong>每个进程拥有独立的内存空间、代码段、数据段以及系统资源。</strong></li>
<li><strong>独立内存空间</strong>：每个进程都有自己独立的地址空间，因此在创建和销毁时需要分配或回收较多资源，开销较大。<br><strong>上下文切换开销</strong>：进程切换时需要保存和恢复整个进程的状态，导致上下文切换开销较高。</li>
<li><strong>进程间通信（IPC）</strong>：由于进程相互隔离，通信必须依赖专门的机制，如管道、消息队列、共享内存等，这使得进程间通信相对复杂。</li>
<li><strong>隔离性高</strong>：进程之间相互隔离，一个进程的崩溃一般不会影响到其他进程，因而整体安全性和稳定性较好。</li>
</ul>
</li>
<li><strong>线程</strong><ul>
<li>线程是<strong>程序执行的最小单位</strong>，是进程内的执行单元。<br><strong>一个进程至少包含一个线程，也可以拥有多个线程，这些线程共享进程内的内存空间和资源</strong></li>
<li><strong>共享内存空间</strong>：同一进程中的所有线程共享内存和其他资源，因此创建和销毁线程的成本较低。<br><strong>轻量级切换</strong>：线程之间的切换只需保存少量的上下文信息，上下文切换速度快。</li>
<li><strong>直接共享数据</strong>：同一进程内的线程可以直接访问共享内存，因此线程间通信更为方便。但这种共享也可能引发数据竞争，需要使用互斥锁、信号量等同步机制进行协调。</li>
<li><strong>风险共享</strong>：由于同一进程内的线程共享内存和资源，一个线程出现错误（如非法内存访问）可能导致整个进程崩溃，从而影响系统稳定性。</li>
</ul>
</li>
</ul>
<p>在实际应用中，<br>如果需要高度的安全性和资源隔离，使用进程会更合适；<br>而如果追求高效的并发和轻量级的切换，线程则是更好的选择。</p>
<h4 id="并行和并发有什么区别"><a href="#并行和并发有什么区别" class="headerlink" title="并行和并发有什么区别"></a>并行和并发有什么区别</h4><p><strong>并行</strong>：</p>
<ul>
<li><strong>定义</strong>：在同一时刻同时执行多个任务，每个任务在不同的处理器或处理器核心上运行。</li>
<li><strong>实现方式</strong>：依赖于多核处理器或多处理器系统，将任务分配到不同的处理单元上同时执行。</li>
<li><strong>应用场景</strong>：适用于计算密集型任务，如科学计算或图像处理，通过并行处理提高效率。</li>
</ul>
<p><strong>并发</strong>：</p>
<ul>
<li><strong>定义</strong>：在同一时间段内管理和处理多个任务，这些任务可能交替执行，但在微观上并非同时进行。</li>
<li><strong>实现方式</strong>：通过任务调度和上下文切换，使多个任务在单个处理器上轮流执行，给人以同时进行的感觉。</li>
<li><strong>应用场景</strong>：适用于需要同时处理多个任务的场景，如网络服务器需要同时响应多个客户端请求。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>执行方式</strong>：并发是通过快速切换在单个处理器上交替执行多个任务；并行是利用多个处理器同时执行多个任务。</li>
<li><strong>硬件需求</strong>：并发可在单处理器系统中实现；并行需要多处理器或多核处理器的支持。</li>
<li><strong>任务交互</strong>：并发任务之间可能需要频繁的上下文切换，存在资源竞争；并行任务通常在独立的处理单元上运行，资源竞争较少。</li>
</ul>
<p><strong>区别与联系</strong>：</p>
<ul>
<li><strong>执行方式</strong>：并发通过任务调度在单个或多个处理器上交替执行多个任务；并行则在多个处理器或多核处理器上同时执行多个任务。</li>
<li><strong>资源利用</strong>：并发通过共享资源（如CPU时间）来提高系统的响应速度；并行通过增加处理单元来提高处理能力。</li>
<li><strong>目的</strong>：并发旨在提高资源利用率和系统吞吐量；并行旨在缩短任务的执行时间。</li>
</ul>
<p><strong>实现、性能、应用场景和复杂性方面的差异</strong>：</p>
<ul>
<li><strong>实现</strong>：<ul>
<li><strong>并发</strong>：通常通过多线程或多进程在单个处理器上实现，依赖于操作系统的任务调度。</li>
<li><strong>并行</strong>：需要硬件支持，如多核处理器或多处理器系统，通过将任务分解为独立的子任务，分配到不同的处理单元上同时执行。</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li><strong>并发</strong>：通过减少任务的等待时间，提高系统的响应性，但频繁的上下文切换可能带来开销。</li>
<li><strong>并行</strong>：通过同时执行多个任务，显著缩短总的执行时间，但需要考虑任务间的同步和通信开销。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>并发</strong>：适用于需要同时处理大量任务且任务之间可能存在交互的场景，如Web服务器需要同时处理多个客户端请求。</li>
<li><strong>并行</strong>：适用于计算密集型任务，如科学计算、图像处理等，需要将大任务分解为可并行执行的子任务。</li>
</ul>
</li>
<li><strong>复杂性</strong>：<ul>
<li><strong>并发</strong>：需要处理任务间的同步和资源竞争问题，可能导致死锁、竞态条件等复杂情况。</li>
<li><strong>并行</strong>：需要将任务有效地分解为独立的子任务，并处理任务间的协调和数据共享，增加了编程的复杂性。</li>
</ul>
</li>
</ul>
<h4 id="解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？"><a href="#解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？" class="headerlink" title="解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？"></a>解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？</h4><h3 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h3><h4 id="进程调度算法你了解多少"><a href="#进程调度算法你了解多少" class="headerlink" title="进程调度算法你了解多少"></a>进程调度算法你了解多少</h4><h4 id="进程间有哪些通信方式"><a href="#进程间有哪些通信方式" class="headerlink" title="进程间有哪些通信方式"></a>进程间有哪些通信方式</h4><h4 id="解释一下进程同步和互斥，以及如何实现进程同步和互斥"><a href="#解释一下进程同步和互斥，以及如何实现进程同步和互斥" class="headerlink" title="解释一下进程同步和互斥，以及如何实现进程同步和互斥"></a>解释一下进程同步和互斥，以及如何实现进程同步和互斥</h4><h3 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h3><h4 id="什么是死锁，如何避免死锁？"><a href="#什么是死锁，如何避免死锁？" class="headerlink" title="什么是死锁，如何避免死锁？"></a>什么是死锁，如何避免死锁？</h4><h4 id="介绍一下几种典型的锁"><a href="#介绍一下几种典型的锁" class="headerlink" title="介绍一下几种典型的锁"></a>介绍一下几种典型的锁</h4><h4 id="讲一讲你理解的虚拟内存"><a href="#讲一讲你理解的虚拟内存" class="headerlink" title="讲一讲你理解的虚拟内存"></a>讲一讲你理解的虚拟内存</h4><h3 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h3><h4 id="你知道的线程同步的方式有哪些？"><a href="#你知道的线程同步的方式有哪些？" class="headerlink" title="你知道的线程同步的方式有哪些？"></a>你知道的线程同步的方式有哪些？</h4><h4 id="有哪些页面置换算法"><a href="#有哪些页面置换算法" class="headerlink" title="有哪些页面置换算法"></a>有哪些页面置换算法</h4>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"># 八股</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/17/2025-02-17-Redis/" rel="prev" title="Redis">
      <i class="fa fa-chevron-left"></i> Redis
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/20/2025-02-20-%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/" rel="next" title="从零开始搭建仿牛客论坛项目">
      从零开始搭建仿牛客论坛项目 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Day01"><span class="nav-number">1.</span> <span class="nav-text">Day01</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BTCP-IP%E6%A8%A1%E5%9E%8B%E5%92%8COSI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">介绍一下TCP&#x2F;IP模型和OSI模型的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">从输入 URL 到页面展示到底发生了什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day02"><span class="nav-number">2.</span> <span class="nav-text">Day02</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">HTTP请求报文和响应报文是怎样的，有哪些常见的字段？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="nav-number">2.1.1.</span> <span class="nav-text">请求报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="nav-number">2.1.2.</span> <span class="nav-text">响应报文</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">HTTP有哪些请求方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.</span> <span class="nav-text">GET请求和POST请求的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day03"><span class="nav-number">3.</span> <span class="nav-text">Day03</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">3.1.</span> <span class="nav-text">HTTP请求中常见的状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-number">3.2.</span> <span class="nav-text">什么是强缓存和协商缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="nav-number">3.2.1.</span> <span class="nav-text">强缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-number">3.2.2.</span> <span class="nav-text">协商缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day04"><span class="nav-number">4.</span> <span class="nav-text">Day04</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP1-0%E5%92%8CHTTP1-1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text">HTTP1.0和HTTP1.1的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP2-0%E4%B8%8EHTTP1-1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">HTTP2.0与HTTP1.1的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP3-0%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">HTTP3.0有了解过吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day05"><span class="nav-number">5.</span> <span class="nav-text">Day05</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E5%92%8CHTTP%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">HTTPS和HTTP有哪些区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-HTTPS%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">HTTPS的工作原理(HTTPS建立连接的过程）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">TCP和UDP的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day06"><span class="nav-number">6.</span> <span class="nav-text">Day06</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">6.1.</span> <span class="nav-text">TCP连接如何确保可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">6.2.</span> <span class="nav-text">TCP 拥塞控制机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">6.3.</span> <span class="nav-text">TCP 流量控制机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">6.4.</span> <span class="nav-text">UDP怎么实现可靠传输</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day08"><span class="nav-number">7.</span> <span class="nav-text">Day08</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1"><span class="nav-number">7.1.</span> <span class="nav-text">TCP连接三次握手的过程，为什么是三次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">TCP连接四次挥手的过程，为什么是四次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E7%9A%84Keep-Alive%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FTCP-%E7%9A%84-Keepalive-%E5%92%8C-HTTP-%E7%9A%84-Keep-Alive-%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%E5%90%97%EF%BC%9F"><span class="nav-number">7.3.</span> <span class="nav-text">HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day09"><span class="nav-number">8.</span> <span class="nav-text">Day09</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">8.1.</span> <span class="nav-text">DNS查询过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CDN%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">CDN是什么，有什么作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie%E5%92%8CSession%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">Cookie和Session是什么？有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day10"><span class="nav-number">9.</span> <span class="nav-text">Day10</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">9.1.</span> <span class="nav-text">进程和线程之间有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">9.2.</span> <span class="nav-text">并行和并发有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E6%A0%B8%E5%BF%83%E6%80%81%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="nav-number">9.3.</span> <span class="nav-text">解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day11"><span class="nav-number">10.</span> <span class="nav-text">Day11</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91"><span class="nav-number">10.1.</span> <span class="nav-text">进程调度算法你了解多少</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">10.2.</span> <span class="nav-text">进程间有哪些通信方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="nav-number">10.3.</span> <span class="nav-text">解释一下进程同步和互斥，以及如何实现进程同步和互斥</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day12"><span class="nav-number">11.</span> <span class="nav-text">Day12</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">11.1.</span> <span class="nav-text">什么是死锁，如何避免死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81"><span class="nav-number">11.2.</span> <span class="nav-text">介绍一下几种典型的锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E8%AE%B2%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">11.3.</span> <span class="nav-text">讲一讲你理解的虚拟内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Day13"><span class="nav-number">12.</span> <span class="nav-text">Day13</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">12.1.</span> <span class="nav-text">你知道的线程同步的方式有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">12.2.</span> <span class="nav-text">有哪些页面置换算法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="间"
      src="/images/new_avatar.png">
  <p class="site-author-name" itemprop="name">间</p>
  <div class="site-description" itemprop="description">面向就业学习，Java相关技术栈、面试八股文和算法题中...</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">间</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/',]
      });
      });
  </script>

</body>
</html>
