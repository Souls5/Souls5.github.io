<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/web-app-manifest-192x192.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-96x96.png">
  <link rel="mask-icon" href="/images/favicon/favicon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"souls5.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
<meta property="og:type" content="website">
<meta property="og:title" content="不是不是">
<meta property="og:url" content="https://souls5.github.io/index.html">
<meta property="og:site_name" content="不是不是">
<meta property="og:description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="间">
<meta property="article:tag" content="Java,JavaWeb,Redis,Nosql,Linux,算法,数据结构,面试,数据结构">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://souls5.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>不是不是</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不是不是</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习、挣扎和一些无关紧要的琐事...大概</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/05/25/2025-05-25-SELinux%E7%AD%96%E7%95%A5%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/25/2025-05-25-SELinux%E7%AD%96%E7%95%A5%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">2025-05-25-SELinux策略结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-25 14:41:16" itemprop="dateCreated datePublished" datetime="2025-05-25T14:41:16+08:00">2025-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-26 17:23:00" itemprop="dateModified" datetime="2025-05-26T17:23:00+08:00">2025-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%95%E8%AE%BE/" itemprop="url" rel="index"><span itemprop="name">毕设</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h4><p><a target="_blank" rel="noopener" href="https://saucer-man.com/operation_and_maintenance/84.html">SELinux从入门到放弃</a></p>
<p>根据这篇文章简要总结如下内容</p>
<p><strong>强制访问控制和自主访问控制的区别：</strong></p>
<ul>
<li><p>自主访问控制 (discretionary access control,  DAC)  </p>
<ul>
<li>由资源的所有者决定对其资源的访问权限。例如，在传统的 Linux 系统中，文件的属主可以通过设置文件权限来控制其他用户的访问</li>
</ul>
</li>
<li><p>强制访问控制 (mandatory access control, MAC) </p>
<ul>
<li>由系统的安全策略统一管理，用户无法随意更改。例如，SELinux 通过预定义的策略规则，控制进程对文件、目录、端口等资源的访问，即使是 root 用户也不能绕过这些规则</li>
</ul>
</li>
</ul>
<p><strong>SELinux带给Linux的主要价值是：提供了一个灵活的，可配置的MAC机制</strong></p>
<p><strong>SELinux相对于其他强制性访问控制系统的优势</strong></p>
<p><strong>SELinux 的运行机制</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/04/01/2025-04-01-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BA%8C%E5%8F%89%E6%A0%91part01-%E4%BA%8C%E5%8F%89%E6%A0%91part08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/01/2025-04-01-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BA%8C%E5%8F%89%E6%A0%91part01-%E4%BA%8C%E5%8F%89%E6%A0%91part08/" class="post-title-link" itemprop="url">2025-04-01-第六章-二叉树part01-二叉树part08</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-01 13:59:15 / 修改时间：14:15:08" itemprop="dateCreated datePublished" datetime="2025-04-01T13:59:15+08:00">2025-04-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE"> 代码随想录二叉树理论基础</a></p>
<h2 id="第六章二叉树part01"><a href="#第六章二叉树part01" class="headerlink" title="第六章二叉树part01"></a>第六章二叉树part01</h2><h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a><strong>理论基础</strong></h4><p>需要了解 二叉树的种类，存储方式，遍历方式 以及二叉树的定义 </p>
<h4 id="递归遍历-（必须掌握）"><a href="#递归遍历-（必须掌握）" class="headerlink" title="递归遍历 （必须掌握）"></a><strong>递归遍历 （必须掌握）</strong></h4><p>二叉树的三种递归遍历掌握其规律后，其实很简单 </p>
<h4 id="迭代遍历-（基础不好的录友，迭代法可以放过）"><a href="#迭代遍历-（基础不好的录友，迭代法可以放过）" class="headerlink" title="迭代遍历 （基础不好的录友，迭代法可以放过）"></a><strong>迭代遍历 （基础不好的录友，迭代法可以放过）</strong></h4><h4 id="统一迭代-（基础不好的录友，迭代法可以放过）"><a href="#统一迭代-（基础不好的录友，迭代法可以放过）" class="headerlink" title="统一迭代   （基础不好的录友，迭代法可以放过）"></a><strong>统一迭代   （基础不好的录友，迭代法可以放过）</strong></h4><p>这是统一迭代法的写法， 如果学有余力，可以掌握一下</p>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a><strong>层序遍历</strong></h4><p>看完本篇可以一口气刷十道题，试一试， 层序遍历并不难，大家可以很快刷了十道题。</p>
<h2 id="第六章二叉树part02"><a href="#第六章二叉树part02" class="headerlink" title="第六章二叉树part02"></a>第六章二叉树part02</h2><h5 id="226-翻转二叉树-（优先掌握递归）"><a href="#226-翻转二叉树-（优先掌握递归）" class="headerlink" title="226.翻转二叉树 （优先掌握递归）"></a>226.翻转二叉树 （优先掌握递归）</h5><p>这道题目 一些做过的同学 理解的也不够深入，建议大家先看我的视频讲解，无论做过没做过，都会有很大收获。</p>
<h5 id="101-对称二叉树-（优先掌握递归）"><a href="#101-对称二叉树-（优先掌握递归）" class="headerlink" title="101. 对称二叉树 （优先掌握递归）"></a>101. 对称二叉树 （优先掌握递归）</h5><p>先看视频讲解，会更容易一些。 </p>
<h5 id="104-二叉树的最大深度-（优先掌握递归）"><a href="#104-二叉树的最大深度-（优先掌握递归）" class="headerlink" title="104.二叉树的最大深度 （优先掌握递归）"></a>104.二叉树的最大深度 （优先掌握递归）</h5><p>什么是深度，什么是高度，如何求深度，如何求高度，这里有关系到二叉树的遍历方式。</p>
<p>大家 要先看视频讲解，就知道以上我说的内容了，很多录友刷过这道题，但理解的还不够。</p>
<h5 id="111-二叉树的最小深度-（优先掌握递归）"><a href="#111-二叉树的最小深度-（优先掌握递归）" class="headerlink" title="111.二叉树的最小深度 （优先掌握递归）"></a>111.二叉树的最小深度 （优先掌握递归）</h5><p>先看视频讲解，和最大深度 看似差不多，其实 差距还挺大，有坑。</p>
<h2 id="第六章二叉树part03"><a href="#第六章二叉树part03" class="headerlink" title="第六章二叉树part03"></a>第六章二叉树part03</h2><p><strong>迭代法，大家可以直接过，二刷有精力的时候 再去掌握迭代法。</strong></p>
<h5 id="110-平衡二叉树-（优先掌握递归）"><a href="#110-平衡二叉树-（优先掌握递归）" class="headerlink" title="110.平衡二叉树 （优先掌握递归）"></a>110.平衡二叉树 （优先掌握递归）</h5><p>再一次涉及到，什么是高度，什么是深度，可以巩固一下。</p>
<h5 id="257-二叉树的所有路径-（优先掌握递归）"><a href="#257-二叉树的所有路径-（优先掌握递归）" class="headerlink" title="257. 二叉树的所有路径 （优先掌握递归）"></a>257. 二叉树的所有路径 （优先掌握递归）</h5><p>这是大家第一次接触到回溯的过程， 我在视频里重点讲解了 本题为什么要有回溯，已经回溯的过程。 </p>
<p>如果对回溯 似懂非懂，没关系， 可以先有个印象。 </p>
<h5 id="404-左叶子之和-（优先掌握递归）"><a href="#404-左叶子之和-（优先掌握递归）" class="headerlink" title="404.左叶子之和 （优先掌握递归）"></a>404.左叶子之和 （优先掌握递归）</h5><p>其实本题有点文字游戏搞清楚什么是左叶子，剩下的就是二叉树的基本操作。 </p>
<h5 id="222-完全二叉树的节点个数（优先掌握递归）"><a href="#222-完全二叉树的节点个数（优先掌握递归）" class="headerlink" title="222.完全二叉树的节点个数（优先掌握递归）"></a>222.完全二叉树的节点个数（优先掌握递归）</h5><p>需要了解，普通二叉树 怎么求，完全二叉树又怎么求</p>
<h2 id="第六章二叉树part04"><a href="#第六章二叉树part04" class="headerlink" title="第六章二叉树part04"></a>第六章二叉树part04</h2><h5 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h5><p>本题递归偏难，反而迭代简单属于模板题， 两种方法掌握一下 </p>
<h5 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h5><p>本题 又一次涉及到回溯的过程，而且回溯的过程隐藏的还挺深，建议先看视频来理解 </p>
<p>\112. 路径总和，和 113. 路径总和ii 一起做了。 优先掌握递归法。</p>
<h5 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h5><p>106.从中序与后序遍历序列构造二叉树，105.从前序与中序遍历序列构造二叉树 一起做，思路一样的</p>
<h2 id="第六章二叉树part05"><a href="#第六章二叉树part05" class="headerlink" title="第六章二叉树part05"></a>第六章二叉树part05</h2><h5 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h5><p>又是构造二叉树，昨天大家刚刚做完 中序后序确定二叉树，今天做这个 应该会容易一些， 先看视频，好好体会一下 为什么构造二叉树都是 前序遍历 </p>
<h5 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h5><p>这次是一起操作两个二叉树了， 估计大家也没一起操作过两个二叉树，也不知道该如何一起操作，可以看视频先理解一下。 优先掌握递归。</p>
<h5 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h5><p>递归和迭代 都可以掌握以下，因为本题比较简单， 了解一下 二叉搜索树的特性</p>
<h5 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h5><p>遇到 搜索树，一定想着中序遍历，这样才能利用上特性。 </p>
<p>但本题是有陷阱的，可以自己先做一做，然后在看题解，看看自己是不是掉陷阱里了。这样理解的更深刻。</p>
<h2 id="第六章二叉树part06"><a href="#第六章二叉树part06" class="headerlink" title="第六章二叉树part06"></a>第六章二叉树part06</h2><h5 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h5><p>需要领悟一下二叉树遍历上双指针操作，优先掌握递归 </p>
<h5 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h5><p>和 530差不多双指针思路，不过 这里涉及到一个很巧妙的代码技巧。</p>
<h5 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h5><p>本题其实是比较难的，可以先看我的视频讲解 </p>
<h2 id="第六章二叉树part07"><a href="#第六章二叉树part07" class="headerlink" title="第六章二叉树part07"></a>第六章二叉树part07</h2><h5 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h5><p>相对于 二叉树的最近公共祖先 本题就简单一些了，因为 可以利用二叉搜索树的特性。 </p>
<h5 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h5><p>本题比想象中的简单，大家可以先自己想一想应该怎么做，然后看视频讲解，就发现 本题为什么比较简单了。</p>
<h5 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h5><p>相对于 插入操作，本题就有难度了，涉及到改树的结构 </p>
<h2 id="第六章二叉树part08"><a href="#第六章二叉树part08" class="headerlink" title="第六章二叉树part08"></a>第六章二叉树part08</h2><h5 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><strong>669. 修剪二叉搜索树</strong></h5><p><strong>这道题目比较难</strong>，比 添加增加和删除节点难的多，建议先看视频理解。</p>
<h5 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h5><p>本题就简单一些，可以尝试先自己做做。</p>
<h5 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h5><p>本题也不难，在 求二叉搜索树的最小绝对差 和 众数 那两道题目 都讲过了 双指针法，思路是一样的。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/28/2025-03-28-%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%88%E6%9D%82%E8%B0%88-%E7%A2%8E%E7%A2%8E%E5%BF%B5%E8%AF%B4%E6%98%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/28/2025-03-28-%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%88%E6%9D%82%E8%B0%88-%E7%A2%8E%E7%A2%8E%E5%BF%B5%E8%AF%B4%E6%98%AF/" class="post-title-link" itemprop="url">2025-03-28-日程记录（笔面试/碎碎念说是...</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-28 11:38:56" itemprop="dateCreated datePublished" datetime="2025-03-28T11:38:56+08:00">2025-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-25 14:33:28" itemprop="dateModified" datetime="2025-05-25T14:33:28+08:00">2025-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%B0%88/" itemprop="url" rel="index"><span itemprop="name">杂谈</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="2025-05-25"><a href="#2025-05-25" class="headerlink" title="2025&#x2F;05&#x2F;25"></a>2025&#x2F;05&#x2F;25</h4><p>在抽象作息和魂游新档的重围下打赢复活赛了…</p>
<p>还得对着学术垃圾准备答辩，感觉得重头学学</p>
<p>答辩日期 05&#x2F;30 早上9：00，这两天害得编编项目</p>
<h4 id="2025-04-10"><a href="#2025-04-10" class="headerlink" title="2025&#x2F;04&#x2F;10"></a>2025&#x2F;04&#x2F;10</h4><p>昨天回学校签了保底，现在等海康那边泡池子能不能泡出来了…</p>
<p>今明两天不出意外应该就是最后两场笔试了，剩下的时间就专心搞毕设和学习了…大概</p>
<p>（不知道是不是前几天了流感生病耍久了…有点学不进去了<br><img src="/2025/03/28/2025-03-28-日程记录（杂谈-碎碎念说是/吐槽.jpg"  alt="吐槽" style="zoom:50%;" /></p>
<h4 id="2025-04-04"><a href="#2025-04-04" class="headerlink" title="2025&#x2F;04&#x2F;04"></a>2025&#x2F;04&#x2F;04</h4><p>昨天神州信息OC了，但是白菜价…</p>
<h4 id="2025-04-03"><a href="#2025-04-03" class="headerlink" title="2025&#x2F;04&#x2F;03"></a>2025&#x2F;04&#x2F;03</h4><p>神州信息Java岗人才测评</p>
<p>海康二面，一周之内出结果</p>
<p>（吐槽：中科创达内部是不是很多个不互通的部门？…第三次做他们家笔试了</p>
<h4 id="2025-04-02"><a href="#2025-04-02" class="headerlink" title="2025&#x2F;04&#x2F;02"></a>2025&#x2F;04&#x2F;02</h4><p>上午十点左右通知海康面试一面过了，明天上午十点过二面</p>
<p>整理一下思路<br>（准备海康威视的测试岗二面，</p>
<p>邮件信息表明此轮为通用素质面试，<br>牛客网上的信息普遍反应此轮面试不考察技术问题，但之前的一面也同样考察较少，且牛客网上最早的信息为去年秋招的情况；<br>那么技术问题可能在这一轮中被加入，或者还有三面，为避免二面问到技术问题的情况，同样需要做好准备测试岗技术面的准备</p>
<p>总结一下：需要准备的内容有</p>
<ol>
<li>可能需要作再作一次自我介绍</li>
<li>通用素质面试通常会问到的问题（包括优缺点表述，期望薪资，为什么选择测试而非开发<br>优缺点在一面时回答分别为适应能力较强，渴望在新环境中学习和成长（Tips：反思是否会被认为不稳定<br>  和自驱力不足，现在通过每天写博客的方式有所改善<br>  问到期望薪资时先确认base地点是否与一面确认的一样为杭州，再问薪资构成（10-12K<br>  选择测试回答往认为测试和开发不分家，自己在之前的实习经历中通过文档的编写和项目的稽核对测试产生兴趣</li>
<li>以及测试岗常问的技术八股</li>
</ol>
<p>根据网上的信息，海康泡池子的流程应该蛮长的…稳住心态吧</p>
<h4 id="2025-03-29"><a href="#2025-03-29" class="headerlink" title="2025&#x2F;03&#x2F;29"></a>2025&#x2F;03&#x2F;29</h4><p>深信服的面经整理得头晕，下午还接到个培训班的诈骗电话</p>
<p>电信17的笔试记成晚上七点了…投的区县后端岗，搜了一圈应该是没有下一轮笔试的机会了<br>区县大概率还得轮岗卖卡…欸，错过了就不去吧</p>
<p>今天感觉还是没找回学习的状态…空投简历和看各自信息陷入内耗和焦虑中了</p>
<p>希望明天能找回状态推进度吧，把B站也禁了算了…</p>
<h4 id="2025-03-28"><a href="#2025-03-28" class="headerlink" title="2025&#x2F;03&#x2F;28"></a>2025&#x2F;03&#x2F;28</h4><p>昨天的神州信息Java和海康威视测试岗都没怎么考八股反而在问抗压<br>感觉答得都还行，有hc的话应该都能进二面</p>
<p>目前手上笔试完了有一段时间，在等面试的就深信服和传音控股的Java岗</p>
<p>中科创达题和星辉游戏的Java岗题太简单了感觉是被充KPI了</p>
<p>oppo运维岗感觉笔试能过，等流程跟进</p>
<p>招银网络题做得还可以，基本上ac了，不过感觉要在下一轮因为简历被筛掉（双非说是…</p>
<p>现在手上还有中国电信和科大讯飞的Java岗笔试题没做</p>
<p>打算突击下深信服面试…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/25/2025-03-25-%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/25/2025-03-25-%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9/" class="post-title-link" itemprop="url">2025-03-25-面试杂项</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-25 12:53:04" itemprop="dateCreated datePublished" datetime="2025-03-25T12:53:04+08:00">2025-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-03 13:36:05" itemprop="dateModified" datetime="2025-04-03T13:36:05+08:00">2025-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>记录2025春招的面试为主…如果能记得的话</p>
<h4 id="2025-03-27-神州信息-Java"><a href="#2025-03-27-神州信息-Java" class="headerlink" title="2025&#x2F;03&#x2F;27 神州信息 Java"></a>2025&#x2F;03&#x2F;27 神州信息 Java</h4><p><strong>面试日期：2025年03月27日 周四	面试时间：14:30	面试方式：视频面试</strong></p>
<p>hr+技术面试官两人，约10min，自我介绍完了过后围绕项目和经历简单问了一下，没问八股…全程追问抗压能力、对加班的看法和是否接受出差，答了更愿意接受长时间低频率的出差，base上海期望薪资要了9-11K<br><img src="/2025/03/25/2025-03-25-面试杂项/QQ图片20250320170904.jpg"  alt="QQ图片20250320170904" style="zoom:33%;" /></p>
<p>感觉还有二面…</p>
<p><strong>2025&#x2F;04&#x2F;03上午发邮件做人才测评</strong></p>
<p>人才测评：</p>
<h4 id="2025-03-27-海康威视-测试工程师"><a href="#2025-03-27-海康威视-测试工程师" class="headerlink" title="2025&#x2F;03&#x2F;27 海康威视 测试工程师"></a>2025&#x2F;03&#x2F;27 海康威视 测试工程师</h4><p><strong>一面</strong>：<br>**面试时间：2025-03-27 16:25:00 ~ 17:00:00	**<br><strong>面试方式：牛客平台-视频面试</strong> </p>
<p><strong>二面</strong><br><strong>面试时间：2025-04-03 10:30:00 ~ 2025-04-03 11:15:00</strong><br>**面试方式：**萤石平台-视频面试</p>
<p><strong>一面</strong>：约15min，hr面，感觉也是偏向性格综合面，没八股，就问了下对加班的看法和是否接受工作性质的倒班</p>
<p>开放问题 问了怎么测试公司使用的圆珠笔？</p>
<p>base杭州</p>
<p>感觉一面整个过程答得没什么问题，看有没有二面了…</p>
<p><strong>二面</strong>：一周左右出结果，没消息就不用等了…大概</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/22/2025-03-22-KMP%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/22/2025-03-22-KMP%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">2025-03-22-KMP算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-22 18:54:02" itemprop="dateCreated datePublished" datetime="2025-03-22T18:54:02+08:00">2025-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-23 13:36:08" itemprop="dateModified" datetime="2025-03-23T13:36:08+08:00">2025-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇本来应该放在字符串那一章里面的，不过个人感觉KMP算法比较难懂，就单独列出来了…</p>
<h4 id="KMP算法-解决字符串匹配问题"><a href="#KMP算法-解决字符串匹配问题" class="headerlink" title="KMP算法(解决字符串匹配问题)"></a>KMP算法(解决字符串匹配问题)</h4><p>经典问题：文本串<code>aabaabaaf</code>中是否存在模式串<code>aabaaf</code></p>
<p>常规思路：暴力解法，两层for循环先文本串后模式串挨个匹配，时间复杂度O(m*n)</p>
<p><strong>KMP算法</strong>：时间复杂度 <strong>O(m*n)</strong>	—&gt;	<strong>O(m+n)</strong></p>
<p>核心思想：遇见冲突时向前回退</p>
<p><strong>通过前缀表来决定冲突时文本串需要跳转的位置</strong></p>
<img src="/2025/03/22/2025-03-22-KMP算法/screenshot_2025_03_23T11_54_45+0800.png"  alt="screenshot_2025_03_23T11_54_45+0800" style="zoom: 50%;" />

<h4 id="求前缀表"><a href="#求前缀表" class="headerlink" title="求前缀表"></a><strong>求前缀表</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i)) </span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(j) == s.charAt(i)) </span><br><span class="line">            j++;</span><br><span class="line">        next[i] = j; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h5 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28.实现 strStr()"></a>28.实现 strStr()</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/</a></p>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D;  10<sup>4</sup></li>
<li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<h5 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/description/">https://leetcode.cn/problems/repeated-substring-pattern/description/</a></p>
<p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;aba&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcabcabc&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 10<sup>4</sup></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/21/2025-03-21-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97part01-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97part02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/21/2025-03-21-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97part01-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97part02/" class="post-title-link" itemprop="url">2025-03-21-第五章-栈与队列part01-栈与队列part02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-21 13:53:57" itemprop="dateCreated datePublished" datetime="2025-03-21T13:53:57+08:00">2025-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-01 19:13:42" itemprop="dateModified" datetime="2025-04-01T19:13:42+08:00">2025-04-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"> 代码随想录栈与队列理论基础</a></p>
<h3 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a>今日任务</h3><p>part01：理论基础 、 232.用栈实现队列 、225. 用队列实现栈 、 20. 有效的括号 、1047. 删除字符串中的所有相邻重复项 </p>
<p>part02：150. 逆波兰表达式求值 、239. 滑动窗口最大值 、前 K 个高频元素 、总结</p>
<h2 id="第五章栈与队列part01"><a href="#第五章栈与队列part01" class="headerlink" title="第五章栈与队列part01"></a>第五章栈与队列part01</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>栈是先进后出，队列是先进先出。如图所示：<br><img src="/2025/03/21/2025-03-21-第五章-栈与队列part01-栈与队列part02/20210104235346563.png"  alt="栈与队列理论1" style="zoom:50%;" /></p>
<h4 id="Java中的栈与队列"><a href="#Java中的栈与队列" class="headerlink" title="Java中的栈与队列"></a><strong>Java中的栈与队列</strong></h4><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h4><ul>
<li><strong>标准栈操作</strong>：<ul>
<li><strong>压栈（Push）</strong>：将元素添加到栈顶</li>
<li><strong>弹栈（Pop）</strong>：移除并返回栈顶元素</li>
<li><strong>查看栈顶元素（Peek）</strong>：获取栈顶元素但不移除</li>
<li><strong>获取栈的大小（size）</strong>：返回栈中元素的数量</li>
<li><strong>检查栈是否为空（isEmpty）</strong>：判断栈中是否有元素</li>
</ul>
</li>
</ul>
<p>在Java中，<code>java.util.Stack</code>类提供了栈的基本功能。<br>然而，由于<code>Stack</code>类继承自<code>Vector</code>，它是同步的，在某些情况下可能导致性能开销。<br>因此，官方建议使用<code>Deque</code>接口及其实现类来替代<code>Stack</code>类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="comment">//使用Deque接口实现栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DequeStackExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个Deque实例作为栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 压栈操作</span></span><br><span class="line">        stack.push(<span class="number">10</span>);</span><br><span class="line">        stack.push(<span class="number">20</span>);</span><br><span class="line">        stack.push(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 查看栈顶元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;栈顶元素: &quot;</span> + stack.peek()); <span class="comment">// 输出: 30</span></span><br><span class="line">        <span class="comment">// 检查栈是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;栈是否为空: &quot;</span> + stack.isEmpty()); <span class="comment">// 输出: false</span></span><br><span class="line">        <span class="comment">// 获取栈的大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;栈的大小: &quot;</span> + stack.size()); <span class="comment">// 输出: 3</span></span><br><span class="line">        <span class="comment">// 弹栈操作</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;弹出: &quot;</span> + stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次检查栈是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;栈是否为空: &quot;</span> + stack.isEmpty()); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a><strong>队列</strong></h4><ul>
<li><p><strong>队列的基本操作</strong></p>
<ul>
<li><strong>从队尾插入元素（push to back）</strong></li>
<li><strong>从队首查看或移除元素（peek&#x2F;pop from front）</strong></li>
<li><strong>获取队列大小（size）</strong></li>
<li><strong>检查队列是否为空（is empty）</strong></li>
</ul>
</li>
<li><p><strong><code>Queue</code> 接口：</strong></p>
<ul>
<li><code>Queue</code> 接口继承自 <code>Collection</code>，表示一种<strong>先进先出</strong>（FIFO）的数据结构，元素按照插入顺序进行处理。<br>  仅支持在队尾插入元素、在队首移除元素，严格遵循 FIFO 原则。</li>
<li><strong>常用实现类：</strong><ul>
<li><strong><code>LinkedList</code>：</strong> 基于双向链表实现，适合需要频繁插入和删除操作的场景。</li>
<li><strong><code>PriorityQueue</code>：</strong> 基于堆结构实现的优先级队列，元素按照自然顺序或提供的比较器顺序进行排序。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>Deque</code> 接口：</strong></p>
<ul>
<li><code>Deque</code>（双端队列）接口继承自 <code>Queue</code>，允许在队列的两端进行插入和删除操作，既可以作为队列（FIFO）使用，也可以作为栈（LIFO）使用。<br>  支持在队首和队尾两端进行插入和删除操作，功能更为灵活</li>
<li><strong>常用实现类：</strong><ul>
<li><strong><code>ArrayDeque</code>：</strong> <strong>基于可变数组</strong>实现，提供高效的元素访问和操作，适合需要快速随机访问的场景。</li>
<li><strong><code>LinkedList</code>：</strong> 同样实现了 <code>Deque</code> 接口，<strong>基于双向链表</strong>，适合需要频繁在两端进行插入和删除操作的场景。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="comment">//使用Queue接口实现队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个Queue实例</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入队操作</span></span><br><span class="line">        queue.offer(<span class="number">10</span>);</span><br><span class="line">        queue.offer(<span class="number">20</span>);</span><br><span class="line">        queue.offer(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 查看队首元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;队首元素: &quot;</span> + queue.peek()); <span class="comment">// 输出: 10</span></span><br><span class="line">        <span class="comment">// 获取队列大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;队列大小: &quot;</span> + queue.size()); <span class="comment">// 输出: 3</span></span><br><span class="line">        <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;队列是否为空: &quot;</span> + queue.isEmpty()); <span class="comment">// 输出: false</span></span><br><span class="line">        <span class="comment">// 出队操作</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出队: &quot;</span> + queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次检查队列是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;队列是否为空: &quot;</span> + queue.isEmpty()); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="comment">//使用Deque接口实现队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DequeQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个Deque实例</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 从队尾入队</span></span><br><span class="line">        deque.offerLast(<span class="number">10</span>);</span><br><span class="line">        deque.offerLast(<span class="number">20</span>);</span><br><span class="line">        deque.offerLast(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 查看队首元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;队首元素: &quot;</span> + deque.peekFirst()); <span class="comment">// 输出: 10</span></span><br><span class="line">        <span class="comment">// 获取队列大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;队列大小: &quot;</span> + deque.size()); <span class="comment">// 输出: 3</span></span><br><span class="line">        <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;队列是否为空: &quot;</span> + deque.isEmpty()); <span class="comment">// 输出: false</span></span><br><span class="line">        <span class="comment">// 从队首出队</span></span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出队: &quot;</span> + deque.pollFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次检查队列是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;队列是否为空: &quot;</span> + deque.isEmpty()); <span class="comment">// 输出: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="理论基础（思考"><a href="#理论基础（思考" class="headerlink" title="理论基础（思考"></a>理论基础（思考</h4><p>在 Java 中，栈（Stack）和队列（Queue）是两种常用的数据结构，分别遵循后进先出（LIFO）和先进先出（FIFO）的原则。</p>
<p><strong>1. Java 中的 Stack 是容器吗？</strong></p>
<p>Java 中的 <code>Stack</code> 类是一个容器。它继承自 <code>Vector</code> 类，属于 Java 集合框架中的一部分，用于存储和管理对象的集合。<br>然而，由于 <code>Stack</code> 继承自 <code>Vector</code>，它继承了 <code>Vector</code> 的所有方法，包括一些与栈操作无关的方法，这可能导致不必要的方法暴露。<br>因此，在现代 Java 开发中，通常建议使用 <code>Deque</code> 接口及其实现类（如 <code>ArrayDeque</code>）来替代 <code>Stack</code> 类，以获得更清晰和高效的栈操作。 </p>
<p><strong>2. Stack 提供迭代器来遍历栈空间吗？</strong></p>
<p>是的，<code>Stack</code> 类提供了迭代器（通过实现 <code>Iterable</code> 接口），允许使用迭代器或增强型 <code>for</code> 循环遍历栈中的元素。<br>然而，需要注意的是，使用迭代器遍历 <code>Stack</code> 时，元素的遍历顺序是从栈底到栈顶，这与 <code>pop</code> 方法的弹出顺序（从栈顶到栈底）相反。<br>因此，在需要按照栈的 LIFO 顺序处理元素时，建议使用 <code>pop</code> 方法而非迭代器进行遍历。 </p>
<h5 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：<br>	<code>void push(int x)</code> 将元素 x 推到队列的末尾<br>	<code>int pop()</code> 从队列的开头移除并返回元素<br>	<code>int peek()</code> 返回队列开头的元素<br>	<code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></p>
<p><strong>说明：</strong></p>
<ul>
<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= x &lt;= 9</code></p>
</li>
<li><p>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></p>
</li>
<li><p>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</p>
</li>
<li><p>使用输入输出两个栈实现</p>
<ul>
<li>push操作将元素压入输入栈即可</li>
<li>pop&#x2F;peek操作时<ul>
<li>先判断输出栈是否为空<ul>
<li>不为空则直接返回操作输出栈栈顶元素（输入栈栈底对应输出栈栈顶</li>
<li>为空则通过while循环将输入栈元素从栈顶开始依次压入输出栈中，再操作输出栈栈顶元素</li>
</ul>
</li>
</ul>
</li>
<li>empty操作同时判断输入输出栈是否均不为空</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue_232</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue_232</span><span class="params">()</span>&#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpStackIn();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpStackIn();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果stackOut为空，则将stackIn中的元素全部放到stackOut中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpStackIn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stackOut.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stackIn.isEmpty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/description/">https://leetcode.cn/problems/implement-stack-using-queues/description/</a></p>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>
<p>实现 <code>MyStack</code> 类：<br>	<code>void push(int x)</code> 将元素 x 压入栈顶。<br>	<code>int pop()</code> 移除并返回栈顶元素。<br>	<code>int top()</code> 返回栈顶元素。<br>	<code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li>
<li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack_225</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack_225</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queue.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用一个单向队列解决：循环队列<ul>
<li>每次push操作后依次将入队元素前的所有元素出队，再入队<br>（注意循环次数为 push 后的 size-1</li>
</ul>
</li>
</ul>
<h5 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p>
<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：<br>1.左括号必须用相同类型的右括号闭合。<br>2.左括号必须以正确的顺序闭合。<br>3.每个右括号都有一个对应的相同类型的左括号。</p>
<p><strong>示例 1：</strong> 	**输入：**s &#x3D; “()” 	**输出：**true</p>
<p><strong>示例 2：</strong> 	**输入：**s &#x3D; “()[]{}” 	**输出：**true</p>
<p><strong>示例 3：</strong> 	**输入：**s &#x3D; “(]” 	**输出：**false</p>
<p><strong>示例 4：</strong> 	**输入：**s &#x3D; “([])” 	**输出：**true</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution_20</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(deque.isEmpty()||deque.peek()!=ch)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==deque.peek()) &#123;</span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用栈模拟不匹配的情况<ul>
<li>左括号多余：遍历完后栈不为空</li>
<li>括号类型不匹配：遍历位置元素不为左括号且<code>ch != deque.peek()</code></li>
<li>右括号多余：遍历过程中栈为空</li>
</ul>
</li>
</ul>
<h5 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/</a></p>
<p>给出由小写字母组成的字符串 <code>s</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。<br>在 <code>s</code> 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 10<sup>5</sup></li>
<li><code>s</code> 仅由小写英文字母组成。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution_1047</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] newChars = <span class="keyword">new</span> <span class="title class_">char</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newChars.length; i++) &#123;</span><br><span class="line">            newChars[newChars.length-<span class="number">1</span>-i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(newChars);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>思路与上一道题基本一致…不过在给字符数组倒序赋值时索引使用<code>stack.size()-1-i</code>会报错<ul>
<li>出栈时<code>stack.size()</code>动态变化，造成数组下标越界的问题</li>
</ul>
</li>
</ul>
<h2 id="第五章栈与队列part02"><a href="#第五章栈与队列part02" class="headerlink" title="第五章栈与队列part02"></a>第五章栈与队列part02</h2><h5 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/</a></p>
<p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 104</code></li>
<li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>
</ul>
<p><strong>逆波兰表达式：</strong></p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution_150</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt;  stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">                stack.push(stack.pop()+stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">                stack.push(-stack.pop()+stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">                stack.push(stack.pop()*stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(n/m);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//stack.push(tokens[i]);</span></span><br><span class="line">                stack.push(Integer.parseInt(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>理解题意即可</p>
</li>
<li><p><strong>不熟悉定义栈中的变量类型转化</strong></p>
</li>
<li><p>这道题leetcode 内置的jdk不能使用&#x3D;&#x3D;判断字符串是否相等</p>
</li>
</ul>
<h5 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/description/">https://leetcode.cn/problems/sliding-window-maximum/description/</a></p>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<sup>5</sup></p>
</li>
<li><p>-10<sup>4</sup> &lt;&#x3D; nums[i] &lt;&#x3D; 10<sup>4</sup></p>
</li>
<li><p>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p>
</li>
<li><p>暴力解法，遍历过程中每次从窗口中找到最大的数值—&gt;<strong>O(n*k)</strong></p>
</li>
<li><p>使用单调队列（自定义队列）—&gt;<strong>O(n)</strong></p>
<ul>
<li>每次窗口移动的时候，<ul>
<li>调用<code>que.pop</code>(滑动窗口中移除元素的数值)，</li>
<li><code>que.push</code>(滑动窗口添加元素的数值)，</li>
<li>然后<code>que.front()</code>就返回我们要的最大值<ul>
<li>弹出最大值：只维护<strong>有可能成为窗口里最大值的元素</strong><ul>
<li>入队时元素值大于出口数值，则弹出前面的所有元素</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/description/">https://leetcode.cn/problems/top-k-frequent-elements/description/</a></p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<sup>5</sup></li>
<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>
<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/19/2025-03-19-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2part01-%E5%AD%97%E7%AC%A6%E4%B8%B2part02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/19/2025-03-19-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2part01-%E5%AD%97%E7%AC%A6%E4%B8%B2part02/" class="post-title-link" itemprop="url">2025-03-20-第四章-字符串part01-字符串part02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-19 16:10:04" itemprop="dateCreated datePublished" datetime="2025-03-19T16:10:04+08:00">2025-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-23 11:40:39" itemprop="dateModified" datetime="2025-03-23T11:40:39+08:00">2025-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a><strong>今日任务</strong></h3><p>part01： 344.反转字符串、 541. 反转字符串II、卡码网：54.替换数字</p>
<p>part02：151.翻转字符串里的单词、卡码网：55.右旋转字符串、 28. 实现 strStr()、<br>               459.重复的子字符串、字符串总结 、 双指针回顾 </p>
<h3 id="第四章字符串part01"><a href="#第四章字符串part01" class="headerlink" title="第四章字符串part01"></a>第四章字符串part01</h3><p>算法思想与数组大致相同</p>
<p>可将输入字符串转为字符数组处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"><span class="type">char</span>[] arr = input.toCharArray();</span><br></pre></td></tr></table></figure>



<h5 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/description/">https://leetcode.cn/problems/reverse-string/description/</a></p>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。<br>不要给另外的数组分配额外的空间，你必须**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 10<sup>5</sup></li>
<li><code>s[i]</code> 都是 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li>
</ul>
<p>将输入字符串转为字符数组，在原地作处理—&gt;定义左右指针，交换首尾字符，同时向中间移动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541.反转字符串II"></a>541.反转字符串II</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">https://leetcode.cn/problems/reverse-string-ii/</a></p>
<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>
<ul>
<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, k = 2</span><br><span class="line">输出：&quot;bacd&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 10<sup>4</sup></li>
<li><code>s</code> 仅由小写英文组成</li>
<li>1 &lt;&#x3D; k &lt;&#x3D; 10<sup>4</sup></li>
</ul>
<p>和上一道题基本一样，逻辑&#x2F;判断条件 复杂一点，不涉及新的算法思想</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length / k / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> index + k - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                arr[right] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            index += <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">otherNum</span> <span class="operator">=</span> arr.length - index;</span><br><span class="line">            <span class="keyword">if</span> (otherNum &gt; <span class="number">0</span> &amp;&amp; otherNum &lt; k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">                    arr[left] = arr[right];</span><br><span class="line">                    arr[right] = temp;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (otherNum &gt;= k &amp;&amp; otherNum &lt; <span class="number">2</span> * k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> index + k - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">                    arr[left] = arr[right];</span><br><span class="line">                    arr[right] = temp;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>简洁写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length - <span class="number">1</span>,start + k - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">                ch[start] = ch[end];</span><br><span class="line">                ch[end] = temp;</span><br><span class="line"></span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h5 id="卡码网：54-替换数字"><a href="#卡码网：54-替换数字" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h5><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1064">https://kamacoder.com/problempage.php?pid=1064</a></p>
<p>给定一个字符串 s，它包含小写字母和数字字符，<br>请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。<br>例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： 输入一个字符串 s,s 仅包含小写字母和数字字符。     </span><br><span class="line">输出： 输入一个字符串 s,s 仅包含小写字母和数字字符。     </span><br></pre></td></tr></table></figure>

<p><strong>示例 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a1b2c3</span><br><span class="line">输出：anumberbnumbercnumber  </span><br></pre></td></tr></table></figure>

<p><strong>提示信息：</strong></p>
<ul>
<li>数据范围：1 &lt;&#x3D; s.length &lt; 10000。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SolutionKm1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计数字的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sOldSize</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充字符串s的大小，也就是每个空格替换成&quot;number&quot;之后的大小</span></span><br><span class="line">        <span class="type">char</span>[] newS = <span class="keyword">new</span> <span class="title class_">char</span>[s.length() + count * <span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sNewSize</span> <span class="operator">=</span> newS.length;</span><br><span class="line">        <span class="comment">// 将旧字符串的内容填入新数组</span></span><br><span class="line">        System.arraycopy(s.toCharArray(), <span class="number">0</span>, newS, <span class="number">0</span>, sOldSize);</span><br><span class="line">        <span class="comment">// 从后先前将空格替换为&quot;number&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; j--, i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(newS[j])) &#123;</span><br><span class="line">                newS[i] = newS[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newS[i] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                newS[i - <span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">                newS[i - <span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                newS[i - <span class="number">3</span>] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                newS[i - <span class="number">4</span>] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">                newS[i - <span class="number">5</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">                i -= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(newS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="第四章字符串part02"><a href="#第四章字符串part02" class="headerlink" title="第四章字符串part02"></a>第四章字符串part02</h3><h5 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">https://leetcode.cn/problems/reverse-words-in-a-string/description/</a></p>
<p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。<br><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p>**注意：**输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; <code>s.length</code> &lt;&#x3D; 10<sup>4</sup></li>
<li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li>
<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>
</ul>
<p>空间复杂度O(1)，不使用库函数</p>
<p>先移除空格	—&gt;	快慢指针移除，时间复杂度O(n)</p>
<p>再整个反转字符串</p>
<p>最后逐个反转单词</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution151</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.去除首尾以及中间多余空格</span></span><br><span class="line">        chars = removeSpace(chars);</span><br><span class="line">        <span class="comment">// 2.反转整个字符串</span></span><br><span class="line">        reverse(chars,<span class="number">0</span>,chars.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.反转各个单词</span></span><br><span class="line">        reverseEachWord(chars);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针去除多余空格</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] removeSpace(<span class="type">char</span>[] chars) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; chars.length; fast++) &#123;</span><br><span class="line">            <span class="comment">//先用 fast 移除所有空格</span></span><br><span class="line">            <span class="keyword">if</span> (chars[fast] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//在用 slow 加空格。 除第一个单词外，单词末尾要加空格</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>)</span><br><span class="line">                    chars[slow++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="comment">//fast 遇到空格或遍历到字符串末尾，就证明遍历完一个单词了</span></span><br><span class="line">                <span class="keyword">while</span> (fast &lt; chars.length &amp;&amp; chars[fast] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                    chars[slow++] = chars[fast++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相当于 c++ 里的 resize()</span></span><br><span class="line">        <span class="type">char</span>[] newChars = <span class="keyword">new</span> <span class="title class_">char</span>[slow];</span><br><span class="line">        System.arraycopy(chars, <span class="number">0</span>, newChars, <span class="number">0</span>, slow);</span><br><span class="line">        <span class="keyword">return</span> newChars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转整个字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right &gt;= chars.length) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;set a wrong right&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            chars[left] ^= chars[right];</span><br><span class="line">            chars[right] ^= chars[left];</span><br><span class="line">            chars[left] ^= chars[right];</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.单词反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//end &lt;= s.length() 这里的 = ，是为了让 end 永远指向单词末尾后一个位置，这样 reverse 的实参更好设置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt;= chars.length; end++) &#123;</span><br><span class="line">            <span class="comment">// end 每次到单词末尾后的空格或串尾,开始反转单词</span></span><br><span class="line">            <span class="keyword">if</span> (end == chars.length || chars[end] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                reverse(chars, start, end - <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>- </p>
<h5 id="卡码网：55-右旋转字符串"><a href="#卡码网：55-右旋转字符串" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h5><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1065">https://kamacoder.com/problempage.php?pid=1065</a></p>
<p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。<br>给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 </p>
<p>输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串</p>
<p>输出共一行，为进行了右旋转操作后的字符串。                                </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： 输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。</span><br><span class="line"><span class="code">				第二行为字符串 s，代表需要旋转的字符串  </span></span><br><span class="line"><span class="code">输出： 输入一个字符串 s,s仅包含小写字母和数字字符。     </span></span><br></pre></td></tr></table></figure>

<p><strong>示例 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">	 abcdefg</span><br><span class="line">输出：fgabcde</span><br></pre></td></tr></table></figure>

<p><strong>提示信息：</strong></p>
<ul>
<li>数据范围：1 &lt;&#x3D; k &lt; 10000,<br>               1 &lt;&#x3D; s.length &lt; 10000;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>







<h4 id="KMP算法-解决字符串匹配问题"><a href="#KMP算法-解决字符串匹配问题" class="headerlink" title="KMP算法(解决字符串匹配问题)"></a>KMP算法(解决字符串匹配问题)</h4><p><a href="https://souls5.github.io/2025/03/22/2025-03-22-KMP%E7%AE%97%E6%B3%95/"><strong>KMP概述</strong>、<strong>28.实现 strStr()</strong>、<strong>459.重复的子字符串</strong>移步至专门总结的KMP算法笔记</a></p>
<p>经典问题：文本串<code>aabaabaaf</code>中是否存在模式串<code>aabaaf</code></p>
<p>常规思路：暴力解法，两层for循环先文本串后模式串挨个匹配，时间复杂度O(m*n)</p>
<p><strong>KMP算法</strong>：时间复杂度 <strong>O(m*n)</strong>	—&gt;	<strong>O(m+n)</strong></p>
<h5 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28.实现 strStr()"></a>28.实现 strStr()</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/</a></p>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D;  10<sup>4</sup></li>
<li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>
</ul>
<h5 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/description/">https://leetcode.cn/problems/repeated-substring-pattern/description/</a></p>
<p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;aba&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcabcabc&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 10<sup>4</sup></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h3 id="字符串总结"><a href="#字符串总结" class="headerlink" title="字符串总结"></a>字符串总结</h3><h3 id="双指针回顾"><a href="#双指针回顾" class="headerlink" title="双指针回顾"></a>双指针回顾</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/15/2025-03-15-%E7%AC%94%E8%AF%95%E6%9D%82%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/15/2025-03-15-%E7%AC%94%E8%AF%95%E6%9D%82%E9%A1%B9/" class="post-title-link" itemprop="url">2025-03-15-笔试杂项</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-15 19:21:41" itemprop="dateCreated datePublished" datetime="2025-03-15T19:21:41+08:00">2025-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-10 22:29:56" itemprop="dateModified" datetime="2025-04-10T22:29:56+08:00">2025-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">笔试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>记录2025春招遇到的笔试算法题为主（如果能找到的话…</p>
<h4 id="2025-03-15美团测开"><a href="#2025-03-15美团测开" class="headerlink" title="2025&#x2F;03&#x2F;15美团测开"></a>2025&#x2F;03&#x2F;15美团测开</h4><p>填空2*20，算法20+15+25</p>
<p>算法三道分别是字符串处理，加解密和fab</p>
<p>（找到题了再更新…</p>
<p>一、对 快递单号 进行分类，依据不同的格式规则来判断属于哪种类型，若不符合任何规则则判定为 “Invalid”</p>
<p>二、对一个由大小写字母组成的加密字符串 <code>s</code> 进行处理，规则如下：</p>
<ol>
<li><p>初始 解密字符串 <code>t</code> 为空。</p>
</li>
<li><p>遍历 <code>s</code> 的每个字符</p>
<ul>
<li><p><code>&#39;R&#39;</code>：将 <code>t</code> 反转。</p>
</li>
<li><p><code>&#39;Z&#39;</code></p>
<p>：撤销上一步操作：</p>
<ul>
<li>如果上一步是 <code>&#39;R&#39;</code>，撤销反转。</li>
<li>如果上一步是普通字符，删除该字符。</li>
<li>如果 <code>t</code> 为空，则忽略 <code>&#39;Z&#39;</code> 操作。</li>
</ul>
</li>
<li><p>其他普通字符追加到 <code>t</code> 末尾。</p>
</li>
</ul>
</li>
</ol>
<p>三、给定一个函数 <code>f(a, b)</code>：</p>
<ul>
<li>若 <code>a</code> 是 <code>b</code> 的倍数，则 <code>f(a, b) = 1</code></li>
<li>否则 <code>f(a, b) = 0</code></li>
</ul>
<p>目标是计算：<img src="/2025/03/15/2025-03-15-笔试杂项/firefox_O70BIMML10.png"  alt="firefox_O70BIMML10" style="zoom:50%;" /></p>
<p>即，遍历所有 <code>(i, j)</code> 组合，<strong>统计 <code>i</code> 是 <code>j</code> 倍数的数量</strong>。</p>
<p>(主要是时间复杂度不太好压…</p>
<h4 id="2025-03-16-美团后端"><a href="#2025-03-16-美团后端" class="headerlink" title="2025&#x2F;03&#x2F;16 美团后端"></a>2025&#x2F;03&#x2F;16 美团后端</h4><p>填空3 * 20，算法2 * 20</p>
<p>第一道大概是这样<br><img src="/2025/03/15/2025-03-15-笔试杂项/6afde5f2406f53a1d49848691fb6deb.png"  alt="6afde5f2406f53a1d49848691fb6deb" style="zoom:60%;" /></p>
<p>应该是哈希，我猜重复一定次数过后就开始循环了，输出循环数组就行了（但是改烦了…<img src="/2025/03/15/2025-03-15-笔试杂项/QQ图片20250316173524.jpg"  alt="QQ图片20250316173524" style="zoom: 67%;" /></p>
<p>第二道题没怎么看…</p>
<h4 id="2025-03-16-深信服Java"><a href="#2025-03-16-深信服Java" class="headerlink" title="2025&#x2F;03&#x2F;16 深信服Java"></a>2025&#x2F;03&#x2F;16 深信服Java</h4><p>填空3*24 算法四道题一共58分</p>
<p>填空逻辑题和二叉树耽误时间有点多，算法前三道ac，最后一道读懂题目用掉的时间有长没来得及做…</p>
<p><strong>一、计算字符串中不同字符的个数</strong></p>
<p>只输出个数，使用哈希法即可</p>
<p><strong>二、字符串的全排列，要求输出所有可能的出栈顺序，</strong></p>
<p>模拟栈操作，可以使用<strong>回溯法 + 栈</strong>来生成所有可能的出栈顺序</p>
<p><strong>三、给定一个未排序的整数数组，要求找到最长的连续递减子序列的长度</strong></p>
<p>滑动窗口&#x2F;双指针 可解</p>
<p><strong>四、给定 n 个任务，每个任务有一个 执行时间，需要在这些任务中选取 k 个任务进行编辑（由两个人共同完成）。</strong><br><strong>目标是合理分配任务，使得两个人的最大工作时间尽可能小（即负载均衡）。</strong></p>
<p>二分 + 动态规划（前缀和）&#x2F;贪心 可解</p>
<p>（可惜速度慢了…</p>
<h4 id="2025-03-19神州信息Java开发"><a href="#2025-03-19神州信息Java开发" class="headerlink" title="2025&#x2F;03&#x2F;19神州信息Java开发"></a>2025&#x2F;03&#x2F;19神州信息Java开发</h4><p>选择2*35，算法第一道ac，第二道状态不好没做出来</p>
<h4 id="2025-03-20小天才-步步高Web后台"><a href="#2025-03-20小天才-步步高Web后台" class="headerlink" title="2025&#x2F;03&#x2F;20小天才&amp;步步高Web后台"></a>2025&#x2F;03&#x2F;20小天才&amp;步步高Web后台</h4><p>单选+多选+填空3道	常规八股</p>
<h4 id="2025-03-20海康威视测试"><a href="#2025-03-20海康威视测试" class="headerlink" title="2025&#x2F;03&#x2F;20海康威视测试"></a>2025&#x2F;03&#x2F;20海康威视测试</h4><p>单选、多选、问答两道看着像场景题、算法题第一道返回素数，第二道螺旋数组</p>
<p>不难，但是只能用python…这下拼尽全力无法回忆起了<br><img src="/2025/03/15/2025-03-15-笔试杂项/QQ图片20250320170904.jpg"  alt="QQ图片20250320170904" style="zoom:33%;" /></p>
<h4 id="2025-03-20中科创达Java"><a href="#2025-03-20中科创达Java" class="headerlink" title="2025&#x2F;03&#x2F;20中科创达Java"></a>2025&#x2F;03&#x2F;20中科创达Java</h4><p>单选+多选+判断 常规八股、外加5道意义不明的行测图推，一共45道题</p>
<h4 id="2025-03-22-360Web服务端开发"><a href="#2025-03-22-360Web服务端开发" class="headerlink" title="2025&#x2F;03&#x2F;22 360Web服务端开发"></a>2025&#x2F;03&#x2F;22 360Web服务端开发</h4><h4 id="2025-03-22-小米-运维开发-测试开发-？"><a href="#2025-03-22-小米-运维开发-测试开发-？" class="headerlink" title="2025&#x2F;03&#x2F;22 小米 运维开发&#x2F;测试开发 ？"></a>2025&#x2F;03&#x2F;22 小米 运维开发&#x2F;测试开发 ？</h4><p>算法题考的二叉树…不难但是不熟</p>
<h4 id="2025-03-24-招银网络-Java"><a href="#2025-03-24-招银网络-Java" class="headerlink" title="2025&#x2F;03&#x2F;24 招银网络 Java"></a>2025&#x2F;03&#x2F;24 招银网络 Java</h4><p>选择2*20 + 大题三道（两道填空一道算法）较简单</p>
<p>（感觉大概率要因为简历被筛掉</p>
<h4 id="2025-03-25-OPPO-IT开发工程师（运维方向）"><a href="#2025-03-25-OPPO-IT开发工程师（运维方向）" class="headerlink" title="2025&#x2F;03&#x2F;25 OPPO IT开发工程师（运维方向）"></a>2025&#x2F;03&#x2F;25 OPPO IT开发工程师（运维方向）</h4><p>三道算法题蛮简单的，ac了两道，中间那道暴力解法测试用例只过了25%<br>就考了双指针和哈希</p>
<h4 id="2025-03-28-星辉游戏-Java服务端开发工程师"><a href="#2025-03-28-星辉游戏-Java服务端开发工程师" class="headerlink" title="2025&#x2F;03&#x2F;28 星辉游戏 Java服务端开发工程师"></a>2025&#x2F;03&#x2F;28 星辉游戏 Java服务端开发工程师</h4><p><strong>线上笔试开放时间为：2025年3月25日-3月31日中午12:00；</strong></p>
<p>问卷星上完成的…很怪</p>
<h4 id="2025-03-29-中国电信重庆分公司"><a href="#2025-03-29-中国电信重庆分公司" class="headerlink" title="2025&#x2F;03&#x2F;29 中国电信重庆分公司"></a>2025&#x2F;03&#x2F;29 中国电信重庆分公司</h4><p>考试地址：通信类：北京时间03月29日（周六）16:00-17:00</p>
<p>记错考试时间</p>
<h4 id="2025-03-30-西山居游戏功能测试-国风武侠项目"><a href="#2025-03-30-西山居游戏功能测试-国风武侠项目" class="headerlink" title="2025&#x2F;03&#x2F;30 西山居游戏功能测试-国风武侠项目"></a>2025&#x2F;03&#x2F;30 西山居游戏功能测试-国风武侠项目</h4><p>2025-03-30 10:00:00-2025-03-30 13:00:00</p>
<p>…很诡异</p>
<p>算法题就考了一道，力扣上处理两个字符串使用KMP算法的原题，20分<br>但是有80分的问答题，其中接近一半在问游戏经历和个人兴趣爱好</p>
<h4 id="2025-03-30-科大讯飞-Java开发工程师"><a href="#2025-03-30-科大讯飞-Java开发工程师" class="headerlink" title="2025&#x2F;03&#x2F;30 科大讯飞 Java开发工程师"></a>2025&#x2F;03&#x2F;30 科大讯飞 Java开发工程师</h4><p>考试时间：(北京时间,UTC+08:00)2025-03-30 19:00:00 – 21:00:00</p>
<p>25道选择题和3道编程题</p>
<h4 id="2025-03-30-亚信安全-Java开发"><a href="#2025-03-30-亚信安全-Java开发" class="headerlink" title="2025&#x2F;03&#x2F;30 亚信安全  Java开发"></a>2025&#x2F;03&#x2F;30 亚信安全  Java开发</h4><p>考试开放时间：2025-03-30 19:00 至 2025-03-30 22:00  </p>
<p>时间冲突，等待顺延到下一次</p>
<h4 id="2024-04-03-深圳乐言u3d开发线上测试"><a href="#2024-04-03-深圳乐言u3d开发线上测试" class="headerlink" title="2024&#x2F;04&#x2F;03 深圳乐言u3d开发线上测试"></a>2024&#x2F;04&#x2F;03 深圳乐言u3d开发线上测试</h4><p>发了邮件，题目在加密的pdf中，15不定项选择 + 一道程序填空题</p>
<h4 id="2025-04-10-亚信安全-Java开发"><a href="#2025-04-10-亚信安全-Java开发" class="headerlink" title="2025&#x2F;04&#x2F;10 亚信安全  Java开发"></a>2025&#x2F;04&#x2F;10 亚信安全  Java开发</h4><p>考试开放时间：2025-04-10 19:00 至 2025-04-10 22:00  </p>
<h4 id="2025-04-11-掌阅科技-移动研发工程师"><a href="#2025-04-11-掌阅科技-移动研发工程师" class="headerlink" title="2025&#x2F;04&#x2F;11 掌阅科技 移动研发工程师"></a>2025&#x2F;04&#x2F;11 掌阅科技 移动研发工程师</h4><p>开始时间：2025-04-11 14:00<br>结束时间：2025-04-11 23:59</p>
<h4 id="2025-04-11-叠纸游戏-测试开发工程师"><a href="#2025-04-11-叠纸游戏-测试开发工程师" class="headerlink" title="2025&#x2F;04&#x2F;11 叠纸游戏 测试开发工程师"></a>2025&#x2F;04&#x2F;11 叠纸游戏 测试开发工程师</h4><p>开始时间：2025-04-11 19:00	结束时间：2025-04-11 20:30</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/13/2025-03-13-%E5%93%88%E5%B8%8C%E8%A1%A8part01%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8part02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/13/2025-03-13-%E5%93%88%E5%B8%8C%E8%A1%A8part01%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8part02/" class="post-title-link" itemprop="url">2025-03-13-第三章-哈希表part01—哈希表part02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-13 14:18:50" itemprop="dateCreated datePublished" datetime="2025-03-13T14:18:50+08:00">2025-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-20 12:44:18" itemprop="dateModified" datetime="2025-03-20T12:44:18+08:00">2025-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"> 代码随想哈希表理论基础</a></p>
<h3 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a><strong>今日任务</strong></h3><p>part01：哈希表理论基础、 242.有效的字母异位词 、 349. 两个数组的交集 、202. 快乐数 、 1. 两数之和 </p>
<p>part02：454.四数相加II 、383. 赎金信  、15. 三数之和 、 18. 四数之和  </p>
<h3 id="第三章-哈希表part01"><a href="#第三章-哈希表part01" class="headerlink" title="第三章 哈希表part01"></a>第三章 哈希表part01</h3><h4 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h4><h5 id="哈希表-Hash-table"><a href="#哈希表-Hash-table" class="headerlink" title="哈希表(Hash table)"></a><strong>哈希表(Hash table)</strong></h5><p>国内也有一些算法书籍翻译为散列表</p>
<blockquote>
<p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
</blockquote>
<p>简单来讲其实数组就是一张哈希表。<br>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：<br><img src="/2025/03/13/2025-03-13-哈希表part01—哈希表part02/20210104234805168.png"  alt="哈希表1" style="zoom: 50%;" /></p>
<p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p>
<p>例如要查询一个名字是否在这所学校里。<br>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。<br>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p>
<p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p>
<h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a><strong>哈希函数</strong></h5><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p>
<p>哈希函数如下图所示，<br>通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，<br>可以<strong>将其他数据格式转化为不同的数值</strong>，这样就把学生名字映射为哈希表上的索引数字了。<br><img src="/2025/03/13/2025-03-13-哈希表part01—哈希表part02/2021010423484818.png"  alt="哈希表2" style="zoom:50%;" /></p>
<ul>
<li>如果hashCode得到的<strong>数值大于哈希表的大小</strong>了，也就是大于tableSize了，怎么办呢？<ul>
<li>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个<strong>取模</strong>的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</li>
</ul>
</li>
</ul>
<p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。如果学生的数量大于哈希表的大小怎么办，<br>此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。此时需要用到<strong>哈希碰撞</strong></p>
<h5 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a><strong>哈希碰撞</strong></h5><p>如图所示，小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。<br><img src="/2025/03/13/2025-03-13-哈希表part01—哈希表part02/2021010423494884.png"  alt="哈希表3" style="zoom:50%;" /></p>
<p>一般哈希碰撞有两种解决方法， <strong>拉链法</strong>和<strong>线性探测法</strong>。</p>
<ul>
<li><p><strong>拉链法</strong><br>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。<br>这样我们就可以通过索引找到小李和小王了</p>
<img src="/2025/03/13/2025-03-13-哈希表part01—哈希表part02/20210104235015226.png"  alt="哈希表4" style="zoom: 50%;" />
（数据规模是dataSize， 哈希表的大小为tableSize）
拉链法要选择适当的哈希表的大小，
既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。
</li>
<li><p><strong>线性探测法</strong><br>使用线性探测法，一定要保证tableSize大于dataSize。<br>我们需要依靠哈希表中的空位来解决碰撞问题。</p>
<ul>
<li>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。</li>
<li>所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。<img src="/2025/03/13/2025-03-13-哈希表part01—哈希表part02/20210104235109950.png"  alt="哈希表5" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h5 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h5><p>当我们需要使用哈希法来解决问题时，通常会选择以下三种数据结构：</p>
<ul>
<li>数组</li>
<li>Set（集合）</li>
<li>Map（映射）</li>
</ul>
<p>在 Java 中，<code>HashSet</code> 和 <code>HashMap</code> 是最常用的实现，它们的底层实现和使用方式如下：</p>
<h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong><code>HashSet</code></strong></h6><p><code>HashSet</code> 是一个<strong>不允许有重复元素</strong>的<strong>集合</strong>，其底层通过 <code>HashMap</code> 实现。<br>每个被添加到 <code>HashSet</code> 的元素实际上作为 <code>HashMap</code> 的键（<code>key</code>）存储，而值（<code>value</code>）则是一个固定的常量对象。</p>
<p><code>HashSet</code> 的主要特性：</p>
<ul>
<li><strong>无序</strong>：元素没有特定的顺序。</li>
<li><strong>唯一性</strong>：不允许有重复元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码：</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 重复元素，不会被添加</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>&quot;Alice&quot;</code> 被添加了两次，但在 <code>HashSet</code> 中只会存储一个 <code>&quot;Alice&quot;</code>，因为 <code>HashSet</code> 不允许重复元素。</p>
<h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong><code>HashMap</code></strong></h6><p><code>HashMap</code> 是一个<strong>键值对（<code>key-value</code>）映射</strong>的数据结构，允许根据键快速查找对应的值。其主要特性包括：</p>
<ul>
<li><strong>无序</strong>：键值对没有特定的顺序。</li>
<li><strong>键的唯一性</strong>：每个键只能对应一个值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码：</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">28</span>); <span class="comment">// 键相同，后面的值会覆盖前面的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>&quot;Alice&quot;</code> 的年龄先被设置为 <code>30</code>，随后又被更新为 <code>28</code>，因为在 <code>HashMap</code> 中，相同的键会覆盖之前的值。</p>
<h6 id="HashSet-与-HashMap-的底层实现"><a href="#HashSet-与-HashMap-的底层实现" class="headerlink" title="HashSet 与 HashMap 的底层实现"></a><strong><code>HashSet</code> 与 <code>HashMap</code> 的底层实现</strong></h6><p>在 Java 中，<code>HashSet</code> 的底层是通过 <code>HashMap</code> 实现的。<br>具体而言，<code>HashSet</code> 内部维护了一个 <code>HashMap</code> 实例，每当向 <code>HashSet</code> 中添加元素时，实际上是将该元素作为键存储到 <code>HashMap</code> 中，而值则是一个固定的常量对象。<br>这种设计利用了 <code>HashMap</code> 键的唯一性特性，确保了 <code>HashSet</code> 中元素的唯一性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>HashSet</code> 通过一个 <code>HashMap</code> 实例 <code>map</code> 来存储元素。<br><code>PRESENT</code> 是一个静态常量对象，作为所有键对应的值。<br>每次调用 <code>add</code> 方法时，实际上是向 <code>map</code> 中添加一个键值对，其中键是元素本身，值是 <code>PRESENT</code>。<br>这种设计确保了 <code>HashSet</code> 中元素的唯一性，因为 <code>HashMap</code> 的键是唯一的。</p>
<p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p>
<h5 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/submissions/610170724/">https://leetcode.cn/problems/valid-anagram/submissions/610170724/</a></p>
<p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li>
<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>
</ul>
<p><strong>字典解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution242</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">            <span class="comment">// 判断长度</span></span><br><span class="line">            <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始化计数数组</span></span><br><span class="line">            <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="comment">// 遍历字符串 s，增加计数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历字符串 t，减少计数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">                count[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查计数数组是否全为零</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>依次遍历字符串的每一位，将其字母出现的频率反应到计数数组上<ul>
<li><code>s.charAt(i)</code>将字符串作为数组处理返回第 i 个字母</li>
<li><code>a</code>将</li>
</ul>
</li>
</ul>
<p>**时间复杂度O(m+n) **<br><strong>空间复杂度O(1)</strong></p>
<h5 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">https://leetcode.cn/problems/intersection-of-two-arrays/description/</a></p>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 它们的 <em><strong>交集</strong></em>。<br>输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>
<p><strong>数组解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection_arr(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="type">int</span>[] hash1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">    <span class="type">int</span>[] hash2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums1)</span><br><span class="line">        hash1[i]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums2)</span><br><span class="line">        hash2[i]++;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1002</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash1[i] &gt; <span class="number">0</span> &amp;&amp; hash2[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            resList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[resList.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : resList)</span><br><span class="line">        res[index++] = i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义两个数组<code>hash1</code>、<code>hash2</code>，分别<strong>遍历</strong>数组<code>nums1</code>、<code>nums2</code>，更新<strong>hash数组</strong>中第<code>num[i]</code>给元素的值</li>
<li>定义集合<code>resList</code>，<strong>遍历hash数组</strong>，使用<code>resList</code>存储两<strong>hash数组</strong>中值均不为0的下标索引，即为数组<code>num1</code>、<code>num2</code><strong>交集</strong></li>
<li>将集合<code>resList</code>转化为数组<code>res</code>，返回数组</li>
</ul>
<p><strong>Set解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection_set(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历数组1，将其转化为哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">        set1.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组2，查询哈希表中是否存在该元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">            resSet.add(i);<span class="comment">//如果存在，将其添加至集合resSet中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将集合转化为数组</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[resSet.size()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : resSet)&#123;</span><br><span class="line">        res[j++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>遍历</strong>数组1，将其转化为<strong>Set</strong>结构的哈希表<code>HashSet</code></li>
<li><strong>遍历</strong>数组2，查询<code>HashSet</code>中是否存在该元素，如果存在，则说明该元素为两数组<strong>交集</strong>，将其添加至集合<code>resSet</code>中</li>
<li>将<code>resSet</code>转换为数组，返回数组<code>res</code></li>
</ul>
<h5 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></p>
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; n &lt;&#x3D; 2<sup>31</sup> - 1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// n = 1 或 集合record中包含元素 n 时结束循环</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !record.contains(n)) &#123;</span><br><span class="line">        record.add(n);</span><br><span class="line">        n = getNextNumber(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">        res += temp * temp;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>isHappy</code> 方法接受整数 <code>n</code> ，返回布尔值</p>
<ul>
<li>使用 <code>while</code> 循环：<strong>n &#x3D; 1</strong> 或 <strong>集合record中包含元素 n</strong> 时结束循环（表示出现循环，不是快乐数）<ul>
<li>将当前的 <code>n</code> 添加到 <code>record</code> 集合中。</li>
<li>调用 <code>getNextNumber(n)</code> 方法，计算并更新 <code>n</code> 为其各位数字的平方和。</li>
</ul>
</li>
<li>循环结束后，判断 <code>n</code> 是否为 1，如果是，则返回 <code>true</code>，否则返回 <code>false</code></li>
</ul>
</li>
<li><p><code>getNextNumber</code> 方法接受整数 <code>n</code> ，返回 <code>n</code> 的各位数字的平方和。</p>
<ul>
<li>使用 <code>while</code> 循环，直到 <code>n</code> 等于 0<ul>
<li>通过 <code>n % 10</code> 获取 <code>n</code> 的个位数字，并存储在 <code>temp</code> 中。</li>
<li>将 <code>temp</code> 的平方加到 <code>res</code> 上。</li>
<li>将 <code>n</code> 除以 10，以去掉个位数字。</li>
</ul>
</li>
<li>返回累加结果 <code>res</code></li>
</ul>
</li>
<li><p>时间复杂度: O(logn)</p>
</li>
<li><p>空间复杂度: O(logn)</p>
</li>
</ul>
<h5 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/description/">https://leetcode.cn/problems/two-sum/description/</a></p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，<br>请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>2 &lt;&#x3D; nums.length &lt;&#x3D; 10<sup>4</sup></li>
<li>-10<sup>9</sup> &lt;&#x3D; nums[i] &lt;&#x3D; 10<sup>9</sup></li>
<li>-10<sup>9</sup> &lt;&#x3D; target &lt;&#x3D; 10<sup>9</sup></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span>  target) &#123;</span><br><span class="line">    <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">            res[<span class="number">1</span>]=i;</span><br><span class="line">            res[<span class="number">0</span>]=map.get(temp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>twoSum</code>方法接收数组<code>nums</code>、整数<code>target</code>，返回大小为2的数组<code>res</code></li>
<li>数组<code>nums</code>为空时直接返回空数组[0, 0]</li>
<li>定义映射<code>map</code>为哈希表，遍历数组<ul>
<li>寻找哈希表中是否存在值为<code>target - num[i]</code>的元素<ul>
<li>若存在，则将该轮遍历的数组下标和<code>map</code>中键为<code>target - num[i]</code>的值存入数组<code>res</code>，使用<code>break</code>结束循环</li>
</ul>
</li>
<li>将该轮遍历的值存入映射<code>map</code>的键，数组下标存入值<ul>
<li>(循环中查找的是数组中的值，而需要返回的是数组下标</li>
</ul>
</li>
</ul>
</li>
<li>返回数组<code>res</code></li>
</ul>
<h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><ul>
<li><p><strong>需要使用哈希法的场景</strong>：</p>
<ul>
<li>快速判断元素是否存在于集合中、统计元素出现频率、<br>处理需要快速查找的场景、<br>检测重复元素、实现缓存机制</li>
</ul>
</li>
<li><p><strong>增强for循环的使用</strong>：简化数组和集合遍历</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (元素类型 变量名 : 遍历对象) &#123;</span><br><span class="line">    <span class="comment">// 操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : nums1)</span><br><span class="line">    hash1[i]++;</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">    hash1[nums1[i]]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>数组 or Set or Map</strong><ul>
<li><strong>数组</strong>：<ul>
<li>直接用下标作映射</li>
<li>数值较大&#x2F;较分散时，数组下标过大，会浪费存储空间</li>
</ul>
</li>
<li><strong>Set</strong>：<ul>
<li>每插入一个值都需要使用哈希运算将其转变为另一个值，<br>同时还需要开辟一个新空间</li>
<li>插入值较多时开销较大</li>
</ul>
</li>
<li><strong>Map</strong>：<ul>
<li>存储<strong>键值对</strong>，可根据<strong>键</strong>快速查找对应的<strong>值</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第三章-哈希表part02"><a href="#第三章-哈希表part02" class="headerlink" title="第三章 哈希表part02"></a>第三章 哈希表part02</h3><h5 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/description/">https://leetcode.cn/problems/4sum-ii/description/</a></p>
<p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，<br>请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：<br><code>0 &lt;= i, j, k, l &lt; n</code><br><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length</code>、<code>n == nums2.length</code>、<br><code>n == nums3.length</code>、<code>n == nums4.length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li>-2<sup>28</sup> &lt;&#x3D; nums1[i], nums2[i], nums3[i], nums4[i] &lt;&#x3D; 2<sup>28</sup></li>
</ul>
<p>暴力解法：四重for循环，时间复杂度为O(n) &#x3D; n<sup>4</sup>，不考虑</p>
<p> <strong>优化解法：使用哈希表</strong>：时间复杂度可降为O(n) &#x3D; n<sup>2</sup></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建哈希表，存储nums1和nums2元素之和及其出现次数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历nums3和nums4，查找其相反数是否存在于哈希表中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums3.length; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; nums4.length; l++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums3[k] + nums4[l];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(-sum)) &#123;</span><br><span class="line">                count += map.get(-sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法<code>fourSum</code>接受四个数组，返回满足条件的四元组数量</li>
<li>定义映射<code>map</code>为哈希表，遍历<code>nums1</code>、<code>nums2</code>两个数组，每轮遍历：<ul>
<li>将<code>num1[i]</code>和<code>num2[j]</code>相加，值为<code>sum</code></li>
<li><code>map.put(sum, map.getOrDefault(sum, 0) + 1)</code>：<ul>
<li>从 <code>map</code> 中获取键 <code>sum</code> 所对应的值：如果该键存在，将值+1，否则返回1 (0+1)</li>
<li>将键 <code>sum</code> 和更新后的值重新放入 <code>map</code> 中</li>
</ul>
</li>
</ul>
</li>
<li>遍历<code>nums3</code>nums4&#96;两个数组，每轮遍历：<ul>
<li>将<code>num3[k]</code>和<code>num4[l]</code>相加，值为<code>sum</code></li>
<li><code>map.containsKey(-sum)</code>：<br>在哈希表 <code>map</code> 中查找键 <code>0-sum</code>，如果存在则将值加到计数器<code>conut</code>上</li>
</ul>
</li>
</ul>
<h5 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">https://leetcode.cn/problems/ransom-note/</a></p>
<p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。<br>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。<br><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; <code>ransomNote.length</code>, <code>magazine.length</code> &lt;&#x3D; 10<sup>5</sup></li>
<li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li>
</ul>
<p>与<code>242.有效的字母异位词 </code>这道题思路大致相同：</p>
<p>遇到判断字符串&#x2F;字母类的题可优先考虑选用数组<code>int[26]</code>作为哈希表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断长度</span></span><br><span class="line">    <span class="keyword">if</span> (ransomNote.length() &gt; magazine.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">        hash[magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">        hash[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p>**注意：**答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li>-10<sup>5</sup> &lt;&#x3D; nums[i] &lt;&#x3D; 10<sup>5</sup></li>
</ul>
<p>（略）<strong>哈希法</strong> 暂时跳过</p>
<p>两重循环，内层循环每次循环时使用<code>set.contains</code>查找是否存在满足条件的第三个数，不存在则将内层循环的数加入集合<code>set</code>中</p>
<p>注意题目中要求不能取重复位置的数，本题使用哈希法<strong>去重条件</strong>较复杂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSumHash</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 用于存储结果的列表</span></span><br><span class="line">    Arrays.sort(nums);<span class="comment">// 数组排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，固定第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果排序后的当前元素大于0，后续元素也会大于0，不可能组成和为0的三元组</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 和前一位元素作比较，重复则说明该元素已经使用过，避免结果中出现重复的三元组</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用哈希集合存储已经遍历过的元素</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历数组中剩余的元素，寻找符合条件的三元组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复的元素</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">2</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] &amp;&amp; nums[j - <span class="number">1</span>] == nums[j - <span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算第三个数的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -nums[i] - nums[j];</span><br><span class="line">            <span class="comment">// 如果集合中包含这个值，说明找到了一个符合条件的三元组</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(c)) &#123;</span><br><span class="line">                result.add(Arrays.asList(nums[i], nums[j], c));</span><br><span class="line">                <span class="comment">// 移除集合中的该值，避免重复</span></span><br><span class="line">                set.remove(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将当前元素添加到集合中</span></span><br><span class="line">                set.add(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>- </p>
<p><strong>双指针法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSumDoubleIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 用于存储结果的列表</span></span><br><span class="line">    Arrays.sort(nums); <span class="comment">// 对数组进行排序</span></span><br><span class="line">    <span class="comment">// 遍历数组，固定第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素大于0，后续元素也会大于0，不可能组成和为0的三元组</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 和前一位元素作比较，重复则说明该元素已经使用过，避免结果中出现重复的三元组</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当左指针小于右指针时，进行循环</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 三数之和大于0，右指针左移</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 三数之和小于0，左指针右移</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 三数之和等于0，找到一个符合条件的三元组</span></span><br><span class="line">                result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                <span class="comment">// 去重逻辑放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 移动指针，寻找下一个可能的三元组</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>threeSumDoubleIndex</code>方法接收数组<code>nums</code>，返回列表（二维数组）</p>
</li>
<li><p>定义列表<code>result</code>存储结果，调用<code>Arrays.sort()</code>方法给数组排序</p>
<ul>
<li><code>List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</code> 声明并初始化一个二维列表，即一个包含整数列表的列表。<br>这使得 <code>result</code> 能够存储多个 <code>List&lt;Integer&gt;</code> 类型的元素，每个元素本身又是一个整数列表。</li>
</ul>
</li>
<li><p>遍历数组</p>
<ul>
<li><code>nums[i]</code> &gt; 0 —&gt; <code>return</code>（后续元素也大于0，不可能组成和为0的三元组</li>
<li><code>nums[i] == nums[i - 1]</code> —&gt; <code>continue</code> 和<strong>前一位</strong>元素作比较，重复则说明该元素已经使用过，跳过该次循环，避免结果中出现重复的三元组<ul>
<li>不能写成<code>nums[i] == nums[i + 1]</code> ，返回结果会变为元组中不能有重复的元素</li>
</ul>
</li>
<li>在<strong>i</strong>右边定义左右两个指针，使用while找满足条件的三元组<ul>
<li>三数之和 &gt; 0，右指针左移</li>
<li>三数之和 &lt; 0，左指针右移</li>
<li>三数之和 &#x3D; 0，<code>result.add(Arrays.asList(nums[i], nums[left], nums[right]))</code><ul>
<li><code>nums[left]</code>和<code>nums[right]</code>的去重逻辑放在找到一个三元组之后<ul>
<li><code>nums[left]</code>&#x2F;<code>nums[right]</code>的下一位数值不变，则会返回相同的三元组，向再后面移动至出现不同的元素为止</li>
</ul>
</li>
<li><code>left++,right--</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/description/">https://leetcode.cn/problems/4sum/description/</a></p>
<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。<br>请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li>-10<sup>9</sup> &lt;&#x3D; nums[i] &lt;&#x3D; 10<sup>9</sup></li>
<li>-10<sup>9</sup> &lt;&#x3D; target &lt;&#x3D; 10<sup>9</sup></li>
</ul>
<p><strong>双指针</strong>，在三数之和的基础上，再在外面套一层for循环</p>
<p>注意<strong>剪枝</strong>和<strong>去重</strong>的操作<br>target为负数时，不能直接剪枝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// 排序数组</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 结果集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.length; k++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝处理，限定nums[k] &gt;= 0避免负数相加的情况</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;	<span class="comment">// 此处的break可以等价于return result;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 第二级剪枝</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;	<span class="comment">// 注意是break到上一级for循环，如果直接return result;会有遗漏</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[k], nums[i], nums[left], nums[right]));</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/10/2025-03-10-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%93%BE%E8%A1%A8part01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/10/2025-03-10-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%93%BE%E8%A1%A8part01/" class="post-title-link" itemprop="url">2025-03-11-第二章-链表part01—链表part02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-10 16:59:00" itemprop="dateCreated datePublished" datetime="2025-03-10T16:59:00+08:00">2025-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-13 14:13:47" itemprop="dateModified" datetime="2025-03-13T14:13:47+08:00">2025-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"> 代码随想链表理论基础</a></p>
<h3 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a><strong>今日任务</strong></h3><p>part01：链表理论基础 、203.移除链表元素 、707.设计链表 、206.反转链表 </p>
<p>part02：24. 两两交换链表中的节点 、19.删除链表的倒数第N个节点 、<br>               面试题 02.07. 链表相交、142.环形链表II 、总结</p>
<h3 id="第二章-链表part01"><a href="#第二章-链表part01" class="headerlink" title="第二章 链表part01"></a>第二章 链表part01</h3><h5 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h5><p>链表是一种通过指针串联在一起的线性结构，<br>每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
<p>链表的入口节点称为链表的头结点也就是head。<br>如图所示：<br><img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806194529815.png"  alt="链表1" style="zoom: 50%;" /></p>
<p><strong>链表的类型</strong></p>
<ul>
<li><p><strong>单链表</strong>：如上所述</p>
</li>
<li><p><strong>双链表</strong>：<br>单链表中的指针域只能指向节点的下一个节点。<br>而双链表每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。<br>所以双链表 既可以向前查询也可以向后查询。</p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806194559317.png"  alt="链表2" style="zoom:50%;" />
</li>
<li><p><strong>循环链表</strong>：链表首尾相连，可以用来解决约瑟夫环问题</p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806194629603.png"  alt="链表4" style="zoom:50%;" /></li>
</ul>
<p><strong>链表的存储方式</strong></p>
<p>链表是通过指针域的指针链接在内存中各个节点。</p>
<p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。<br><img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806194613920.png"  alt="链表3" style="zoom:67%;" /></p>
<p><strong>链表的定义</strong> (使用 <strong>自定义类 <code>ListNode</code></strong> 来定义链表节点)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;      <span class="comment">// 存储节点的值</span></span><br><span class="line">    ListNode next; <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 只有值的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有值和下一个节点指针的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Java 的构造函数</strong>： Java 类中的一种特殊方法，当创建对象时自动调用</p>
<ul>
<li><strong>初始化对象</strong>，为对象的字段（变量）赋初值。</li>
<li><strong>与类同名</strong>，且 <strong>没有返回值</strong>（包括 <code>void</code> 也不能写）</li>
<li><strong>可以重载</strong>（即<strong>多个构造方法</strong>），以支持不同的初始化方式</li>
</ul>
</li>
<li><p><code>ListNode</code> 类中的构造函数解析</p>
</li>
<li><p><strong>无参构造函数</strong>：</p>
<ul>
<li><p><strong>不设置任何初始值</strong>，即 <code>val</code> 默认为 <code>0</code>，<code>next</code> 默认为 <code>null</code>。</p>
<ul>
<li>适用于 <strong>先创建空节点，再赋值</strong> 的情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(); <span class="comment">// val = 0, next = null</span></span><br><span class="line">node.val = <span class="number">10</span>;</span><br><span class="line">node.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>只有值的构造函数</strong>：</p>
<ul>
<li>创建 <strong>仅存储数据、不指向其他节点</strong> 的单个节点，适用于 <strong>逐步构造链表</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>); <span class="comment">// 创建一个值为 5 的节点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有值和下一个节点指针的构造函数</strong>：</p>
<ul>
<li><strong>同时初始化节点的值和指向的下一个节点</strong>，适用于 <strong>创建多个节点连接的链表</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>, node1); <span class="comment">// node2 -&gt; node1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>)));</span><br><span class="line"><span class="comment">// 生成链表： 1 -&gt; 2 -&gt; 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这样可以<strong>一行代码创建链表</strong>，简化构造流程。</li>
</ul>
</li>
<li><p>为什么需要三种构造函数</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>构造函数</th>
<th>适用场景</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>无参构造</td>
<td>先创建节点再赋值</td>
<td>适用于动态添加节点</td>
</tr>
<tr>
<td>只有值的构造</td>
<td>只存储值，不指定后续节点</td>
<td>适用于<strong>构建独立节点</strong></td>
</tr>
<tr>
<td>值 + 指针构造</td>
<td>直接构建完整链表结构</td>
<td><strong>简化链表创建</strong>，减少手动赋值</td>
</tr>
</tbody></table>
<ul>
<li>三种构造函数的使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 无参构造（手动赋值）</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        node1.val = <span class="number">10</span>;</span><br><span class="line">        node1.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 只有值的构造</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 值 + 指针构造</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">40</span>, node2); <span class="comment">// node3 -&gt; node2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 一行构造完整链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">        printList(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>链表的操作</strong></p>
<ul>
<li><p><strong>删除节点</strong></p>
<p>删除D节点，如图所示：</p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806195114541-20230310121459257.png"  alt="链表-删除节点" style="zoom:33%;" />
只要将C节点的next指针 指向E节点就可以了。

<p>此时D节点依然存留在内存里，只不过是没有在这个链表里而已。所以在C++里最好是再手动释放这个D节点，释放这块内存。</p>
<p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p>
</li>
<li><p><strong>添加节点</strong></p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806195134331-20230310121503147.png"  alt="链表-添加节点" style="zoom: 33%;" />
可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。

<p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p>
</li>
</ul>
<p><strong>性能分析</strong></p>
<p>再把链表的特性和数组的特性进行一个对比，如图所示：<br><img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806195200276.png"  alt="链表-链表与数据性能对比" style="zoom: 50%;" /></p>
<p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>
<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<h5 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/description/">https://leetcode.cn/problems/remove-linked-list-elements/description/</a></p>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，<br>请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/removelinked-list.jpg"  alt="img" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数目在范围 [0, 10<sup>4</sup>] 内</li>
<li><code>1 &lt;= Node.val &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
<p><strong>原链表删除元素</strong></p>
<ul>
<li>判断是否移除头结点（可能需要连续移除，使用while循环作判断）<ul>
<li>删除元素为头结点则将头结点后移，</li>
</ul>
</li>
<li>定义临时指针curr，从head开始 ——&gt; 避免单向链表找不到上一个节点的问题<ul>
<li>使用临时指针 <code>curr</code> 来遍历和操作链表</li>
</ul>
</li>
<li>循环条件包含 <code>head != null</code> &#x2F; <code>curr!= null</code> ——&gt;避免操作空指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements1</span><span class="params">(ListNode head, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义临时指针curr，从head开始 ——&gt; 避免单向链表找不到上一个节点的问题</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head; </span><br><span class="line">    <span class="keyword">while</span>(curr!= <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.next.val == val)&#123;</span><br><span class="line">            curr.next = curr.next.next; <span class="comment">// 删除元素，将指针指向下一个元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            curr = curr.next; <span class="comment">//无需删除元素，遍历下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head; <span class="comment">//返回链表头节点，通过打印链表方法可输出整个链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用虚拟头结点</strong></p>
<ul>
<li>引入虚拟头节点来简化对头节点的删除操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements2</span><span class="params">(ListNode head, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个值为 0 的虚拟头节点 dummy，并将其 next 指向原链表的头节点 head。</span></span><br><span class="line">    <span class="comment">//这样，即使需要删除头节点，也能方便地处理。</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">//临时指针 curr用于遍历链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span>(curr.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.next.val == val)&#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/description/">https://leetcode.cn/problems/design-linked-list/description/</a></p>
<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>
<p>实现 <code>MyLinkedList</code> 类：</p>
<ul>
<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>
<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>
<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>
<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>
<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	输入</span></span><br><span class="line"><span class="code">[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]</span></span><br><span class="line"><span class="code">[[], [1], [3], [1, 2], [1], [1], [1]]</span></span><br><span class="line"><span class="code">	输出</span></span><br><span class="line"><span class="code">[null, null, null, null, 2, null, 3]</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	解释</span></span><br><span class="line"><span class="code">MyLinkedList myLinkedList = new MyLinkedList();</span></span><br><span class="line"><span class="code">myLinkedList.addAtHead(1);</span></span><br><span class="line"><span class="code">myLinkedList.addAtTail(3);</span></span><br><span class="line"><span class="code">myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span></span><br><span class="line"><span class="code">myLinkedList.get(1);              // 返回 2</span></span><br><span class="line"><span class="code">myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span></span><br><span class="line"><span class="code">myLinkedList.get(1);              // 返回 3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= index, val &lt;= 1000</code></li>
<li>请不要使用内置的 LinkedList 库。</li>
<li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li>
</ul>
<p><strong>定义一个链表节点类</strong><br>包含节点的值 <code>val</code> 、指向下一个节点的引用 <code>next</code><br>	以及两个成员变量：<code>size</code> 用于存储链表元素的个数，<code>head</code> 记录的是虚拟头结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val=val;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//size存储链表元素的个数</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"> <span class="comment">//注意这里记录的是虚拟头结点</span></span><br><span class="line"> <span class="keyword">private</span> ListNode head;</span><br></pre></td></tr></table></figure>

<p><strong>需要实现功能如下：</strong></p>
<ul>
<li>初始化链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取第N个节点的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//第0个节点是虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>头部插入节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    newNode.next = head.next;</span><br><span class="line">    head.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 在链表最前面插入一个节点，等价于在第0个元素前添加</span></span><br><span class="line">    <span class="comment">// addAtIndex(0, val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尾部插入节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span></span><br><span class="line">    <span class="comment">// addAtIndex(size, val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第N个节点前插入节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line"><span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line"><span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    newNode.next = pre.next;</span><br><span class="line">    pre.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除第N个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为有虚拟头节点，所以不用对index=0的情况进行特殊处理</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = pre.next.next;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//注意这里记录的是虚拟头结点</span></span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值，注意index是从0开始的，第0个节点就是虚拟头结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//第0个节点是虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = head.next;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">// 在链表最前面插入一个节点，等价于在第0个元素前添加</span></span><br><span class="line">        <span class="comment">// addAtIndex(0, val);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span></span><br><span class="line">        <span class="comment">// addAtIndex(size, val);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = pre.next;</span><br><span class="line">        pre.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为有虚拟头节点，所以不用对index=0的情况进行特殊处理</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h5><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/rev1ex1.jpg"  alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/rev1ex2.jpg"  alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶</strong>：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p><strong>双指针解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义一个临时指针，用于循环的时候保存下一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        temp = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>cur</code>指向头节点遍历链表，<br><code>prve</code>为当前节点的上一个节点，初值为null —&gt; 链表反转后，原链表头节点的下一个节点为null<br>定义一个临时指针<code>temp</code>，用于循环的时候保存下一个节点</p>
</li>
<li><p>每次循环完成如下操作，直至<code>cur</code>循环到null</p>
<ul>
<li><strong>暂存下一个节点：</strong> 使用 <code>nextTemp</code> 暂存 <code>curr</code> 的下一个节点，防止链表断裂。</li>
<li><strong>反转指针：</strong> 将 <code>curr</code> 的 <code>next</code> 指向 <code>prev</code>，实现当前节点指针反转。</li>
<li><strong>移动指针：</strong> 将 <code>prev</code> 移动到 <code>curr</code>，<code>curr</code> 移动到 <code>nextTemp</code>，即下一个节点。</li>
</ul>
</li>
<li><p>遍历结束后，<code>prev</code> 即为新的头节点，返回 <code>prev</code></p>
</li>
</ul>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/screenshot_2025_03_12T16_42_01+0800.png"  alt="screenshot_2025_03_12T16_42_01+0800" style="zoom:33%;" />



<p><strong>递归解法</strong></p>
<p><strong>递归解法在逻辑上和是双指针法等效的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList2</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode prev, ListNode cur)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    temp = cur.next;</span><br><span class="line">    cur.next = prev;</span><br><span class="line">    <span class="comment">// 更新prev、cur位置</span></span><br><span class="line">    <span class="comment">// prev = cur;</span></span><br><span class="line">    <span class="comment">// cur = temp;</span></span><br><span class="line">    <span class="keyword">return</span> reverse(cur, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>递归终止条件：</strong> 当链表为空（<code>head == null</code>）或仅有一个节点（<code>head.next == null</code>）时，直接返回该节点作为新的头节点。</li>
<li><strong>递归调用：</strong> 对 <code>head.next</code> 进行递归调用，反转剩余的链表，返回新的头节点 <code>newHead</code>。</li>
<li><strong>反转指针：</strong> 将当前节点的下一个节点的 <code>next</code> 指向当前节点，即 <code>head.next.next = head</code>，实现当前节点与下一个节点的连接反转。</li>
<li><strong>断开连接：</strong> 将当前节点的 <code>next</code> 设为 <code>null</code>，断开原始链表中当前节点与下一个节点的连接，防止形成环。</li>
<li><strong>返回新头节点：</strong> 递归完成后，<code>newHead</code> 即为反转后的新头节点，返回 <code>newHead</code>。</li>
</ul>
<p>两种写法时间复杂度都为: O(n)；<br>双指针空间复杂度为: O(1)、递归写法空间复杂度: O(n), 递归调用了 n 层栈空间；</p>
<h3 id="第二章-链表part02"><a href="#第二章-链表part02" class="headerlink" title="第二章 链表part02"></a>第二章 链表part02</h3><h5 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。<br>你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/swap_ex1.jpg"  alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dumyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dumyhead.next = head; <span class="comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dumyhead;</span><br><span class="line">        ListNode temp; <span class="comment">// 临时节点，保存两个节点后面的节点</span></span><br><span class="line">        ListNode firstnode; <span class="comment">// 临时节点，保存两个节点之中的第一个节点</span></span><br><span class="line">        ListNode secondnode; <span class="comment">// 临时节点，保存两个节点之中的第二个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = cur.next.next.next;</span><br><span class="line">            firstnode = cur.next;</span><br><span class="line">            secondnode = cur.next.next;</span><br><span class="line">            cur.next = secondnode;       <span class="comment">// 步骤一</span></span><br><span class="line">            secondnode.next = firstnode; <span class="comment">// 步骤二</span></span><br><span class="line">            firstnode.next = temp;      <span class="comment">// 步骤三</span></span><br><span class="line">            cur = firstnode; <span class="comment">// cur移动，准备下一轮交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>创建虚拟头结点：</strong> 为了方便处理头节点的交换情况，创建一个虚拟头结点 <code>dummyHead</code>，其 <code>next</code> 指向原链表的头节点 <code>head</code>。</li>
<li><strong>初始化指针：</strong> 使用指针 <code>cur</code> 指向虚拟头结点 <code>dummyHead</code>，以便在循环中进行节点交换操作。</li>
<li><strong>遍历链表：</strong> 在 <code>cur.next</code> 和 <code>cur.next.next</code> 都不为 <code>null</code> 的情况下，进行以下操作：<ul>
<li><strong>定义要交换的节点：</strong> <code>firstNode</code> 指向 <code>cur.next</code>，即第一个要交换的节点；<code>secondNode</code> 指向 <code>cur.next.next</code>，即第二个要交换的节点。</li>
<li><strong>交换节点：</strong> 首先将 <code>firstNode.next</code> 指向 <code>secondNode.next</code>，然后将 <code>secondNode.next</code> 指向 <code>firstNode</code>，最后将 <code>cur.next</code> 指向 <code>secondNode</code>。这样就完成了两个节点的交换。</li>
<li><strong>移动指针：</strong> 将 <code>cur</code> 移动到 <code>firstNode</code>，为下一次交换做准备。</li>
</ul>
</li>
<li><strong>返回新头节点：</strong> 循环结束后，返回 <code>dummyHead.next</code>，即交换后的新头节点。</li>
</ol>
<p><strong>在每轮循环结束后，指针 <code>cur</code> 会移动到下一轮需要操作的第一个节点的前一个节点</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/screenshot_2025_03_13T09_35_32+0800.png"  alt="screenshot_2025_03_13T09_35_32+0800" style="zoom: 25%;" /></p>
<h5 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h5><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<img src="/2025/03/10/2025-03-10-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%93%BE%E8%A1%A8part01/remove_ex1.jpg" class="" title="img">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>双指针法</strong></p>
<p>让<code>fast</code>先移动n步，然后让<code>fast</code>和<code>slow</code>同时移动，<br>直到<code>fast</code>指向null。删掉<code>slow</code>所指向的节点就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="面试题-02-07-链表相交略"><a href="#面试题-02-07-链表相交略" class="headerlink" title="面试题 02.07. 链表相交	略"></a>面试题 02.07. 链表相交	略</h5><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交**：**<br><img src="/2025/03/10/2025-03-10-第二章-链表part01/160_statement.png"  alt="img" style="zoom: 50%;" />]</p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>示例 1：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/160_example_1.png"  alt="img" style="zoom: 50%;" />]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/160_example_2.png"  alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/160_example_3.png"  alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>0 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>
</ul>
<p>**进阶：**你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<h5 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h5><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/circularlinkedlist.png"  alt="img" style="zoom: 67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/circularlinkedlist_test2.png"  alt="img" style="zoom: 67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/circularlinkedlist_test3.png"  alt="img" style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p>**进阶：**你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<ul>
<li><p><strong>142.1确认是否有环</strong>：</p>
<ul>
<li>使用快慢指针，快指针步长为2，慢指针步长为1</li>
<li>快指针追上慢指针则说明链表中存在环</li>
</ul>
</li>
<li><p><strong>142.2找环的入口</strong></p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/screenshot_2025_03_13T14_05_44+0800.png"  alt="screenshot_2025_03_13T14_05_44+0800" style="zoom: 33%;" />

<p>综上，快慢指针相遇时，定义两个新指针以同样步长分别从头结点和相遇位置出发直到相遇，相遇点即为环入口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution142</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="间"
      src="/images/new_avatar.png">
  <p class="site-author-name" itemprop="name">间</p>
  <div class="site-description" itemprop="description">助理开发工程师，不被温水煮死就算成功，顺便学点Java，刷点算法，水点八股...大概</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">间</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
