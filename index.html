<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/web-app-manifest-192x192.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-96x96.png">
  <link rel="mask-icon" href="/images/favicon/favicon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"souls5.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
<meta property="og:type" content="website">
<meta property="og:title" content="不是不是">
<meta property="og:url" content="https://souls5.github.io/index.html">
<meta property="og:site_name" content="不是不是">
<meta property="og:description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="间">
<meta property="article:tag" content="Java,JavaWeb,Redis,Nosql,Linux,算法,数据结构,面试,数据结构">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://souls5.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>不是不是</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不是不是</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习、挣扎和一些无关紧要的琐事...大概</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/05/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/05/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-05 09:12:44" itemprop="dateCreated datePublished" datetime="2025-03-05T09:12:44+08:00">2025-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-06 19:01:55" itemprop="dateModified" datetime="2025-03-06T19:01:55+08:00">2025-03-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>title: 卡码八股训练营记录<br>date: 2025-02-19 00:00:00<br>tags: [面试, 八股]<br>categories: [面试]</p>
<h3 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h3><h4 id="介绍一下TCP-IP模型和OSI模型的区别"><a href="#介绍一下TCP-IP模型和OSI模型的区别" class="headerlink" title="介绍一下TCP&#x2F;IP模型和OSI模型的区别"></a>介绍一下TCP&#x2F;IP模型和OSI模型的区别</h4><p><strong>TCP&#x2F;IP 模型与 OSI 模型的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>OSI 模型（七层）</strong></th>
<th><strong>TCP&#x2F;IP 模型（四层）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>层次划分</strong></td>
<td>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</td>
<td>应用层、传输层、网络层、网络接口层</td>
</tr>
<tr>
<td><strong>设计理念</strong></td>
<td>理想化、理论性强，定义清晰的层次关系，每层独立</td>
<td>结合实际网络设计，更符合互联网协议</td>
</tr>
<tr>
<td><strong>协议示例</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>应用层</strong></td>
<td>HTTP、FTP、SMTP、DNS 等</td>
<td>HTTP、FTP、SMTP、DNS 等（合并 OSI 的应用层、表示层、会话层）</td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td>TCP、UDP</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td>IP、ICMP、ARP</td>
<td>IP、ICMP、ARP</td>
</tr>
<tr>
<td><strong>数据链路层 &#x2F; 物理层</strong></td>
<td>以太网、Wi-Fi、PPP</td>
<td>以太网、Wi-Fi、PPP（合并 OSI 的数据链路层、物理层）</td>
</tr>
<tr>
<td><strong>适用范围</strong></td>
<td>理论上更全面</td>
<td>实际网络通信中更为实用。</td>
</tr>
<tr>
<td><strong>数据封装单位</strong></td>
<td><strong>比特流（物理层） → 帧（数据链路层） → 数据包（网络层） → 段（传输层） → 数据（应用层）</strong></td>
<td><strong>比特流 → 帧 → 数据包 → 段 → 数据</strong></td>
</tr>
</tbody></table>
<p>TCP&#x2F;IP 模型的<strong>应用层</strong>相当于 OSI 的 <strong>应用层 + 表示层 + 会话层</strong>，<br>而 TCP&#x2F;IP 的<strong>网络接口层</strong>相当于 OSI 的 <strong>数据链路层 + 物理层</strong>。</p>
<h4 id="从输入-URL-到页面展示到底发生了什么？"><a href="#从输入-URL-到页面展示到底发生了什么？" class="headerlink" title="从输入 URL 到页面展示到底发生了什么？"></a>从输入 URL 到页面展示到底发生了什么？</h4><ul>
<li><strong>浏览器网络请求</strong><ul>
<li><strong>输入网址，解析 URL 信息</strong><ul>
<li>解析 URL，提取协议（<code>https</code>）、域名（<code>www.example.com</code>）、路径（<code>/</code>）</li>
</ul>
</li>
<li><strong>检查浏览器缓存</strong><ul>
<li>有缓存并且仍然有效，则直接加载页面</li>
</ul>
</li>
<li><strong>DNS 解析 （域名 → IP 地址）</strong><ul>
<li>浏览器缓存 —&gt; 本地 <code>hosts</code> 文件 —&gt; 本地 DNS 服务器（ISP 提供）—&gt;权威 DNS 服务器（根 DNS → 顶级域名 DNS → 权威 DNS）</li>
</ul>
</li>
<li><strong>建立 TCP 连接（三次握手）</strong><ul>
<li><strong>第一步</strong>：客户端发送 SYN 报文请求连接。</li>
<li><strong>第二步</strong>：服务器回复 SYN-ACK 报文，确认连接请求。</li>
<li><strong>第三步</strong>：客户端回复 ACK，连接建立成功。</li>
</ul>
</li>
<li><strong>发送 HTTP 请求</strong><ul>
<li>浏览器构造 HTTP 请求：<ul>
<li><strong>请求行</strong>（请求方法 <code>GET</code>、请求路径 <code>/</code>、协议版本 <code>HTTP/1.1</code>）</li>
<li><strong>请求头</strong>（包含 <code>User-Agent</code>、<code>Cookie</code> 等）</li>
</ul>
</li>
<li>如果是 HTTPS，还涉及 <strong>TLS 握手</strong> 进行加密通信。</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务器处理请求</strong><ul>
<li><strong>服务器解析HTTP请求</strong><ul>
<li>接收 HTTP 请求，解析 URL 和请求头，查询静态资源和数据库、渲染动态页面</li>
</ul>
</li>
<li><strong>服务器返回HTTP响应</strong><ul>
<li><strong>响应状态码</strong>（如 <code>200 OK</code>，<code>404 Not Found</code>）</li>
<li><strong>响应头</strong>（<code>Content-Type: text/html</code>）</li>
<li><strong>响应体</strong>（HTML、CSS、JavaScript）</li>
</ul>
</li>
<li><strong>TCP 连接断开（四次挥手）</strong><ul>
<li><strong>客户端发送 FIN</strong>（请求关闭连接）</li>
<li><strong>服务器回复 ACK</strong>  此时若有剩余数据则继续发送</li>
<li><strong>服务器发送 FIN</strong>（服务器准备关闭）</li>
<li><strong>客户端回复 ACK</strong>（最终确认关闭）</li>
</ul>
</li>
</ul>
</li>
<li><strong>浏览器解析并渲染页面</strong><ul>
<li><strong>解析响应头</strong><ul>
<li>301，302重定向，为字节流则下载，为HTML文件则解析html文件</li>
</ul>
</li>
<li><strong>解析HTML 并渲染页面</strong><ul>
<li><strong>解析 HTML</strong>，构建 <strong>DOM 树</strong>    <strong>解析 CSS</strong>，构建 <strong>CSSOM 树</strong>，进行 <strong>样式计算</strong></li>
<li><strong>合成渲染树</strong>（DOM + CSSOM），<strong>布局（Layout）</strong> 计算元素的具体位置，<strong>绘制（Painting）</strong> 将页面渲染到屏幕上</li>
<li><strong>执行 JavaScript</strong>，更新页面内容</li>
</ul>
</li>
<li><strong>页面显示</strong><ul>
<li>页面最终呈现给用户，加载其他资源（图片、视频、异步数据等）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h3><h4 id="HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"><a href="#HTTP请求报文和响应报文是怎样的，有哪些常见的字段？" class="headerlink" title="HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"></a>HTTP请求报文和响应报文是怎样的，有哪些常见的字段？</h4><h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><ul>
<li><p><strong>请求行</strong>（Request Line）</p>
<ul>
<li><p><strong>请求方法（Method）</strong>：如 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等</p>
</li>
<li><p><strong>资源路径（Resource Path）</strong>：要访问的资源地址</p>
</li>
<li><p><strong>HTTP 版本（HTTP Version）</strong>：如 <code>HTTP/1.1</code>、<code>HTTP/2.0</code></p>
</li>
<li><p>例如：<code>GET /index.html HTTP/1.1</code></p>
</li>
</ul>
</li>
<li><p><strong>请求头</strong>（Request Headers）：提供额外的信息，例如浏览器类型、缓存策略等</p>
<ul>
<li><p>常见请求头字段：</p>
<ul>
<li><p><strong>客户端环境&#x2F;请求资源</strong></p>
<ul>
<li><code>Host</code>：请求的服务器域名（必须字段）</li>
<li><code>User-Agent</code>：客户端信息（如浏览器、操作系统）</li>
<li><code>Accept</code>：客户端能接受的数据类型（如 <code>text/html</code>）</li>
<li><code>Accept-Encoding</code>：支持的压缩格式（如 <code>gzip</code>）</li>
</ul>
</li>
<li><p><strong>身份认证与安全</strong></p>
<ul>
<li><code>Authorization</code>：身份认证信息（如 <code>Bearer Token</code>）</li>
</ul>
</li>
<li><p><strong>缓存控制</strong></p>
<ul>
<li><code>If-None-Match </code> &#x2F; <code> If-Modified-Since</code>：资源的ETag &#x2F; 最后修改时间 值，用于缓存控制。</li>
</ul>
</li>
<li><p><strong>请求内容描述</strong></p>
<ul>
<li><code>Content-Length</code>：请求体的长度（仅适用于带请求体的方法）</li>
<li><code>Content-Type</code>：请求体的媒体类型（如 <code>application/json</code>）</li>
<li><code>Cookie</code>：发送存储在客户端的 Cookie</li>
</ul>
</li>
<li><p><code>Connection</code>：管理连接的选项，如 keep-alive</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>空行</strong>：用于分隔请求头和请求体。</p>
</li>
<li><p><strong>请求体</strong>（Request Body）：用于 <code>POST</code>、<code>PUT</code> 请求，包含要发送的数据（如 JSON、表单数据等）。</p>
</li>
</ul>
<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><ul>
<li><p><strong>状态行</strong>（Status Line）：包含 HTTP 版本、状态码、状态描述</p>
<ul>
<li><p><strong>HTTP 版本</strong>：如 <code>HTTP/1.1</code></p>
</li>
<li><p><strong>状态码</strong>（Status Code）</p>
<ul>
<li><code>2xx</code>（成功）：<code>200 OK</code>、<code>201 Created</code></li>
<li><code>3xx</code>（重定向）：<code>301 Moved Permanently</code>、<code>302 Found</code></li>
<li><code>4xx</code>（客户端错误）：<code>400 Bad Request</code>、<code>404 Not Found</code></li>
<li><code>5xx</code>（服务器错误）：<code>500 Internal Server Error</code></li>
</ul>
</li>
<li><p><strong>状态描述</strong>：对状态码的解释（如 <code>OK</code>、<code>Not Found</code>）</p>
</li>
<li><p>例如：<code>HTTP/1.1 200 OK</code></p>
</li>
</ul>
</li>
<li><p><strong>响应头</strong>（Response Headers）：提供额外信息，如内容类型、缓存控制等</p>
<ul>
<li><p>常见响应头字段</p>
<ul>
<li><p><strong>重定向</strong></p>
<ul>
<li><code>Location</code>：重定向地址（适用于 301、302）</li>
</ul>
</li>
<li><p><strong>描述响应内容</strong></p>
<ul>
<li><code>Content-Type</code>：返回数据的 MIME 类型（如 <code>text/html</code>）</li>
<li><code>Content-Length</code>：响应体长度（字节）</li>
</ul>
</li>
<li><p><strong>控制缓存</strong></p>
<ul>
<li><code>Expires</code>：指定响应的过期时间，用于缓存控制。</li>
<li><code>ETag</code>：资源的实体标签，用于缓存验证。</li>
<li><code>Last-Modified</code>：资源最后修改的日期和时间。</li>
</ul>
</li>
<li><p><strong>管理连接和安全</strong></p>
<ul>
<li><code>Server</code>：服务器软件信息（如 <code>nginx/1.18.0</code>）</li>
<li><code>Set-Cookie</code>：设置 Cookie</li>
<li><code>Access-Control-Allow-Origin</code>：指示哪些域名可以访问资源，涉及跨域资源共享（CORS）策略</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>空行</strong>：用于分隔响应头和响应体。</p>
</li>
<li><p><strong>响应体</strong>（Response Body）：实际的返回数据，如 HTML 页面、JSON 数据、图片等。</p>
</li>
</ul>
<h4 id="HTTP有哪些请求方式？"><a href="#HTTP有哪些请求方式？" class="headerlink" title="HTTP有哪些请求方式？"></a>HTTP有哪些请求方式？</h4><p><strong>幂等性</strong>：表示多次执行相同请求，服务器状态不变。</p>
<p><strong>安全性</strong>：表示请求不会修改服务器数据（如 <code>GET</code>、<code>HEAD</code>、<code>OPTIONS</code>）。</p>
<p>HTTP 定义了多种请求方法，每种方法适用于不同的场景。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>用途</strong></th>
<th><strong>幂等性</strong></th>
<th><strong>安全性</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>GET</strong></td>
<td>获取资源</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>POST</strong></td>
<td>提交数据</td>
<td>❌ 非幂等</td>
<td>❌ 不安全（数据在请求体中）</td>
</tr>
<tr>
<td><strong>PUT</strong></td>
<td>更新资源（完整更新）</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>DELETE</strong></td>
<td>删除资源</td>
<td>✅ 幂等</td>
<td>❌ 不安全（改变服务器状态）</td>
</tr>
<tr>
<td><strong>HEAD</strong></td>
<td>获取资源的头部信息</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>OPTIONS</strong></td>
<td>获取服务器支持的请求方法</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>TRACE</strong></td>
<td>回显请求，用于调试</td>
<td>✅ 幂等</td>
<td>❌ 不安全（容易被攻击）</td>
</tr>
<tr>
<td><strong>CONNECT</strong></td>
<td>建立隧道连接（如 HTTPS 代理）</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
</tbody></table>
<h4 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h4><ul>
<li><code>GET</code> <strong>适用于获取数据</strong>，参数放在 URL，容易被缓存，幂等且安全。</li>
<li><code>POST</code> <strong>适用于提交数据</strong>，参数放在请求体，不容易被缓存，不幂等。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>参数位置</strong></td>
<td>URL 查询参数（<code>?key=value</code>）</td>
<td>请求体</td>
</tr>
<tr>
<td><strong>参数长度</strong></td>
<td>受 URL 长度限制</td>
<td>理论上无限制</td>
</tr>
<tr>
<td><strong>缓存</strong></td>
<td>可被缓存</td>
<td>不会被浏览器缓存</td>
</tr>
<tr>
<td><strong>可见性</strong></td>
<td>参数暴露在 URL 中</td>
<td>参数在请求体，不易暴露</td>
</tr>
<tr>
<td><strong>幂等性</strong></td>
<td>✅ 幂等</td>
<td>❌ 非幂等</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>查询数据（如获取用户信息）</td>
<td>提交数据（如用户注册、登录）</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>❌ 不适合传输敏感信息（如密码）</td>
<td>✅ 相对更安全，但仍需 HTTPS</td>
</tr>
</tbody></table>
<h3 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h3><h4 id="HTTP请求中常见的状态码"><a href="#HTTP请求中常见的状态码" class="headerlink" title="HTTP请求中常见的状态码"></a><strong>HTTP请求中常见的状态码</strong></h4><p>HTTP 状态码用于指示服务器对请求的处理结果，按照功能分为 5 类</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>分类名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1xx</strong></td>
<td><strong>信息性状态码</strong></td>
<td>服务器已收到请求，正在继续处理</td>
</tr>
<tr>
<td><strong>2xx</strong></td>
<td><strong>成功状态码</strong></td>
<td>请求成功并返回预期的响应</td>
</tr>
<tr>
<td><strong>3xx</strong></td>
<td><strong>重定向状态码</strong></td>
<td>需要客户端执行进一步操作（重定向）</td>
</tr>
<tr>
<td><strong>4xx</strong></td>
<td><strong>客户端错误码</strong></td>
<td>客户端请求有错误（参数错误、权限不足等）</td>
</tr>
<tr>
<td><strong>5xx</strong></td>
<td><strong>服务器错误码</strong></td>
<td>服务器端发生错误，无法处理请求</td>
</tr>
</tbody></table>
<p><strong>常见状态码</strong></p>
<ul>
<li><p>**2xx：**请求成功</p>
<ul>
<li><strong>200 OK</strong>：常用于 <code>GET</code>、<code>POST</code>、<code>PUT</code> 等请求。</li>
<li><strong>201 Created</strong>：服务器创建了新资源（常用于 <code>POST</code>）。</li>
<li><strong>204 No Content</strong>：服务器无返回内容（常用于 <code>DELETE</code>）。</li>
</ul>
</li>
<li><p><strong>3xx：</strong></p>
<ul>
<li><strong>301 Moved Permanently</strong>：资源永久移动，后续请求应使用新 URL（SEO 友好）。</li>
<li><strong>302 Found</strong>（临时重定向）：资源暂时移动，后续请求仍可使用原 URL。</li>
<li><strong>304 Not Modified</strong>（缓存优化）：客户端缓存资源仍然有效，无需重新下载（结合 <code>ETag</code>、<code>Last-Modified</code> 头使用）。<ul>
<li><strong>缓存相关：</strong></li>
<li>浏览器在接收到 <code>304 Not Modified</code> 后，不会下载新资源，而是从本地缓存加载，提升性能。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>4xx：</strong></p>
<ul>
<li><strong>400 Bad Request</strong>：请求格式错误或参数无效，服务器无法解析。</li>
<li><strong>401 Unauthorized</strong>：身份认证失败，需要提供有效凭证（如未登录）。</li>
<li><strong>403 Forbidden</strong>：服务器拒绝请求。（如权限不够）</li>
<li><strong>404 Not Found</strong>：请求的资源不存在（常见于访问错误的 URL）。</li>
</ul>
</li>
<li><p><strong>5xx：</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong>：服务器内部错误（代码异常、数据库崩溃等）。</li>
<li><strong>502 Bad Gateway</strong>：服务器作为网关&#x2F;代理，收到无效响应（上游服务器问题）。</li>
<li><strong>503 Service Unavailable</strong>：服务器暂时不可用（维护、超载等）。</li>
</ul>
</li>
</ul>
<p><strong>状态码使用案例</strong></p>
<ol>
<li><strong>用户访问网站首页</strong><ul>
<li>正常加载：返回 <code>200 OK</code></li>
<li>页面不存在：返回 <code>404 Not Found</code></li>
<li>需要登录：返回 <code>401 Unauthorized</code></li>
</ul>
</li>
<li><strong>API 接口</strong><ul>
<li>获取数据成功：返回 <code>200 OK</code></li>
<li>没有权限：返回 <code>403 Forbidden</code></li>
<li>请求参数错误：返回 <code>400 Bad Request</code></li>
</ul>
</li>
<li><strong>重定向</strong><ul>
<li>旧网站迁移到新域名：返回 <code>301 Moved Permanently</code></li>
<li>用户登录后跳转到主页：返回 <code>302 Found</code></li>
<li>资源未修改：返回 &#96;304 Not Modified</li>
</ul>
</li>
</ol>
<h4 id="什么是强缓存和协商缓存"><a href="#什么是强缓存和协商缓存" class="headerlink" title="什么是强缓存和协商缓存"></a><strong>什么是强缓存和协商缓存</strong></h4><p>HTTP 协议中，缓存机制主要用于减轻服务器负担，加快页面加载速度</p>
<ol>
<li>浏览器第一次访问时访问服务器时需要下载资源</li>
<li>后续访问时，只要强缓存没有失效就直接从缓存中获取，不需要将获取资源的请求包含在请求报文中</li>
<li>当强缓存失效后，浏览器会使用协商缓存机制来验证资源是否被修改</li>
</ol>
<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><ul>
<li><strong>Expires</strong><br> <code>Expires</code> 是一个 HTTP 响应头，指定资源的过期时间（绝对时间），表示在该时间之前资源都是有效的，可以直接使用缓存，不需要向服务器重新请求。<br> 用于设置强缓存。当客户端收到带有 <code>Expires</code> 头的响应后，在当前时间早于 <code>Expires</code> 指定时间内，浏览器直接从本地缓存中读取资源。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 21 Oct 2025 07:28:00 GMT</span><br><span class="line"><span class="comment">## 表示在 2025 年 10 月 21 日 07:28:00 GMT 之前，资源均可直接使用缓存。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>Cache-Control</strong></p>
<p><code>Cache-Control</code> 是 HTTP&#x2F;1.1 提供的用于控制缓存行为的通用头部，可以用于请求和响应中。它提供了多种指令来精细控制资源如何被缓存。<br>用于替代或补充 <code>Expires</code>，提供更灵活的缓存控制。服务器可以根据业务需求，准确控制资源的缓存策略</p>
<ul>
<li><strong>常见指令</strong>：<ul>
<li><strong>max-age</strong>：指定资源在客户端缓存的最大时间（秒），例如 <code>max-age=3600</code> 表示缓存有效期为 3600 秒。</li>
<li><strong>no-cache</strong>：表示缓存必须在使用前进行重新验证，即使缓存仍在有效期内。</li>
<li><strong>no-store</strong>：禁止缓存，确保每次请求都从服务器获取最新数据。</li>
<li><strong>public</strong> 和 <strong>private</strong>：分别指示资源可以被所有用户缓存，或仅供单个用户缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=3600, public</span><br><span class="line"><span class="comment">## 表示资源可以被缓存 3600 秒，并允许任何缓存设备缓存此资源。</span></span><br></pre></td></tr></table></figure>



<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><ul>
<li><p><strong>Last-Modified</strong></p>
<p> <code>Last-Modified</code> 是服务器在响应中返回的头部字段，用来指示资源的最后修改时间。它通常以 GMT 时间格式表示。</p>
<p> 客户端在后续请求时，可以使用 <code>If-Modified-Since</code> 请求头将之前获取的 <code>Last-Modified</code> 值发送给服务器。如果资源自该时间之后没有更新，服务器可以返回 <code>304 Not Modified</code> 状态，从而避免不必要的数据传输。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Tue, 20 Apr 2025 12:00:00 GMT</span><br><span class="line"><span class="comment">## 表示资源在该时间之后没有发生变化，客户端可据此进行缓存验证。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>ETag</strong></p>
<p> <code>ETag</code>（实体标签）是服务器为特定资源生成的唯一标识符，它反映了资源的版本。当资源内容发生变化时，ETag 值也会改变。</p>
<p> 客户端在后续请求时，可以在请求头中使用 <code>If-None-Match</code> 将之前收到的 ETag 值发送给服务器。服务器比对后，如果发现资源没有变化，则返回 <code>304 Not Modified</code>，让客户端继续使用缓存数据。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ETag: <span class="string">&quot;686897696a7c876b7e&quot;</span></span><br><span class="line"><span class="comment">## 表示该资源当前的版本标识符，后续可以利用此值进行缓存验证。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>浏览器使用缓存流程</code><br><img src="/2025/03/05/2025-02-19-卡码八股训练营记录/1.png"  alt="1" style="zoom:67%;" /></p>
<h3 id="Day04"><a href="#Day04" class="headerlink" title="Day04"></a>Day04</h3><h4 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h4><ul>
<li><strong>连接管理</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：默认使用<strong>短连接</strong>，每次请求&#x2F;响应后关闭 TCP 连接；<br>可以通过 <code>Connection: keep-alive</code> 来实现持久连接</li>
<li><em>HTTP&#x2F;1.1</em>：默认启用<strong>持久连接</strong>（<code>Connection</code>字段值默认为<code>keep-alive</code>），<br>在同一 TCP 连接上可以连续发送多个请求和响应，减少了连接建立和关闭的开销。</li>
</ul>
</li>
<li><strong>管道化</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：客户端的每次请求都需要在上一次请求的响应到达之后发送，请求发送有等待时间</li>
<li><em>HTTP&#x2F;1.1</em>：支持<strong>管道化</strong>，即同一连接上可以连续发送多个请求，<br>但由于服务器必须按顺序返回响应（队头阻塞问题），实际效果有限</li>
</ul>
</li>
<li><strong>缓存控制</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：主要依赖 <code>Expires</code> 头来指定资源的绝对过期时间，没有协商缓存机制</li>
<li><em>HTTP&#x2F;1.1</em>：引入了 <code>Cache-Control </code>头提供更精细的缓存指令,通过 <code>If-Modified-Since </code>和 <code>If-None-Match </code>等头实现协商缓存</li>
</ul>
</li>
<li><strong>错误处理和状态码</strong><br><strong>HTTP&#x2F;1.1</strong>增加了状态码（如 <code>100 Continue</code>）用于中间响应和更精细的错误处理，<br>使客户端能更好地管理请求过程和错误恢复</li>
<li><strong>请求头要求</strong><br><strong>HTTP&#x2F;1.1</strong>要求所有请求必须包含 <code>Host</code> 头  —&gt;  一台服务器&#x2F;一个IP 上可托管多个 域名&#x2F;网站</li>
<li><strong>带宽优化</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：不支持断点续传功能，客户端只需要某个对象的一部分时，服务器也会将整个对象发送过来</li>
<li><em>HTTP&#x2F;1.1</em>：在请求头引入了<code>range</code>头域，允许只请求资源的某个部分，此时服务器返回状态码<code>206</code></li>
</ul>
</li>
</ul>
<h4 id="HTTP2-0与HTTP1-1的区别？"><a href="#HTTP2-0与HTTP1-1的区别？" class="headerlink" title="HTTP2.0与HTTP1.1的区别？"></a>HTTP2.0与HTTP1.1的区别？</h4><ul>
<li><p><strong>二进制协议</strong></p>
<ul>
<li>HTTP&#x2F;1.1：请求和响应内容都是以纯文本方式发送的，解析时开销较大且容易出错。</li>
<li>HTTP&#x2F;2.0：采用二进制格式，将数据分割为小的帧，解析更高效、可靠</li>
</ul>
</li>
<li><p><strong>多路复用</strong></p>
<ul>
<li>HTTP&#x2F;1.1：支持持久连接，但请求在同一连接上串行发送，容易出现队头阻塞<ul>
<li>可以连续发送多个请求，但服务器必须按顺序返回响应</li>
</ul>
</li>
<li>HTTP&#x2F;2.0：支持多路复用，允许在单个TCP连接上并行交错发送多个请求和响应<ul>
<li>请求和响应报文被拆分为更小的帧<ul>
<li>帧类型包括 DATA、HEADERS、PRIORITY 等，每种类型的帧都有特定的用途。</li>
<li>流的状态管理涉及多种状态，如“已打开”、“已关闭”等，客户端和服务器可以通过发送特定的帧（如 RST_STREAM）来管理流的生命周期</li>
</ul>
</li>
<li>帧被分配到不同的流（Stream），每个流都有唯一的标识符</li>
<li>接收方根据帧头中的流标识符将属于同一流的帧重新组装为完整的请求或响应</li>
</ul>
</li>
<li>HTTP&#x2F;2.0 基于 TCP 协议来传输数据，发生了丢包现象时，就会触发 TCP 的重传机制，<br>这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来</li>
</ul>
</li>
<li><p><strong>头部压缩</strong></p>
<ul>
<li>HTTP&#x2F;1.1：头部信息以纯文本发送，冗余较多</li>
<li>HTTP&#x2F;2.0：引入 HPACK 算法对头部进行压缩，显著减少传输数据量<br><strong>HPACK 算法</strong>：<ul>
<li><strong>静态表和动态表</strong>：<br>客户端和服务器各自维护一个<strong>静态表</strong>和<strong>动态表</strong>，用于存储常见的头部字段。<br>静态表包含预定义的常用头部，动态表则在通信过程中动态更新，记录已发送的头部字段。<br>通过引用这些表中的索引，可以避免重复传输相同的头部信息。</li>
<li><strong>哈夫曼编码</strong>：<br>HPACK 使用哈夫曼编码对头部字段进行压缩，将常用字符编码为更短的二进制序列，从而减少头部的大小。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器推送</strong></p>
<p><code>HTTP/2.0</code> 允许服务器主动推送页面相关资源给客户端，而不需要客户端明确请求，<br>避免了客户端请求和服务器响应之间的延迟，可以减少页面加载时间</p>
<ul>
<li>例如，客户端请求一个 HTML 页面时，服务器可以主动推送相关的 CSS、JavaScript 文件等资源，从而加快页面渲染速度</li>
</ul>
</li>
<li><p><strong>优先级和依赖</strong></p>
<p><code>HTTP/2.0</code> 允许客户端为请求设置优先级，并表达请求之间的依赖关系，资源加载更加有序</p>
</li>
</ul>
<h4 id="HTTP3-0有了解过吗？"><a href="#HTTP3-0有了解过吗？" class="headerlink" title="HTTP3.0有了解过吗？"></a>HTTP3.0有了解过吗？</h4><p>HTTP3.0基于 QUIC 协议，运行在UDP上，整合了TCP和TLS协议</p>
<p>应用层数据直接被封装成QUIC帧，<br>整合一个或多个帧，加上信息（<strong>连接 ID</strong>&#x2F;<code>Connection ID</code>）后被封装成一个 QUIC 数据包<br>QUIC 数据包被封装在 UDP 数据报中，通过网络传输</p>
<ul>
<li><strong>无队头阻塞</strong><ul>
<li>HTTP&#x2F;1.1没有解决响应的队头阻塞、HTTP&#x2F;2基于TCP 协议，<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong></li>
<li>HTTP3.0基于UDP 协议发送，<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong></li>
</ul>
</li>
<li><strong>零 RTT 连接建立</strong><ul>
<li>传输数据前的 QUIC 协议握手只需要 1 RTT，目的是为确认双方的「连接 ID」</li>
<li>QUIC 内部包含了 TLS</li>
<li>第二次连接时，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</li>
</ul>
</li>
<li><strong>连接迁移</strong><ul>
<li>网络环境发送改变（如Wifi—&gt;移动网络）时，通过确认<code>Connection ID</code>实现<strong>零 RTT 连接</strong></li>
</ul>
</li>
<li><strong>向前纠错机制</strong><ul>
<li>每个数据包还包括了部分其他数据包的数据，少量丢包无需重传</li>
</ul>
</li>
<li><strong>安全性</strong><ul>
<li>默认使用TLS加密</li>
</ul>
</li>
</ul>
<h3 id="Day05"><a href="#Day05" class="headerlink" title="Day05"></a>Day05</h3><h4 id="HTTPS和HTTP有哪些区别"><a href="#HTTPS和HTTP有哪些区别" class="headerlink" title="HTTPS和HTTP有哪些区别"></a>HTTPS和HTTP有哪些区别</h4><ul>
<li>HTTP 明文传输、TCP三次握手后建立连接传输报文，默认工作在80端口</li>
<li>HTTPS TCP三次握手后还需要进行SSL&#x2F;TLS的握手过程才能进入加密报文传输，默认工作在443端口<ul>
<li>需要向CA（证书权威机构）申请数字证书，来保证服务器身份可信</li>
</ul>
</li>
</ul>
<h4 id="HTTPS的工作原理-HTTPS建立连接的过程）"><a href="#HTTPS的工作原理-HTTPS建立连接的过程）" class="headerlink" title="HTTPS的工作原理(HTTPS建立连接的过程）"></a>HTTPS的工作原理(HTTPS建立连接的过程）</h4><p><code>HTTPS</code> 主要基于<code>SSL/TLS</code> 协议，确保数据传输的安全性和完整性</p>
<ol>
<li><p><strong>客户端向服务器请求加密通信</strong></p>
<ul>
<li>请求报文包括：<ul>
<li>客户端支持的TLS版本、支持的加密算法、随机数1（Client Random）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器选择一个客户端支持的加密算法</strong></p>
<ul>
<li>响应报文包括：<ul>
<li>CA证书：服务器的数字证书，由受信任的CA签发、<br>随机数2（Server Random）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>客户端验证证书合法性</strong></p>
<ul>
<li>使用数字证书中的公钥<strong>加密</strong>报文<br>报文内容包括：<ul>
<li>随机数3（预主密钥 Pre-Master Secret）：三个随机数生成 <strong>会话密钥&#x2F;主密钥（Master Secret）</strong></li>
<li>加密算法改变通知：之前使用会话密钥加密通话</li>
<li>结束握手通知、之前消息摘要校验值（用于服务器验证数据完整性）<ul>
<li>“加密算法改变通知”通常是通过<strong>ChangeCipherSpec</strong>消息发送，<br>而<strong>Finished</strong>消息则包含了整个握手过程的摘要，用于双方确认握手数据未被篡改。<br>这两个消息实际上是分开的，而不是合并在一个报文中。<ol>
<li>客户端生成并发送加密后的预主密钥（即ClientKeyExchange消息）。</li>
<li>客户端随后发送ChangeCipherSpec和Finished消息。</li>
<li><code>Tips</code>：<br>消息通常指应用层的数据单位，而报文是网络层的数据传输单位。<br>消息在传输过程中可能被分割成多个报文进行传输。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器生成会话密钥</strong></p>
<ul>
<li><p>服务器使用自己的私钥解密客户端发送的预主密钥，随后与客户端共同计算出主密钥，再派生出对称加密所需的各个子密钥。</p>
</li>
<li><p>发送内容：通知服务器后续加密、结束握手通知、之前消息摘要校验值（用于客户端验证数据完整性）</p>
<ul>
<li>后续加密的通知、结束握手通知和之前消息摘要校验值同样是两个消息分别发送的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据传输完成后销毁密钥</strong></p>
<ul>
<li>通信结束后双方应销毁会话密钥以防止长期使用造成安全风险。</li>
</ul>
</li>
</ol>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><ul>
<li><strong>TCP</strong> <ul>
<li><strong>面向连接</strong>：数据传输前需要建立连接（三次握手），确保通信双方的可靠连接</li>
<li><strong>可靠数据传输</strong>（保证顺序、完整性）：通过序列号、确认应答、重传机制等<ul>
<li>检测并重传丢失数据包</li>
</ul>
</li>
<li><strong>拥塞控制机制</strong>：根据网络状况调整发送速率</li>
<li><strong>滑动窗口机制</strong>：流量控制，保证对端能够处理发送的数据</li>
<li>报文头部复杂：TCP头部通常为20字节，包含序列号、确认号、窗口大小等多个字段</li>
</ul>
</li>
<li><strong>UDP</strong> <ul>
<li><strong>无连接</strong>：数据传输前不需要建立连接，发送方直接将数据包发送出去，接收方无需确认</li>
<li><strong>不可靠</strong>：UDP不提供数据包的确认、重传等机制，无法保证数据的顺序性和完整性，<br>           适用于对实时性要求高且能容忍一定数据丢失的应用。</li>
<li>发送速率恒定</li>
<li>头部报文相对简单，开销较小 ：<br>UDP头部只有8字节，包含源端口、目的端口、长度和校验和等基本信息，适合对速度和效率要求高的应用。</li>
</ul>
</li>
</ul>
<h3 id="Day06"><a href="#Day06" class="headerlink" title="Day06"></a>Day06</h3><h4 id="TCP连接如何确保可靠性"><a href="#TCP连接如何确保可靠性" class="headerlink" title="TCP连接如何确保可靠性"></a>TCP连接如何确保可靠性</h4><ul>
<li><strong>连接管理</strong>：三次握手、四次挥手</li>
<li><strong>差错控制</strong>：<ul>
<li><strong>序列号和确认应答机制</strong>：<br>每个数据包都被赋予唯一的序列号，接收方通过发送确认包（ACK）来告知发送方数据已成功接收。<br>发送方根据确认包的序列号来确认哪些数据已经收到，哪些还需要重新发送。</li>
<li><strong>超时重传机制</strong>：<br>如果发送方在一定时间内没有收到接收方的确认（ACK），它会重新发送未确认的数据包。<br>这确保了数据在丢包时能够重新传输。</li>
</ul>
</li>
<li><strong>流量控制</strong>：<br>TCP使用滑动窗口机制进行流量控制，确保接收方的缓冲区不被溢出。<br>接收方在ACK包中告诉发送方它能够接收的最大数据量，发送方根据这一信息调整数据发送速度。</li>
<li><strong>拥塞控制</strong>：TCP使用拥塞控制机制来动态调整发送速率，防止网络过载，</li>
</ul>
<h4 id="TCP-拥塞控制机制"><a href="#TCP-拥塞控制机制" class="headerlink" title="TCP 拥塞控制机制"></a>TCP 拥塞控制机制</h4><ul>
<li><p><strong>慢启动</strong>：<br>发送方维护一个拥塞窗口，窗口初始设为一个小的值（通常为1个最大报文段大小MSS）<br>每一经过一RTT窗口大小翻倍，达到阈值后进入拥塞避免阶段</p>
</li>
<li><p><strong>拥塞避免</strong> ：拥塞窗口大小达到阈值之后，增长方式由指数级增长变为线性增长</p>
</li>
<li><p><strong>快重传</strong> ：<br>接收方收到失序数据包时<strong>重复发送上一个数据包的ACK</strong><br>发送方收到<strong>三个重复的ACK</strong>后，认为发生了丢包，直接重传丢失的数据包，而不是等待超时</p>
</li>
<li><p><strong>快恢复</strong> ：<br>快重传之后，TCP不会回到慢启动阶段，而是将窗口大小设置为阈值的一半，然后继续线性增长</p>
</li>
</ul>
<h4 id="TCP-流量控制机制"><a href="#TCP-流量控制机制" class="headerlink" title="TCP 流量控制机制"></a>TCP 流量控制机制</h4><p><strong>流量控制的目的</strong></p>
<ul>
<li><strong>防止接收方过载</strong>：接收方有一定的缓冲区，当发送数据过快而接收方处理不过来时，就可能造成缓冲区溢出，从而丢失数据。</li>
<li><strong>保障数据正确接收</strong>：确保数据传输双方的速率匹配，使得接收方能够及时处理和确认收到的数据。</li>
</ul>
<p>TCP采用<strong>滑动窗口机制</strong>实现流量控制，<strong>TCP报文头中有一个“窗口大小”字段（16位）</strong>，<br>它由接收方计算并告知发送方，表示接收方当前可用的缓冲区大小。</p>
<ul>
<li>发送方发送，接收方更新，协商窗口大小</li>
<li>接收方将接收数据存入缓冲区，向上层应用提供数据处理</li>
<li>接收方定期发送确认报文，缓冲区快满时、减少窗口大小，缓冲区剩余空间较大时，增大窗口大小</li>
</ul>
<p>TCP流量控制主要是为了确保发送方不会以超过接收方处理能力的速率发送数据，从而防止接收方的缓冲区溢出和数据丢失。其基本实现原理和关键组件如下：</p>
<p><strong>流量控制与拥塞控制的区别</strong></p>
<ul>
<li><strong>流量控制</strong>：主要是点对点的机制，关注的是发送方与接收方之间的数据速率匹配，防止接收方缓冲区溢出。</li>
<li><strong>拥塞控制</strong>：则是端到端的机制，目的是防止整个网络中某个环节因数据量过大而导致拥塞、丢包及延迟增加。</li>
<li>在实际传输中，发送方的发送速率受两个因素的限制：<br>接收方通告的窗口大小（流量控制）和网络状况下的拥塞窗口（拥塞控制），<br>实际允许发送的数据量为两者的最小值。</li>
</ul>
<h4 id="UDP怎么实现可靠传输"><a href="#UDP怎么实现可靠传输" class="headerlink" title="UDP怎么实现可靠传输"></a>UDP怎么实现可靠传输</h4><p><strong>选择UDP原因</strong>：TCP在<strong>传输层</strong>实现可靠连接，存在问题：连接延迟、队头阻塞、网络迁移需要重新建立连接</p>
<p>UDP本身是无连接、不可靠的协议，但在需要可靠传输的场景下，可以在<strong>应用层</strong>自行实现类似TCP的可靠性机制。一般可以从以下两方面实现：</p>
<ul>
<li><strong>超时重传</strong><ul>
<li>为每个UDP数据报设计一个自定义首部，其中包含时间戳，用于测量数据报的往返时间（RTT），从而计算合适的重传超时时间（RTO）。</li>
<li>采用“等停（stop-and-wait）”方式发送数据报，即发送一个数据报后等待对端确认，确认收到后再发送下一个；若超过RTO未收到确认，则进行重传，同时将RTO扩大为原来的两倍，再次启动计时。</li>
</ul>
</li>
<li><strong>确认和序列号机制</strong><ul>
<li>在UDP数据报首部中增加确认序列号字段，标识当前数据报的序号。</li>
<li>对端在收到数据报后，提取时间戳和序列号，并构造确认报文（ACK）返回给发送方。</li>
<li>发送方收到确认后，就知道该数据报已正确到达；同时，对端根据序列号对收到的数据报进行排序，并丢弃重复的数据报，保证数据按序交付给上层应用。</li>
</ul>
</li>
</ul>
<p><strong>QUIC协议</strong><br>基于UDP协议，在应用层实现可靠传输，通过三次握手协商ConnectionID建立连接<br>（网络迁移时只需要确认ConnectionID，可实现0RTT建立连接）</p>
<h3 id="Day08"><a href="#Day08" class="headerlink" title="Day08"></a>Day08</h3><h4 id="TCP连接三次握手的过程，为什么是三次"><a href="#TCP连接三次握手的过程，为什么是三次" class="headerlink" title="TCP连接三次握手的过程，为什么是三次"></a>TCP连接三次握手的过程，为什么是三次</h4><p>TCP 采用 <strong>三次握手</strong> 主要是为了<br><strong>确保双方的发送和接收能力都正常</strong>，<br><strong>同步初始序列号（ISN），保证数据有序传输</strong>，<br><strong>防止旧的连接请求影响新连接</strong></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>发送方</th>
<th>报文类型</th>
<th>关键字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第一次握手</strong></td>
<td>客户端</td>
<td><strong>SYN</strong></td>
<td><code>SYN=1, seq=x</code></td>
<td>请求建立连接</td>
</tr>
<tr>
<td><strong>第二次握手</strong></td>
<td>服务器</td>
<td><strong>SYN+ACK（SYN-ACK）</strong></td>
<td><code>SYN=1, ACK=1, seq=y, ack=x+1</code></td>
<td>服务器同意连接</td>
</tr>
<tr>
<td><strong>第三次握手</strong></td>
<td>客户端</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, seq=x+1, ack=y+1</code></td>
<td>确认连接建立</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>第一次握手（SYN）</strong>：客户端 → 服务器：发送 <code>SYN（seq=x）</code>，表示希望建立连接，并携带 <strong>初始序列号（ISN）</strong></p>
<ul>
<li>客户端确认自己<strong>能发送数据</strong>，请求建立连接。<ul>
<li>✔️ 客户端知道自己 <strong>能发送数据</strong>（但不知道服务器能否接收）</li>
<li>❌ 客户端还不知道服务器的状态、服务器也不知道客户端是否能正常接收数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第二次握手（SYN+ACK）</strong>：服务器 → 客户端：返回 <code>SYN+ACK（SYN=1, ACK=1, seq=y, ack=x+1）</code>，<br>表示：<strong>ACK&#x3D;x+1</strong>：确认收到了客户端的 SYN，表明服务器 <strong>能接收</strong> 数据。<br>        <strong>SYN&#x3D;y</strong>：服务器也发送自己的 SYN，请求客户端确认服务器的状态。</p>
<ul>
<li>服务器确认自己能<strong>接收并发送</strong>，并请求客户端确认。<ul>
<li>✔️ 服务器知道自己 <strong>能接收</strong> 客户端的数据。</li>
<li>✔️ 服务器知道客户端 <strong>能发送</strong> 数据。</li>
<li>❌ 服务器还不知道客户端是否能接收数据、客户端也不知道服务器的数据是否能被自己正确接收。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第三次握手（ACK）</strong>：客户端 → 服务器：发送 <code>ACK（ACK=1, seq=x+1, ack=y+1）</code><br>表示：<strong>ACK&#x3D;y+1</strong>：确认收到了服务器的 SYN，说明客户端 <strong>能接收</strong> 数据。<strong>这一步之后，双方都确认了收发能力，连接正式建立！</strong></p>
<ul>
<li>客户端最终确认服务器的<strong>发送能力</strong>，确保连接正常。<ul>
<li>✔️ 客户端&#x2F;服务器 知道对方 <strong>能收发</strong> 数据 ，成功建立连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>为什么不能用两次握手？</strong></p>
<p>如果只用 两次握手<code>（SYN → SYN+ACK）</code>，可能会遇到 <strong>旧 SYN 报文导致的错误连接问题</strong>。</p>
<p><strong>问题：旧 SYN 报文导致连接异常</strong></p>
<ol>
<li>客户端 A 发送 <code>SYN</code> 请求，但网络延迟，未到达服务器。</li>
<li>客户端 A 以为服务器无响应，放弃连接，重新发送新的 <code>SYN</code>。</li>
<li>服务器此时收到<strong>旧的</strong> <code>SYN </code>请求，并误以为客户端要建立新连接，返回 <code>SYN+ACK</code>。</li>
<li>客户端 A 没有预期这次握手，可能直接忽略或返回 RST，导致服务器错误建立连接。</li>
</ol>
<p> <strong>三次握手可以避免这个问题</strong>：</p>
<ul>
<li>只有客户端 收到服务器的 <code>SYN+ACK</code>，并主动发送 <code>ACK</code>，服务器才会确认连接建立，从而避免误连接。</li>
</ul>
<p><strong>为什么不能用四次或更多次握手？</strong></p>
<p>三次握手已经足够确保双方的收发能力正常，额外的握手只会增加开销，没有额外收益，因此三次是最合理的方案。</p>
<h4 id="TCP连接四次挥手的过程，为什么是四次？"><a href="#TCP连接四次挥手的过程，为什么是四次？" class="headerlink" title="TCP连接四次挥手的过程，为什么是四次？"></a>TCP连接四次挥手的过程，为什么是四次？</h4><p>TCP 采用 <strong>四次挥手</strong> 主要是为了<br><strong>确保双方都能正常断开连接</strong><br><strong>让双方的数据传输完全结束，避免丢失</strong><br><strong>保证全双工通信中，双方都能独立关闭发送方向</strong></p>
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>发送方</strong></th>
<th><strong>报文类型</strong></th>
<th><strong>关键字段</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>第一次挥手</strong></td>
<td>客户端</td>
<td><strong>FIN</strong></td>
<td><code>FIN=1, seq=x</code></td>
<td>请求关闭连接</td>
</tr>
<tr>
<td><strong>第二次挥手</strong></td>
<td>服务器</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, ack=x+1</code></td>
<td>确认关闭请求</td>
</tr>
<tr>
<td><strong>第三次挥手</strong></td>
<td>服务器</td>
<td><strong>FIN</strong></td>
<td><code>FIN=1, seq=y</code></td>
<td>服务器请求关闭</td>
</tr>
<tr>
<td><strong>第四次挥手</strong></td>
<td>客户端</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, ack=y+1</code></td>
<td>确认服务器关闭</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>第一次挥手（客户端 → 服务器：FIN）</strong></p>
<ul>
<li>客户端 发送 <code>FIN（seq=x）</code>，表示自己 没有数据要发送了，请求关闭 发送方向。<br>客户端进入 <strong>FIN-WAIT-1状态</strong>，等待服务器确认。</li>
<li>客户端 –&gt; 服务器: <code>FIN, seq=x</code></li>
</ul>
</li>
<li><p><strong>第二次挥手（服务器 → 客户端：ACK）</strong></p>
<ul>
<li>服务器 发送 <code>ACK（ack=x+1）</code>，表示 收到了客户端的关闭请求，但仍可能有数据要发送。<br>服务器进入 <strong>CLOSE-WAIT 状态</strong>，继续处理剩余数据。<br>客户端进入 <strong>FIN-WAIT-2 状态</strong>，等待服务器关闭。</li>
<li>服务器 –&gt; 客户端: <code>ACK, ack=x+1</code></li>
</ul>
</li>
<li><p><strong>第三次挥手（服务器 → 客户端：FIN）</strong></p>
<ul>
<li>服务器 处理完所有数据后，发送<code> FIN（seq=y）</code>，请求关闭 发送方向。<br>服务器进入 <strong>LAST-ACK 状态</strong>，等待客户端的确认。</li>
<li>服务器 –&gt; 客户端: <code>FIN, seq=y</code></li>
</ul>
</li>
<li><p><strong>第四次挥手（客户端 → 服务器：ACK）</strong></p>
<ul>
<li>客户端 发送 <code>ACK（ack=y+1）</code>，确认服务器的关闭请求。<br>客户端进入 <strong>TIME-WAIT 状态</strong>，等待 <strong>2MSL</strong>（最大报文生存时间），确保服务器收到 <code>ACK</code> 后才完全释放连接。<br>服务器收到 ACK 后，进入 <strong>CLOSED 状态</strong>，彻底关闭连接。</li>
<li>客户端 –&gt; 服务器: <code>ACK, ack=y+1</code></li>
</ul>
</li>
</ul>
<p><strong>为什么需要四次挥手，而不是三次？</strong></p>
<p>TCP 是 <strong>全双工通信</strong>，<strong>数据的 发送和接收是独立的，所以需要分别关闭：</strong></p>
<p>前两次挥手：客户端请求关闭 发送通道，服务器确认<br>后两次挥手：服务器处理完剩余数据后，主动关闭 发送通道，客户端确认</p>
<p><strong>如果只用 三次挥手：</strong></p>
<p>服务器如果 还未发送完数据 就直接关闭，可能导致<strong>数据丢失</strong>。</p>
<p><strong>TIME-WAIT 状态与 2MSL 等待期</strong><br>TIME-WAIT 作用</p>
<ul>
<li>确保服务器收到最终的 <code>ACK</code><br>如果服务器没有收到 <code>ACK</code>，它会超时重发<code> FIN</code>，<strong>TIME-WAIT</strong> 允许客户端 重新发送 <code>ACK</code>。</li>
<li>防止旧连接数据干扰新连接<br>旧连接的数据可能在网络中滞留，<strong>TIME-WAIT</strong> 确保这些数据在新连接建立前被丢弃。</li>
</ul>
<p><strong>为什么等待 2MSL？</strong></p>
<p><strong>MSL</strong>（Maximum Segment Lifetime） 是一个 TCP 报文在网络中的最长存活时间。<br>等待 2MSL 确保网络中 所有旧数据包都已消失，避免影响新连接。</p>
<h4 id="HTTP的Keep-Alive是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？"><a href="#HTTP的Keep-Alive是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？" class="headerlink" title="HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？"></a>HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</h4><ul>
<li><p><strong>HTTP Keep-Alive</strong>	 <strong>HTTP 应用层</strong>。</p>
<ul>
<li>HTTP 的 <strong>Keep-Alive</strong> 机制允许 <strong>在同一个 TCP 连接上发送多个 HTTP 请求和响应</strong>，而不是在每个请求后都关闭 TCP 连接。</li>
<li><strong>目的</strong><ul>
<li>减少 TCP 连接的建立和关闭开销**，避免频繁的三次握手（建立连接）和四次挥手（关闭连接）。**</li>
<li>提高 HTTP 请求的性能**，减少请求延迟，提高服务器的吞吐量。**</li>
<li>减少服务器资源消耗，降低 CPU 和内存开销。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>TCP Keepalive</strong>    <strong>TCP 传输层</strong></p>
<ul>
<li>TCP 的 <strong>Keepalive 机制不是用来复用连接的，而是用于检测 TCP 连接是否仍然存活</strong>。当一个 TCP 连接长时间没有数据传输时，TCP Keepalive <strong>定期发送探测包</strong>，检查对端是否仍然在线，以避免资源浪费。</li>
<li><strong>目的</strong><ul>
<li><strong>检测并清理无效的 TCP 连接</strong>，防止服务器资源被僵尸连接占用。</li>
<li><strong>保持 NAT 设备中的 TCP 连接映射有效</strong>，防止 NAT 设备因长时间无数据而丢弃连接。</li>
</ul>
</li>
<li><strong>TCP Keepalive 的工作方式</strong><ul>
<li><strong>TCP 连接长时间没有数据传输</strong>（默认 2 小时）。<strong>内核发送 Keepalive 探测包</strong>，询问对方是否存活。</li>
<li><strong>如果对方正常响应</strong>，连接继续保持。<strong>如果连续多次探测无响应</strong>（如 3 次），TCP 认为对端失效，关闭连接。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>HTTP Keep-Alive 和 TCP Keepalive 的区别</strong></p>
<ul>
<li><strong>核心区别</strong><ul>
<li><strong>HTTP Keep-Alive 解决的是“重复建立连接的问题”</strong>，避免 HTTP 请求频繁创建新 TCP 连接。</li>
<li><strong>TCP Keepalive 解决的是“连接是否还存活的问题”</strong>，防止僵尸连接占用系统资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>机制</th>
<th>作用</th>
<th>适用协议</th>
<th>作用层次</th>
<th>触发方式</th>
<th>典型使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HTTP Keep-Alive</strong></td>
<td>复用 TCP 连接，减少握手开销</td>
<td>HTTP</td>
<td><strong>应用层</strong></td>
<td>HTTP 头部 <code>Connection: Keep-Alive</code></td>
<td>加速 HTTP 访问，减少 TCP 连接消耗</td>
</tr>
<tr>
<td><strong>TCP Keepalive</strong></td>
<td>检测 TCP 连接是否存活，防止僵尸连接</td>
<td>TCP</td>
<td><strong>传输层</strong></td>
<td>操作系统定期发送探测包</td>
<td>服务器维护长连接，检测对端是否存活</td>
</tr>
</tbody></table>
<h3 id="Day09"><a href="#Day09" class="headerlink" title="Day09"></a>Day09</h3><h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><p>DNS基本概念</p>
<ul>
<li><strong>DNS是什么？</strong><br>域名系统（Domain Name System）是将易记的域名（例如 <a target="_blank" rel="noopener" href="http://www.example.com)转换为计算机能识别的ip地址(例如/">www.example.com）转换为计算机能识别的IP地址（例如</a> 192.0.2.1）的分布式数据库系统。它类似于互联网的“电话簿”，使我们无需记住数字地址即可访问网站。</li>
<li><strong>DNS的作用</strong><br>DNS使得互联网用户可以通过友好的域名访问网站、邮件服务器等，同时提供一定的负载均衡和容错能力。</li>
</ul>
<p><strong>DNS查询的基本流程</strong></p>
<p><strong>用户发起请求</strong><br>当你在浏览器中输入一个URL时，操作系统和浏览器会检查各自的DNS缓存（以及Hosts文件），<br>如果已经存在该域名对应的IP地址，解析过程会立即结束；<br>如果没有命中，则向配置的本地域名解析器（DNS Resolver）发送请求。</p>
<p><strong>本地域名解析器处理请求（递归查询）</strong><br>本地DNS服务器通常采用递归查询方式，它负责替客户端查找最终的IP地址。<br>（<strong>递归查询</strong>由本地域名解析器替客户端完成所有查询过程，简化了客户端的操作。）</p>
<p>若自身缓存中没有记录，它会依次向其他DNS服务器发起查询。</p>
<p><strong>迭代查询过程</strong><br>本地域名解析器会按照以下步骤依次查询：</p>
<ul>
<li><strong>查询根DNS服务器</strong>：<br>根服务器不会返回具体的IP地址，而是告诉解析器该查询应转发到哪个顶级域（如.com、.net、.org）的DNS服务器。</li>
<li><strong>查询顶级域名服务器</strong>：<br>利用根服务器返回的信息，本地解析器向对应的顶级域名服务器发出查询。<br>顶级域名服务器同样不会直接返回目标IP，而是指向负责该域名的权威DNS服务器。</li>
<li><strong>查询权威DNS服务器</strong>：<br>本地DNS解析器最终向权威DNS服务器发送查询请求，权威服务器并返回具体的IP地址。<br>（权威DNS服务器是负责存储特定域名和IP地址映射的服务器）</li>
</ul>
<p><strong>返回结果</strong><br>得到IP地址后，本地域名解析器将结果缓存（以便下次查询更快响应），并将IP地址返回给客户端，浏览器随后使用该IP地址发起HTTP请求访问网站。</p>
<h4 id="CDN是什么，有什么作用？"><a href="#CDN是什么，有什么作用？" class="headerlink" title="CDN是什么，有什么作用？"></a>CDN是什么，有什么作用？</h4><p>CDN（内容分发网络）是一种由遍布全球各地的边缘服务器组成的分布式网络系统，<br>其核心目的是将网站的静态资源（如图片、CSS、JavaScript文件等）缓存在离用户最近的节点上，从而加速内容加载，降低延迟，提高网站性能和用户体验。</p>
<p><strong>工作原理</strong></p>
<ol>
<li><strong>用户请求</strong><br> 当用户在浏览器中请求某个网站时，DNS系统会将请求解析到CDN网络中离用户最近的<strong>边缘服务器</strong>。<ul>
<li><strong>调度系统</strong><br>通过DNS解析或Anycast技术，把用户请求引导到最优的CDN节点</li>
<li><strong>边缘服务器&#x2F;PoP（Point of Presence）</strong><br>分布在各地的节点，负责缓存内容并快速响应用户请求。</li>
</ul>
</li>
<li><strong>缓存内容</strong><ul>
<li><strong>边缘缓存</strong>：如果该边缘服务器已缓存了所需内容，则直接返回给用户，无需每次都访问源站。</li>
<li><strong>回源请求</strong>：如果缓存中没有，则边缘服务器会向源站（Origin Server）请求内容，并将获取到的内容缓存起来，以便后续请求使用。<ul>
<li><strong>缓存策略</strong><ul>
<li><strong>TTL（生存时间）</strong>：决定缓存内容在边缘节点中存留多久。</li>
<li><strong>缓存失效与更新策略</strong>：确保内容及时更新，比如通过主动刷新、定时更新或基于内容变更的触发机制。</li>
<li><strong>分层缓存</strong>：结合多级缓存结构，使不同类型的内容（静态与动态）能够有效缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>可用性</strong>：即使某些节点出现问题，用户请求可以被重定向到其他健康的节点。</li>
</ol>
<p><strong>主要优势与作用</strong></p>
<ul>
<li><strong>提升访问速度</strong><br> 用户可以从最近的节点获取内容，大幅降低延迟，加快页面加载速度。</li>
<li><strong>减轻源站压力</strong><br> 大量静态资源由CDN节点分担，源站不需要处理所有流量，降低服务器负载。</li>
<li><strong>提高可靠性与可用性</strong><br> 多个节点分布在全球，即使部分节点发生故障，其他节点仍能提供服务，增强整体稳定性。</li>
<li><strong>防御DDoS攻击</strong><br> 分布式架构能够吸收并分散恶意流量，提升抗攻击能力。</li>
<li><strong>改善用户体验</strong><br> 快速加载和更稳定的连接使用户获得更流畅的浏览体验，进而提高网站转化率和满意度。</li>
</ul>
<h4 id="Cookie和Session是什么？有什么区别？"><a href="#Cookie和Session是什么？有什么区别？" class="headerlink" title="Cookie和Session是什么？有什么区别？"></a>Cookie和Session是什么？有什么区别？</h4><ul>
<li><p><strong>Cookie</strong></p>
<ul>
<li>客户端&#x2F;浏览器发起HTTP请求后服务器通过 HTTP 响应头设置<code>Set-Cookie</code>值，<br>由服务器将一个或多个<code> Cookie</code> 发送到用户浏览器，然后浏览器将这些 <code>Cookie</code> 存储在本地。<br>服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的<code>Cookie</code>得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</li>
<li><code>Cookie</code>  存储容量较小，一般为几 KB<br>生命周期由服务器设置，通过HTTP请求自动发送</li>
<li>易被窃取、篡改、有传输风险（中间人截获）—&gt; HTTPS</li>
<li>存储小量非敏感信息，如用户个性化设置，临时状态等</li>
</ul>
</li>
<li><p><strong>Session</strong></p>
<ul>
<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是<code>Session</code>。（<code>Session</code>  数据存储在服务器上）</li>
<li>存储容量较大，通常没有固定限制，取决于服务器的配置和资源。<br>生命周期由服务器管理（默认与会话相关，通常在浏览器关闭后失效）<br><code>Session ID</code>  通常通过<code> Cookie</code>  或 URL 参数传递</li>
<li>Session 数据存储在服务器上，更难被用户访问和修改<br>（攻击者获取Session后也有可能冒充用户）</li>
<li>Session主要用于存储用户登录状态及权限信息、保存敏感数据和状态管理（在多步操作或交易中，存储临时数据，确保数据一致性）等</li>
</ul>
</li>
</ul>
<h3 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h3><h4 id="进程和线程之间有什么区别"><a href="#进程和线程之间有什么区别" class="headerlink" title="进程和线程之间有什么区别"></a>进程和线程之间有什么区别</h4><ul>
<li><strong>进程</strong><ul>
<li>进程是<strong>操作系统进行资源分配和调度的基本单位</strong>，<br><strong>每个进程拥有独立的内存空间、代码段、数据段以及系统资源。</strong></li>
<li><strong>独立内存空间</strong>：每个进程都有自己独立的地址空间，因此在创建和销毁时需要分配或回收较多资源，开销较大。<br><strong>上下文切换开销</strong>：进程切换时需要保存和恢复整个进程的状态，导致上下文切换开销较高。</li>
<li><strong>进程间通信（IPC）</strong>：由于进程相互隔离，通信必须依赖专门的机制，如管道、消息队列、共享内存等，这使得进程间通信相对复杂。</li>
<li><strong>隔离性高</strong>：进程之间相互隔离，一个进程的崩溃一般不会影响到其他进程，因而整体安全性和稳定性较好。</li>
</ul>
</li>
<li><strong>线程</strong><ul>
<li>线程是<strong>程序执行的最小单位</strong>，是进程内的执行单元。<br><strong>一个进程至少包含一个线程，也可以拥有多个线程，这些线程共享进程内的内存空间和资源</strong></li>
<li><strong>共享内存空间</strong>：同一进程中的所有线程共享内存和其他资源，因此创建和销毁线程的成本较低。<br><strong>轻量级切换</strong>：线程之间的切换只需保存少量的上下文信息，上下文切换速度快。</li>
<li><strong>直接共享数据</strong>：同一进程内的线程可以直接访问共享内存，因此线程间通信更为方便。但这种共享也可能引发数据竞争，需要使用互斥锁、信号量等同步机制进行协调。</li>
<li><strong>风险共享</strong>：由于同一进程内的线程共享内存和资源，一个线程出现错误（如非法内存访问）可能导致整个进程崩溃，从而影响系统稳定性。</li>
</ul>
</li>
</ul>
<p>在实际应用中，<br>如果需要高度的安全性和资源隔离，使用进程会更合适；<br>而如果追求高效的并发和轻量级的切换，线程则是更好的选择。</p>
<h4 id="并行和并发有什么区别"><a href="#并行和并发有什么区别" class="headerlink" title="并行和并发有什么区别"></a>并行和并发有什么区别</h4><p><strong>并行</strong>：</p>
<ul>
<li>同一时刻执行多个任务，在<strong>物理上</strong>同时执行。</li>
<li>需要多核 CPU 或多台计算机，每个核心或计算节点独立执行不同的任务。</li>
<li>并行旨在缩短任务的执行时间。</li>
<li>并行通过增加处理单元、同时执行多个任务来提高处理能力，<br>显著缩短总的执行时间，但需要考虑任务间的同步和通信开销。</li>
<li><strong>应用场景</strong>：适用于计算密集型任务，如科学计算、图像处理等，需要将大任务分解为可并行执行的子任务。</li>
<li>需要将任务有效地分解为独立的子任务，并处理任务间的协调和数据共享，增加了编程的复杂性。</li>
</ul>
<p><strong>并发</strong>：</p>
<ul>
<li>相同的时间段内执行多个任务，任务可能交替执行，通过调度实现，在<strong>逻辑上</strong>同时处理。</li>
<li>不要求物理上真正同时执行。例如，单核 CPU 通过任务切换来执行多个任务，使其看起来是同时运行的。</li>
<li>并发旨在提高资源利用率和系统吞吐量</li>
<li>通过共享资源（如CPU时间）、减少任务的等待时间，来提高系统的响应速度，<br>但频繁的上下文切换可能带来开销。</li>
<li><strong>应用场景</strong>：适用于需要同时处理大量任务且任务之间可能存在交互的场景，如Web服务器需要同时处理多个客户端请求。</li>
<li>需要处理任务间的同步和资源竞争问题，可能导致死锁、竞态条件等复杂情况。</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>并发（Concurrency）</th>
<th>并行（Parallelism）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>任务<strong>交替执行</strong>，宏观上同时进行</td>
<td>任务<strong>真正同时执行</strong></td>
</tr>
<tr>
<td><strong>依赖硬件</strong></td>
<td>不需要多核，单核也能并发</td>
<td>需要多核或多机</td>
</tr>
<tr>
<td><strong>执行方式</strong></td>
<td>任务<strong>切换</strong>执行</td>
<td>任务<strong>同时</strong>执行</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>I&#x2F;O 密集型任务，如 Web 服务器处理多个请求</td>
<td>CPU 密集型任务，如深度学习计算</td>
</tr>
<tr>
<td><strong>实现难度</strong></td>
<td>需要线程管理、同步机制</td>
<td>需要高性能硬件、数据分割</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Python 中的 <code>asyncio</code>，Java 多线程</td>
<td>OpenMP、CUDA 并行计算</td>
</tr>
</tbody></table>
<ul>
<li><strong>并发可以实现并行</strong>：在多核 CPU 或分布式环境下，并发任务可以被调度到不同核心或机器上，形成真正的并行执行。</li>
<li><strong>并行通常包含并发</strong>：并行任务可能需要协调、通信，而协调机制通常涉及并发编程。</li>
</ul>
<h4 id="解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？"><a href="#解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？" class="headerlink" title="解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？"></a>解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？</h4><p>用户态和内核态是 CPU 的两种运行模式，主要用于<strong>保护系统资源和控制访问权限</strong>。</p>
<ul>
<li><strong>用户态</strong>：<ul>
<li>普通应用程序运行的环境，权限受限，不能直接访问硬件。</li>
<li>只能执行普通指令，若需要访问操作系统资源，必须通过<strong>系统调用</strong>进入内核态。</li>
</ul>
</li>
<li><strong>内核态</strong>：<ul>
<li>操作系统内核运行的环境，拥有最高权限，可直接管理<strong>进程、内存、I&#x2F;O 设备</strong>等。</li>
<li>允许执行特权指令，如<strong>控制硬件、修改内存管理单元（MMU）状态</strong>等。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>用户态（User Mode）</th>
<th>内核态（Kernel Mode）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>特权级别</strong></td>
<td>低（受限制）</td>
<td>高（完全访问权限）</td>
</tr>
<tr>
<td><strong>执行主体</strong></td>
<td>应用程序</td>
<td>操作系统内核</td>
</tr>
<tr>
<td><strong>访问硬件</strong></td>
<td>不能直接访问</td>
<td>可直接操作硬件</td>
</tr>
<tr>
<td><strong>指令权限</strong></td>
<td>仅普通指令</td>
<td>可执行特权指令</td>
</tr>
<tr>
<td><strong>稳定性</strong></td>
<td>高（程序崩溃不影响系统）</td>
<td>低（内核崩溃导致系统崩溃）</td>
</tr>
</tbody></table>
<p><strong>用户态和内核态的切换场景</strong></p>
<p>CPU 运行时，可能因以下原因从用户态切换到内核态：</p>
<ol>
<li><strong>系统调用（System Call）</strong><ul>
<li>当用户进程需要操作文件、访问网络、分配内存等，需要调用操作系统提供的服务。<br>例如 <code>read()</code>, <code>write()</code>, <code>open()</code> 等函数，最终会触发软中断（Trap），CPU 切换到内核态执行内核代码。</li>
</ul>
</li>
<li><strong>异常（Exception）</strong><ul>
<li>当用户程序执行非法操作（如除零、访问非法内存）时，CPU 触发异常，进入内核态，交由操作系统处理。</li>
</ul>
</li>
<li><strong>中断（Interrupt）</strong><ul>
<li>外设（键盘、网络、磁盘等）发送中断信号，CPU 停止当前任务，切换到内核态执行中断处理程序（ISR）。</li>
<li>例如：<ul>
<li>键盘输入触发中断，CPU 进入内核态读取输入数据。</li>
<li>磁盘 I&#x2F;O 完成后触发中断，通知操作系统数据已准备就绪。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><strong>用户态：</strong> 运行普通应用，权限受限，不能直接访问硬件。</li>
<li><strong>内核态：</strong> 运行操作系统，完全控制系统资源，可直接访问硬件。</li>
<li><strong>切换场景：</strong> 通过<strong>系统调用、异常、中断</strong>切换到内核态。</li>
</ul>
<h3 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h3><h4 id="进程调度算法你了解多少"><a href="#进程调度算法你了解多少" class="headerlink" title="进程调度算法你了解多少"></a>进程调度算法你了解多少</h4><ol>
<li><strong>先来先服务（FCFS）</strong>：<ul>
<li><strong>特点</strong>：按照进程的到达顺序进行调度，最简单的调度算法。</li>
<li><strong>缺点</strong>：由于没有考虑进程的运行时间，可能会导致长作业占用CPU较长时间，导致短作业的等待时间过长，产生“convoy effect”。</li>
</ul>
</li>
<li><strong>最短作业优先（SJF）</strong>：<ul>
<li><strong>特点</strong>：非抢占式调度，优先调度估计运行时间最短的进程。</li>
<li><strong>缺点</strong>：需要知道进程的运行时间，且可能导致长作业永远得不到调度，出现“饥饿”现象。实际系统中通常采用估算方法来解决这个问题。</li>
</ul>
</li>
<li><strong>最短剩余时间优先（SRTF）</strong>：<ul>
<li><strong>特点</strong>：基于最短作业优先（SJF）的抢占式调度算法。每当一个新的进程到达时，比较其剩余运行时间与当前正在执行进程的剩余时间。如果新进程的剩余时间更短，当前进程被挂起，转而执行新进程。</li>
<li><strong>缺点</strong>：可能导致频繁的上下文切换，增加系统开销。</li>
</ul>
</li>
<li><strong>优先级调度（Priority Scheduling）</strong>：<ul>
<li><strong>特点</strong>：每个进程都有一个优先级，系统根据优先级来决定调度顺序。高优先级的进程会优先执行。</li>
<li><strong>缺点</strong>：可能会导致低优先级进程“饥饿”，即长时间无法获得调度。为了解决这个问题，通常会引入优先级提升机制，使等待时间过长的进程逐渐获得更高的优先级。</li>
</ul>
</li>
<li><strong>时间片轮转（RR）</strong>：<ul>
<li><strong>特点</strong>：每个进程轮流执行，分配一个固定的时间片。当时间片用完后，进程会被挂起，调度下一个进程执行，直到所有进程执行完毕。</li>
<li><strong>缺点</strong>：如果时间片设置过大，可能导致响应时间较长；如果时间片设置过小，频繁的上下文切换会增加系统开销。</li>
</ul>
</li>
<li><strong>多级队列（Multilevel Queue Scheduling）</strong>：<ul>
<li><strong>特点</strong>：将进程按照优先级分为多个队列，不同队列使用不同的调度算法。例如，高优先级队列使用时间片轮转调度，而低优先级队列使用先来先服务（FCFS）等。</li>
<li><strong>优点</strong>：可以在不同类型的任务间进行合理的调度，确保高优先级任务不会被低优先级任务干扰。</li>
<li><strong>缺点</strong>：由于每个队列使用不同的调度算法，可能导致进程之间的切换较为复杂。</li>
</ul>
</li>
</ol>
<h4 id="进程间有哪些通信方式-进程间通信（IPC）"><a href="#进程间有哪些通信方式-进程间通信（IPC）" class="headerlink" title="进程间有哪些通信方式 &#x2F; 进程间通信（IPC）"></a>进程间有哪些通信方式 &#x2F; 进程间通信（IPC）</h4><ol>
<li><strong>管道（Pipe）</strong><ul>
<li>半双工，只能实现单向数据流动；用于父子进程或具有血缘关系的进程间通信。<br>常见于命令行中多个命令的连接，例如 <code>ls | grep txt</code>。<ul>
<li>半双工（Half-duplex）通信方式：<br>通信双方都能发送和接收数据，但同一时间只能有一个方向在传输数据，不能同时进行双向通信。</li>
</ul>
</li>
</ul>
</li>
<li><strong>命名管道（FIFO）</strong><ul>
<li>与管道类似，同样是半双工，但由于它有名字，可以在不相关的进程之间通信（无需进程之间的血缘关系）<br>常用于需要临时建立进程间数据传递通道的场景</li>
</ul>
</li>
<li><strong>消息队列</strong><ul>
<li>内核维护一个消息链表，允许进程发送格式化的消息，并支持消息优先级；通信是异步的。<br>适用于客户端—服务器模式和复杂的事件传递场景。</li>
</ul>
</li>
<li><strong>信号</strong><ul>
<li>用于向进程发送异步通知，告知某种事件的发生，通常只传递信号编号；处理函数要求尽可能简单。<br>处理用户中断（例如Ctrl+C）、定时器事件或其他异常情况。</li>
</ul>
</li>
<li><strong>信号量</strong><ul>
<li>作为计数器使用，控制多个进程或线程对共享资源的访问，通常用来实现互斥和同步。<br>解决<strong>生产者-消费者问题</strong>、资源管理和进程同步问题。</li>
</ul>
</li>
<li><strong>共享内存</strong><ul>
<li>将一段内存映射到多个进程的地址空间中，实现高速数据共享；<br>但必须借助同步机制（如互斥锁、信号量）避免竞态条件。<br>适用于大数据量、高性能的通信场景，如实时数据处理和数据库缓存。</li>
</ul>
</li>
<li><strong>Socket套接字</strong><ul>
<li>全双工，支持TCP&#x2F;IP 的网络通信的基本操作单元，<br>主要用于在客户端和服务器之间通过网络进行通信、网络应用开发以及分布式系统</li>
</ul>
</li>
</ol>
<p><strong>安全问题与预防</strong></p>
<ul>
<li><strong>竞态条件</strong>：多个进程同时访问共享数据时，若没有适当的同步机制（如互斥锁或信号量），数据可能会因操作顺序不确定而出错。<br><strong>预防</strong>：在共享内存等方式中使用锁机制或原子操作，确保临界区内操作互斥执行。</li>
<li><strong>死锁</strong>：当多个进程相互等待对方释放资源时，会导致所有进程永远阻塞。<br> <strong>预防</strong>：<ul>
<li>遵循固定顺序申请资源，避免循环等待；</li>
<li>使用超时机制，在无法获取资源时及时放弃重试；</li>
<li>尽量缩小临界区，减少持锁时间。</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li><strong>简单数据传输</strong>：使用<strong>管道</strong>或<strong>命名管道</strong>。</li>
<li><strong>异步消息传递</strong>：使用<strong>消息队列</strong>进行复杂的进程间通信。</li>
<li><strong>高性能数据共享</strong>：<strong>共享内存</strong>是最快的方式，但需要额外的同步控制。</li>
<li><strong>网络通信</strong>：使用<strong>Socket</strong>进行客户端与服务器间的数据交换。</li>
</ul>
<h4 id="解释一下进程同步和互斥，以及如何实现进程同步和互斥"><a href="#解释一下进程同步和互斥，以及如何实现进程同步和互斥" class="headerlink" title="解释一下进程同步和互斥，以及如何实现进程同步和互斥"></a>解释一下进程同步和互斥，以及如何实现进程同步和互斥</h4><p>进程同步和互斥是确保多个并发执行的进程或线程在访问共享资源时<br>不会产生数据错误和逻辑冲突的两种关键机制。</p>
<p><strong>进程同步</strong></p>
<ul>
<li>进程同步指的是多个并发执行的进程之间协调和管理它们的执行顺序或执行时机，<br> 以保证它们按照预期的顺序或时间间隔执行。<br> 这对于一些依赖于前后顺序的操作（例如生产者消费者问题）尤为重要。</li>
<li>主要目的是保证<strong>数据一致性</strong>和<strong>程序正确性</strong>，即确保在某些操作发生前，必须满足特定条件或顺序。<br> 例如，消费者在取出数据之前，必须等待生产者将数据写入缓冲区。</li>
</ul>
<p><strong>互斥</strong></p>
<ul>
<li>互斥指的是在某一时刻只允许一个进程（或线程）访问某个共享资源，<br> 防止多个进程同时进入临界区，从而避免数据竞争（Race Condition）。</li>
<li>主要是保证共享资源（如共享内存、全局变量、文件等）在同一时间内不被多个进程同时修改，确保<strong>操作的原子性</strong>和<strong>数据的完整性</strong>。</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li><p><strong>信号量和 PV 操作</strong></p>
<ul>
<li><p><strong>信号量</strong>：特殊的变量，用来表示系统中某种资源的数量或状态。</p>
</li>
<li><p><strong>PV操作</strong></p>
<ul>
<li><strong>P操作（“检查”信号量）</strong>：进入临界区前。如果信号量的值大于0，则将其减1并允许进程进入；若为0，则进程将被阻塞，等待资源释放。</li>
<li><strong>V操作（“归还”资源）</strong>：退出临界区时，将信号量的值加1，并唤醒因P操作而阻塞的进程。</li>
</ul>
</li>
<li><p>这种机制既可以实现<strong>互斥</strong>（当信号量初始值为1时，相当于互斥锁），也可以<strong>控制有限资源的访问</strong>（计数信号量）。</p>
</li>
</ul>
</li>
<li><p><strong>临界区与互斥锁（Mutex）</strong></p>
<ul>
<li><strong>临界区</strong>：<br>访问共享资源的代码段 &#x2F; 可能引发互斥问题的代码。<br>在进入临界区前，必须先获取相应的锁（互斥锁）；离开时释放锁，<br>从而保证同一时刻只有一个进程能够执行临界区内的代码。</li>
<li><strong>互斥锁</strong>：<br>每个共享资源都关联一个互斥锁，只有获得该锁的进程才能进入临界区访问资源。<br>互斥锁是一种常用的实现互斥的方法，其工作原理简单且直观。</li>
</ul>
</li>
<li><p><strong>条件变量</strong></p>
<ul>
<li><strong>条件变量</strong>：<br>条件变量通常与互斥锁配合使用，并采用<code>while循环</code>检查条件以防止假唤醒。<br>用于让进程在特定条件下（例如缓冲区非空或非满）<strong>等待&#x2F;进入阻塞状态</strong> 或 被<strong>唤醒</strong>。</li>
<li>在临界区内，进程检查某一条件是否满足，如果不满足，则调用等待操作（例如<code>wait()</code>），这会自动释放互斥锁并将进程挂起；<br>当其他进程改变了共享状态后，调用通知操作（例如<code>signal()</code>或<code>notify()</code>），唤醒等待的进程，然后重新获得互斥锁继续执行。</li>
</ul>
</li>
</ul>
<h3 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h3><h4 id="什么是死锁，如何避免死锁？"><a href="#什么是死锁，如何避免死锁？" class="headerlink" title="什么是死锁，如何避免死锁？"></a>什么是死锁，如何避免死锁？</h4><p>系统中多个进程&#x2F;线程分别持有部分资源，且<strong>相互等待</strong>其他进程释放它们所需的资源而造成的一种僵局</p>
<p><strong>死锁同时满足四个条件，破坏其一即可预防</strong></p>
<ul>
<li><strong>互斥条件</strong>：资源不能被多个进程共享<ul>
<li>某些资源（如读操作）可以设计为共享模式，降低互斥资源的使用场景</li>
</ul>
</li>
<li><strong>请求保持条件</strong>：进程在等待新的资源而阻塞时不会释放自己的资源。<ul>
<li>采用一次性申请策略：<br>进程在开始执行前一次性申请所有需要的资源；<br>若无法全部获得，则不占有任何资源，待所有资源可用时再执行。</li>
<li>或者采用动态释放策略：<br>在申请资源时如果发现无法一次性满足所有资源要求，<br>则释放当前已占用资源，等待一段时间后重试。</li>
</ul>
</li>
<li><strong>不可剥夺条件</strong>：资源在未使用完之前，不能被操作系统&#x2F;其他进程强制收回，只能由进程自己释放。<ul>
<li>资源分配时允许抢占：<br>进程请求新资源而系统检测到可能发生死锁时，可暂时剥夺其他进程占用的部分资源分配给请求者</li>
</ul>
</li>
<li><strong>循环等待条件</strong>：系统中存在进程循环链，每个进程都在等待链中下一个进程所占有的资源，形成闭环。<ul>
<li>为所有资源设定一个全局的顺序：<br>要求所有进程按照相同顺序申请资源，防止形成循环等待。<br>例如，规定进程申请资源时必须先申请编号较小的，再申请编号较大的资源，避免出现闭环等待。</li>
</ul>
</li>
</ul>
<p><strong>无法完全预防死锁的情况下，系统可以采用检测与恢复机制</strong></p>
<ul>
<li><p><strong>死锁检测</strong></p>
<ul>
<li><strong>资源分配图检测</strong>：构建资源分配图或等待图，定期检查是否存在环路。若存在闭环，则说明可能发生了死锁。</li>
<li><strong>银行家算法</strong>：通过模拟资源分配过程来判断系统是否进入不安全状态。</li>
</ul>
</li>
<li><p><strong>死锁解除</strong>：一旦检测到死锁，可以采取如下措施解除：</p>
<ul>
<li><strong>进程中止</strong>：选择中止一个或多个处于死锁状态的进程，以打破循环等待。</li>
<li><strong>资源抢占</strong>：强制收回某些进程已经占用的资源，使系统重新恢复到安全状态。</li>
<li><strong>回滚机制</strong>：事务性系统中，通过回滚部分操作来释放资源，重新执行操作，确保系统数据一致性。</li>
</ul>
</li>
</ul>
<h4 id="介绍一下几种典型的锁"><a href="#介绍一下几种典型的锁" class="headerlink" title="介绍一下几种典型的锁"></a>介绍一下几种典型的锁</h4><p><strong>互斥锁</strong>：</p>
<ul>
<li><p>任何时刻只有一个线程能够进入临界区访问&#x2F;修改资源。<br>其他线程等待该锁释放后获取，保证<strong>资源的一致性</strong>。</p>
</li>
<li><p><strong>优点</strong>：实现简单，能有效防止数据并发修改引发的不一致问题。<br><strong>缺点</strong>：但在高并发场景下容易引起线程阻塞和上下文切换，进而影响系统性能。</p>
</li>
<li><p><strong>适用场景</strong></p>
<ul>
<li>需要独占访问共享数据的场合（如写操作）、</li>
<li>数据竞争较严重的环境。</li>
</ul>
</li>
</ul>
<p><strong>自旋锁</strong></p>
<ul>
<li>自旋锁与互斥锁的作用类似，都用于保护共享资源。<br>但自旋锁获取不到锁时不会让线程进入睡眠状态，<br>而是采用忙等待（busy waiting）的方式<strong>不断轮询</strong>锁的状态，直到锁可用。</li>
<li><strong>优点</strong>：避免了线程切换带来的开销，延迟较低。<br><strong>缺点</strong>：如果锁等待时间较长，会占用CPU资源，导致资源浪费；在单核系统上效果较差。</li>
<li><strong>适用场景</strong><ul>
<li>持锁时间非常短的临界区，能降低线程切换的开销、</li>
<li>多核处理器环境中，适合使用自旋锁，因为忙等待期间其他线程可在其他核上执行。</li>
</ul>
</li>
</ul>
<p><strong><code>互斥锁</code>和<code>自旋锁</code>是最基本的两种锁机制。</strong><br><strong>高级锁（如读写锁、悲观锁和乐观锁）的实现往往是基于这两种基本机制的扩展或改进</strong></p>
<p><strong>读写锁</strong></p>
<ul>
<li>在互斥锁基础上的扩展，特点是允许多个线程同时执行<strong>读操作</strong>，但在执行<strong>写操作</strong>时要求<strong>独占访问</strong>。<br>即在<strong>写操作</strong>进行时，不允许其他线程进行读或写操作，从而保证<strong>数据的完整性</strong>。</li>
<li><strong>优点</strong>：能显著提高读密集型应用的并发性能，减少锁竞争。<br><strong>缺点</strong>：如果写操作频繁，可能会出现写饥饿或整体性能下降的情况，同时实现上比互斥锁复杂。</li>
<li><strong>适用场景</strong><ul>
<li>读操作远多于写操作的场合，如缓存系统或配置文件的读取、</li>
<li>需要在保证数据一致性的同时提高系统并发度。</li>
</ul>
</li>
</ul>
<p><strong>悲观锁</strong></p>
<ul>
<li>悲观锁 假定 <code>在并发环境下数据冲突 / 多线程同时修改共享资源</code> 的概率比较高<br>在访问共享资源时一律上锁，确保在操作过程中不会发生并发冲突（如数据库中常见的行级锁和表级锁）</li>
<li><strong>优点</strong>：安全性高，能有效防止并发冲突。<br><strong>缺点</strong>：加锁时间较长可能会降低系统吞吐量，引发较多的阻塞等待。</li>
<li><strong>适用场景</strong><ul>
<li>多线程或多进程写操作较多、冲突频繁的场景，如金融系统中的账户转账。</li>
<li>数据一致性要求非常高的业务逻辑。</li>
</ul>
</li>
</ul>
<p><strong>乐观锁</strong></p>
<ul>
<li>乐观锁基于“冲突较少”的假设，在操作共享资源时不立即加锁，而是在更新时检测数据是否被其他线程修改。<br>常见的实现方式有基于版本号（versioning）或时间戳的比较，在冲突检测到时，放弃本次修改或者重试操作。</li>
<li><strong>优点</strong>：无需长时间持有锁，可以极大地提高并发性能。<br><strong>缺点</strong>：在高冲突环境下，频繁的冲突检测和重试会影响整体效率，同时实现逻辑较为复杂。</li>
<li><strong>适用场景</strong><ul>
<li>读操作远多于写操作的场景，如用户信息更新、库存扣减等。</li>
<li>并发冲突发生概率较低的系统中，能最大限度地减少锁竞争。</li>
</ul>
</li>
</ul>
<p><strong>选择策略</strong></p>
<ul>
<li><strong>互斥锁</strong>适用于简单的独占访问场景；<strong>自旋锁</strong>适用于临界区操作短、上下文切换成本较高的场合；</li>
<li><strong>读写锁</strong>在读多写少的场景中能显著提升并发性能；</li>
<li><strong>悲观锁</strong>在高冲突、高一致性要求的场合较为稳妥；<strong>乐观锁</strong>则适合冲突较少、追求高并发性能的场景。</li>
</ul>
<h4 id="讲一讲你理解的虚拟内存"><a href="#讲一讲你理解的虚拟内存" class="headerlink" title="讲一讲你理解的虚拟内存"></a>讲一讲你理解的虚拟内存</h4><ul>
<li><strong>定义和工作原理</strong><ul>
<li>虚拟内存为每个进程提供一个看似连续的虚拟地址空间，其实际<strong>映射</strong>关系由页表维护，<br>利用内存管理单元（MMU）完成虚拟地址到物理地址的转换。</li>
<li>当某个虚拟页面不在物理内存中时，会触发缺页异常，操作系统负责将该页面从硬盘（交换区）调入内存。</li>
</ul>
</li>
<li><strong>页置换算法的作用</strong><ul>
<li>当物理内存资源不足时，操作系统会采用页置换算法（例如FIFO、LRU等）来决定哪些页面需要被换出，从而为新加载的页面腾出内存空间。</li>
</ul>
</li>
<li><strong>虚拟内存的优点与可能的性能问题</strong><ul>
<li>优点<ul>
<li>扩展内存容量，使程序能够使用超过实际物理内存大小的内存空间。</li>
<li>提供内存隔离，确保各进程之间的内存安全。</li>
<li>通过内存映射文件技术，实现高效的文件I&#x2F;O操作。</li>
</ul>
</li>
<li>性能问题<ul>
<li>频繁的缺页异常和页面交换可能引发I&#x2F;O瓶颈，从而降低系统性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h3><h4 id="你知道的线程同步的方式有哪些？"><a href="#你知道的线程同步的方式有哪些？" class="headerlink" title="你知道的线程同步的方式有哪些？"></a>你知道的线程同步的方式有哪些？</h4><p>线程同步机制：多线程编程中保证线程之间的互不干扰的机制</p>
<ul>
<li><p><strong>互斥锁</strong></p>
<ul>
<li>用于保护共享资源，使任一时刻只有一个线程能进入临界区，防止多个线程同时修改数据，确保数据一致性。</li>
<li><strong>优点</strong>：实现简单、适用性广。<br><strong>缺点</strong>：如果使用不当可能会导致线程长时间等待甚至死锁，锁粒度过大时会降低并发性能。</li>
</ul>
</li>
<li><p><strong>自旋锁</strong></p>
<ul>
<li>自旋锁在等待锁时不会挂起线程，而是通过忙等待（不断循环检测锁状态）保持对锁的占用，适用于临界区执行时间非常短的情况。</li>
<li><strong>优点</strong>：避免线程挂起与上下文切换，适合多核系统中短时竞争场景。<br><strong>缺点</strong>：如果等待时间较长，自旋会占用大量CPU资源，可能导致效率低下。</li>
</ul>
</li>
<li><p><strong>读写锁</strong></p>
<ul>
<li>读写锁允许多个线程并发读取共享数据，但写操作时要求独占访问。<br>这种机制在读操作远多于写操作时能显著提高并发性能。</li>
<li><strong>优点</strong>：在读多写少的场景下能提高系统整体并发性。<br><strong>缺点</strong>：实现较复杂，可能出现写者饥饿（长时间等待写入）的情况。</li>
</ul>
</li>
<li><p><strong>条件变量</strong></p>
<ul>
<li>条件变量允许线程在等待特定条件（如队列不为空、资源可用等）时进入睡眠状态，<br>避免忙等待。通常需要与互斥锁结合使用，确保状态检查与等待操作的原子性。</li>
<li><strong>优点</strong>：有效降低CPU空转，适合事件触发和生产者-消费者模型。<br><strong>缺点</strong>：使用时逻辑较复杂，容易出错，必须保证条件的正确性和通知的及时性。</li>
</ul>
</li>
<li><p><strong>信号量</strong></p>
<ul>
<li>信号量是一种基于计数器的同步机制，用于控制对共享资源的访问数量。<br>二值信号量（值为1）可用于实现互斥，而计数信号量允许多个线程同时访问有限的资源（如连接池）。</li>
<li><strong>优点</strong>：灵活控制并发访问的数量，适用于有限资源的管理。<br><strong>缺点</strong>：管理和调试较复杂，容易因计数错误导致资源泄露或竞争问题。</li>
</ul>
</li>
</ul>
<p><strong>如何选择合适的线程同步机制</strong></p>
<ul>
<li><strong>资源访问方式</strong>：  <ul>
<li>需要严格互斥时优先使用<strong>互斥锁</strong>；  </li>
<li>临界区执行时间非常短且竞争不激烈时，<strong>自旋锁</strong>可以减少上下文切换；  </li>
<li>对共享数据的读操作远多于写操作时，使用<strong>读写锁</strong>能提高并发度。</li>
</ul>
</li>
<li><strong>线程间通信</strong>：  <ul>
<li>当线程需要等待某个条件满足时，<strong>条件变量</strong>是理想的选择；  </li>
<li>对于管理有限资源访问，<strong>信号量</strong>能有效控制同时访问的线程数。</li>
</ul>
</li>
</ul>
<h4 id="有哪些页面置换算法"><a href="#有哪些页面置换算法" class="headerlink" title="有哪些页面置换算法"></a>有哪些页面置换算法</h4><ul>
<li><p><strong>最佳置换算法（OPT）</strong></p>
<ul>
<li>根据未来页面访问情况，选择最长时间内不会被访问的页面进行淘汰。</li>
<li>理论上缺页率最低，常作为性能下界参考；<br>实际中无法实现，因为操作系统无法预知未来的页面访问序列。</li>
<li><strong>适用场景</strong>：理论研究和算法性能比较时使用。</li>
</ul>
</li>
<li><p><strong>先进先出算法（FIFO）</strong></p>
<ul>
<li>按照页面进入内存的顺序，最早进入的页面先被淘汰。</li>
<li>实现简单，但可能会淘汰仍在被频繁使用的页面，<br>容易出现“Belady 异常”（增加内存反而缺页率上升）。</li>
<li><strong>适用场景</strong>：<br>对实现要求简单且不追求最优性能的场景。</li>
</ul>
</li>
<li><p><strong>最近最久未使用算法（LRU）</strong></p>
<ul>
<li>利用页面历史访问记录，淘汰最长时间未被访问的页面。</li>
<li>符合程序时间局部性原理，缺页率较低；<br>但需要维护访问顺序或时间戳，开销相对较大。</li>
<li><strong>适用场景</strong>：应用于大部分实际系统，尤其适合访问模式具有明显时间局部性的场景。</li>
</ul>
</li>
<li><p><strong>时钟算法（Clock）</strong></p>
<ul>
<li>利用环形队列和页面的引用位来近似实现 LRU。时钟指针遍历页面，<br>当遇到引用位为 0 的页面时进行置换；若引用位为 1，则清零后继续查找。</li>
<li>实现较简单，开销低，能够较好地平衡实现复杂性和性能，是 LRU 的一种高效近似算法。</li>
<li><strong>适用场景</strong>：实际操作系统中广泛采用，特别是在硬件资源有限、需要降低实现成本的场景。</li>
</ul>
</li>
<li><p><strong>最不经常使用算法（LFU）</strong></p>
</li>
<li><p>记录页面访问频率，淘汰访问次数最少的页面。</p>
</li>
<li><p>能反映页面的长期使用情况，适用于访问模式相对稳定的环境；<br>但对突发性或短期变化响应不够敏感，维护访问计数也会增加额外开销。</p>
</li>
<li><p><strong>适用场景</strong>：用于那些页面访问频率变化较小的系统，但在动态环境下可能不够灵活。</p>
</li>
</ul>
<p><strong>如何选择</strong></p>
<ul>
<li><strong>理论与实际折中</strong>：<br> 虽然最佳置换算法（<strong>OPT</strong>）理论上最优，但实际中无法实现，<br>因此常用 <strong>LRU</strong> 或其近似算法（如 <strong>Clock</strong>）来兼顾性能和实现复杂度。</li>
<li><strong>实现复杂度与系统特性</strong>：<br><strong>FIFO</strong> 实现简单，但在某些场景下可能性能不佳；<br>而 <strong>LRU</strong> 和 <strong>LFU</strong> 虽然性能较优，但开销较大，需要额外的数据结构支持。</li>
<li><strong>工作负载特点</strong>：<br>根据系统的内存容量、访问局部性（时间或频率）以及实际工作负载，<br>选择合适的算法可以在资源利用和系统响应之间取得平衡。</li>
</ul>
<h3 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h3><h4 id="熟悉哪些Linux命令"><a href="#熟悉哪些Linux命令" class="headerlink" title="熟悉哪些Linux命令"></a>熟悉哪些Linux命令</h4><p><strong>文件操作：</strong></p>
<ul>
<li><code>ls</code>：列出目录内容、<code>cd</code>：更改当前工作目录、<br><code>pwd</code>：显示当前工作目录路径。</li>
<li><code>cp</code>：复制文件或目录、<br><code>mv</code>：移动或重命名文件或目录、<code>rm</code>：删除文件或目录。</li>
<li><code>touch</code>：创建空文件或更新文件的时间戳。</li>
<li><code>mkdir</code>：创建新目录、<code>rmdir</code>：删除空目录。</li>
</ul>
<p><strong>文件内容查看：</strong></p>
<ul>
<li><code>cat</code>：连接并显示文件内容。<br><code>head</code>：显示文件的前几行。<br><code>tail</code>：显示文件的后几行，常用于查看日志文件。</li>
<li><code>more</code>：分页显示文件内容。<br><code>less</code>：与 <code>more</code> 类似，但提供更强大的导航功能。</li>
</ul>
<p><strong>权限管理：</strong></p>
<ul>
<li><code>chmod</code>：更改文件或目录的访问权限。<br><code>chown</code>：更改文件或目录的所有者和&#x2F;或所属组。</li>
</ul>
<p><strong>磁盘管理：</strong></p>
<ul>
<li><code>df</code>：显示文件系统的磁盘空间使用情况。<br><code>du</code>：估算文件和目录的磁盘使用情况。</li>
<li><code>fdisk</code>：用于磁盘分区的管理工具。</li>
<li><code>mount</code>：挂载文件系统。<br><code>umount</code>：卸载已挂载的文件系统。</li>
</ul>
<p><strong>网络管理：</strong></p>
<ul>
<li><code>ifconfig</code>&#x2F;<code>ip addr</code>：显示或配置网络接口。</li>
<li><code>ping</code>：测试与主机的网络连接。</li>
<li><code>netstat</code>：显示网络连接、路由表和接口统计信息。</li>
<li><code>ssh</code>：通过安全外壳协议远程登录。<br><code>scp</code>：通过 SSH 进行安全的文件复制。<br><code>ftp</code>：文件传输协议客户端，用于在网络上传输文件。</li>
</ul>
<p><strong>进程管理：</strong></p>
<ul>
<li><code>ps</code>：显示当前进程的快照。<br><code>top</code>：实时显示系统中各个进程的资源使用情况。</li>
<li><code>kill</code>：向进程发送信号（通常用于终止进程）。<br><code>killall</code>：通过进程名终止所有匹配的进程。</li>
<li><code>bg</code>：将进程放到后台运行、<code>fg</code>：将后台进程带到前台运行。</li>
</ul>
<p><strong>软件包管理：</strong></p>
<ul>
<li><code>apt-get</code>：Debian 系列发行版的包管理工具，用于安装、更新和删除软件包。<br><code>yum</code>：Red Hat 系列发行版的包管理工具，用于安装、更新和删除软件包。</li>
<li><code>rpm</code>：Red Hat Package Manager，用于安装、查询、验证、更新和卸载 RPM 包。<br><code>dpkg</code>：Debian 包管理器，用于安装、构建、删除和管理 Debian 软件包。</li>
</ul>
<h4 id="Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用"><a href="#Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用" class="headerlink" title="Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用"></a>Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用</h4><p><strong>1. 查看进程</strong></p>
<ul>
<li>方法：<ul>
<li>使用 <code>ps aux</code> 或 <code>ps -ef</code> 命令列出当前所有进程及详细信息。</li>
<li>使用 <code>top</code> 或 <code>htop</code> 命令实时监控进程的运行状态和资源占用情况。</li>
</ul>
</li>
</ul>
<p><strong>2. 杀死进程</strong></p>
<ul>
<li>方法：<ul>
<li>首先使用 <code>ps</code> 或 <code>top</code> 命令查找目标进程的 PID（进程ID）。</li>
<li>然后使用 <code>kill PID</code> 命令发送终止信号（默认 SIGTERM）来请求进程结束。</li>
<li>如果进程无法正常退出，可使用 <code>kill -9 PID</code> 强制终止进程。</li>
</ul>
</li>
</ul>
<p><strong>3. 查看端口占用</strong></p>
<ul>
<li>方法：<ul>
<li>使用 <code>lsof -i:端口号</code> 命令可以列出占用特定端口的进程信息。</li>
<li>或者使用 <code>netstat -tulnp | grep 端口号</code> 命令查看该端口的监听状态和相关进程ID。</li>
<li>另外，<code>ss -tulnp | grep 端口号</code> 也是常用的工具，输出信息类似于 netstat，但速度更快。</li>
</ul>
</li>
</ul>
<h4 id="说一下-select、poll、epoll"><a href="#说一下-select、poll、epoll" class="headerlink" title="说一下 select、poll、epoll"></a>说一下 select、poll、epoll</h4><ul>
<li><strong>select</strong><ul>
<li><strong>原理</strong>：传入一个固定大小的文件描述符集合，内核逐一检查这些描述符是否有可读、可写或异常事件。</li>
<li><strong>特点与限制</strong>：实现简单、兼容性好，但受限于最大描述符数（通常为1024）且每次调用都需要遍历整个集合，效率随描述符数量增加而下降。</li>
</ul>
</li>
<li><strong>poll</strong><ul>
<li><strong>原理</strong>：使用动态数组（pollfd数组）来监控多个文件描述符，避免了select固定数量的限制。</li>
<li><strong>特点与限制</strong>：克服了文件描述符数量的限制，但同样需要遍历整个数组，性能随描述符数量线性下降，拷贝开销较大。</li>
</ul>
</li>
<li><strong>epoll</strong><ul>
<li><strong>原理</strong>：将感兴趣的文件描述符注册到内核中，内核维护一个事件表，并在文件描述符就绪时通过事件通知给应用程序。支持水平触发和边缘触发模式。</li>
<li><strong>特点与限制</strong>：在处理大量文件描述符时效率高，时间复杂度接近 O(1)；但仅适用于 Linux 平台，且在活动连接非常频繁的情况下，边缘触发模式下的处理需要开发者额外注意，可能使优势不那么明显。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：<br><strong>select</strong> 是最早的 I&#x2F;O 多路复用技术，但存在文件描述符数量和效率上的限制；</p>
<p><strong>poll</strong> 改进了数量限制的问题，但在大量连接时性能仍然不足；</p>
<p>而 <strong>epoll</strong> 则通过事件驱动方式显著提高了性能，尤其适用于高并发场景，<br>不过仅在 Linux 平台可用，并且在某些特殊情况下（如活动连接频繁）其优势可能会减弱。</p>
<h3 id="Day16"><a href="#Day16" class="headerlink" title="Day16"></a>Day16</h3><h4 id="一条SQL查询语句是如何执行的？"><a href="#一条SQL查询语句是如何执行的？" class="headerlink" title="一条SQL查询语句是如何执行的？"></a>一条SQL查询语句是如何执行的？</h4><ul>
<li><strong>连接器</strong>：<br>负责与客户端建立连接、进行权限认证，并维持和管理整个会话。</li>
<li><strong>查询缓存</strong>：<br> 当接收到查询请求后，MySQL 首先检查查询缓存，判断是否存在相同语句的执行结果；如果存在，则直接返回缓存中的结果，节省解析和执行的开销。</li>
<li><strong>分析器</strong>：<br> 将输入的 SQL 语句拆分成多个字符串和标记，识别各部分的含义，构建解析树（或抽象语法树），确保语句符合语法和语义规则。</li>
<li><strong>优化器</strong>：<br> 根据解析器输出的语法树以及数据库中的索引、统计信息等，决定最优的执行计划。比如在多索引或多表关联时，选择合适的索引和连接顺序，以降低查询成本。</li>
<li><strong>执行器</strong>：<br> 根据优化器生成的执行计划，实际执行查询操作，读取数据、进行计算和转换，最后将结果返回给客户端。</li>
</ul>
<p>这种分层设计使得 MySQL 在处理查询请求时能够高效地完成从连接建立、缓存检查、语句解析、执行计划优化到最终数据检索的全过程。</p>
<h4 id="事务的四大特性-ACID-属性-有哪些？"><a href="#事务的四大特性-ACID-属性-有哪些？" class="headerlink" title="事务的四大特性 &#x2F; ACID 属性 有哪些？"></a>事务的<code>四大特性</code> &#x2F; <code>ACID 属性</code> 有哪些？</h4><ul>
<li><p><strong>原子性（Atomicity）</strong></p>
<ul>
<li>一个事务中的所有操作<strong>要么全部成功，要么全部失败</strong>。</li>
<li>确保<strong>数据操作的不可分割性</strong>，避免部分提交导致数据不一致。</li>
<li>举例：在银行转账中，扣款和加款必须同时完成；如果其中一步失败，则整个转账操作都会回滚，保证账户状态不出现部分更新的情况。</li>
</ul>
</li>
<li><p><strong>一致性（Consistency）</strong></p>
<ul>
<li>事务必须使数据库从一个一致性状态转换到另一个一致性状态。</li>
<li>保证业务规则和约束始终得到遵守，防止数据错误。</li>
<li>举例：在订单处理系统中，订单总金额与库存数量之间的关系在事务执行前后必须保持业务规则的一致性。</li>
</ul>
</li>
<li><p><strong>隔离性（Isolation）</strong></p>
<ul>
<li><strong>并发执行的事务之间互不干扰，执行结果应该与串行执行相同</strong>。</li>
<li>防止并发事务间的相互干扰，确保数据的正确性。</li>
<li>举例：当两个用户同时更新同一条记录时，通过隔离机制避免数据竞争，确保每个事务看到的数据都是正确且独立的。</li>
<li><strong>现代技术</strong>：多版本并发控制（MVCC）就是一种实现隔离性的机制，通过保存数据的多个版本来减少锁竞争，提高并发性能。</li>
</ul>
</li>
<li><p><strong>持久性（Durability）</strong></p>
<ul>
<li><p>一旦<strong>事务提交，其对数据库的修改将永久保存</strong>，即使系统出现故障也不会丢失。</p>
</li>
<li><p>保证事务结果的长期可靠性和数据安全性。</p>
</li>
<li><p>举例：在订单提交后，即使数据库发生崩溃，已提交的订单信息也应该在恢复后依然存在。</p>
</li>
</ul>
</li>
</ul>
<h4 id="数据库的事务隔离级别有哪些？"><a href="#数据库的事务隔离级别有哪些？" class="headerlink" title="数据库的事务隔离级别有哪些？"></a>数据库的事务隔离级别有哪些？</h4><ul>
<li><p><strong>读未提交</strong></p>
<ul>
<li>允许一个事务读取其他事务尚未提交的修改数据，<strong>并发性能最高</strong></li>
<li>是最低的隔离级别，因此会存在<strong>脏读</strong>、<strong>不可重复读</strong>和<strong>幻读</strong>的问题。<strong>数据一致性较弱</strong></li>
</ul>
</li>
<li><p><strong>读已提交</strong></p>
<ul>
<li>一个事务只能读取其他事务已经提交的数据，未提交的数据对当前事务不可见。是<strong>大多数系统的默认选择</strong></li>
<li>能够解决<strong>脏读问题</strong>，适合大部分应用场景。<br>但由于在同一事务中多次读取可能遇到其他事务提交的数据，所以仍可能发生<strong>不可重复读</strong>和<strong>幻读</strong>。</li>
</ul>
</li>
<li><p><strong>可重复读</strong></p>
<ul>
<li>保证在事务执行期间，多次读取同一数据得到的结果一致。</li>
<li>在事务开始后和结束前，其他事务对数据的修改对当前事务不可见，从而解决了不可重复读的问题。提高了<strong>事务内数据一致性</strong><br>不过，在某些情况下可能仍然会遇到<strong>幻读</strong>（例如插入新的符合查询条件的数据）。</li>
</ul>
</li>
<li><p><strong>序列化</strong></p>
<ul>
<li>最高的隔离级别，通过强制事务串行化执行，使得并发事务的执行结果与串行执行的效果完全一致。提供<strong>最严格的数据一致性保证</strong></li>
<li><strong>从根本上避免了脏读、不可重复读和幻读问题。</strong><br>由于严格的并发控制，可能会对性能产生较大的影响，适用于对数据一致性要求极高的场景。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/04/2025-03-04-ELinux%E7%AD%96%E7%95%A5%E5%86%B2%E7%AA%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/04/2025-03-04-ELinux%E7%AD%96%E7%95%A5%E5%86%B2%E7%AA%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">SELinux策略冲突分析工具的设计与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-04 15:30:00" itemprop="dateCreated datePublished" datetime="2025-03-04T15:30:00+08:00">2025-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-05 09:15:25" itemprop="dateModified" datetime="2025-03-05T09:15:25+08:00">2025-03-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%95%E8%AE%BE/" itemprop="url" rel="index"><span itemprop="name">毕设</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="开题报告"><a href="#开题报告" class="headerlink" title="开题报告"></a>开题报告</h4><h5 id="一、选题背景"><a href="#一、选题背景" class="headerlink" title="一、选题背景"></a>一、选题背景</h5><p><strong>研究现状</strong></p>
<p>SELinux（Security-Enhanced Linux）是美国国家安全局（NSA）研发的一种强制访问控制机制，目前广泛应用于Linux系统安全领域。其通过安全策略对系统访问权限进行细粒度管控，能够有效遏制恶意操作。然而，随着应用场景复杂度增加，SELinux策略文件的规模呈现指数增长，由此带来的冗余与冲突问题逐步显现。这类问题可能导致系统安全漏洞、性能衰减甚至功能障碍。</p>
<p>在国际研究中，学者们围绕SELinux的访问控制模型及策略优化展开了深入探讨。例如，Pahuja等（2023）提出了改进的逻辑推理冲突检测算法，大幅提高了检测效率。但多数研究侧重理论验证，实际工具开发较少涉及。在国内，研究集中于SELinux策略定制与优化，部分开源工具虽具备检测功能，但多局限于单一任务，难以应对复杂环境需求。</p>
<p><strong>选题目的及意义</strong></p>
<p>本课题旨在开发一款SELinux策略冲突分析工具，解决当前工具在冲突检测及优化建议方面的不足。通过自动检测与实时优化建议，该工具帮助管理员迅速发现并处理冲突，提升系统安全性与运维效率。本研究既能为SELinux的应用提供技术支持，也有助于推动该领域的理论研究发展。</p>
<h5 id="二、研究目标和内容"><a href="#二、研究目标和内容" class="headerlink" title="二、研究目标和内容"></a>二、研究目标和内容</h5><p>2.1 研究目标<br>1.策略解析：构建功能模块，解析SELinux策略文件并转化为结构化数据。<br>2.冲突检测：设计高效算法，定位并识别规则冗余及权限冲突问题。<br>3.实时告警与优化：通过可视化和告警功能，辅助用户快速排查并解决问题。</p>
<p>2.2 主要研究内容<br>1.理论分析：梳理SELinux策略语法和冲突类型，搭建冲突检测的理论框架。<br>2.算法设计：基于图算法或逻辑推理方法，开发适配Java语言的检测算法。<br>3.工具开发：基于Java语言实现具备解析、检测及告警功能的工具。<br>系统验证：在多种Linux系统环境中对工具进行功能和性能测试，并优化算法以提高准确性。</p>
<h5 id="三、研究方案"><a href="#三、研究方案" class="headerlink" title="三、研究方案"></a>三、研究方案</h5><p><strong>3.1 研究方法</strong><br>1.理论分析<br>   系统分析 SELinux 策略文件结构，提取其语法规则和常见冲突类型。<br>   总结现有文献中的冲突检测方法，为工具开发提供理论依据。<br>2.算法设计<br>   使用基于图模型的算法表示策略规则之间的依赖关系，定位可能的冲突点。<br>   引入逻辑推理模块，通过对权限的推导分析潜在冲突。<br>3.工具开发<br>   语言选择：采用 Java 语言开发核心功能模块，确保工具的跨平台兼容性。<br>   模块设计：<br>     策略解析模块：利用 ANTLR 等工具解析 SELinux 策略文件。<br>     冲突检测模块：实现基于图算法的冲突分析逻辑。<br>     用户界面模块：通过 JavaFX 提供交互式可视化界面。<br>     告警与日志模块：通过日志记录和实时通知功能，协助用户快速处理问题。<br>4.测试验证<br>   在多种 Linux 发行版（如 CentOS、Ubuntu）中进行功能测试，评估工具的兼容性与性能表现。<br>   通过真实策略文件验证检测算法的准确率，优化算法以降低误报与漏报率。</p>
<p><strong>3.2 实施步骤</strong></p>
<p>2025年1月：调研SELinux策略特性，明确工具设计需求。<br>2025年2月：完成冲突检测算法的设计与初步实现。<br>2025年3月：开发策略解析、检测和用户界面模块。<br>2025年4月：部署工具并进行功能与性能优化，撰写相关文档与论文。</p>
<p><strong>3.3 拟解决的主要问题及措施</strong><br>问题1：策略解析复杂度高，可能影响性能。<br>措施：优化解析算法，并结合多线程技术提高效率。</p>
<p>问题2：检测算法误报率较高。<br>措施：通过逻辑推理及依赖分析，减少误报并提升检测准确性。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/02/20/2025-02-20-%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/20/2025-02-20-%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">从零开始搭建仿牛客论坛项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-20 13:57:01" itemprop="dateCreated datePublished" datetime="2025-02-20T13:57:01+08:00">2025-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-21 17:35:09" itemprop="dateModified" datetime="2025-02-21T17:35:09+08:00">2025-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h2><ul>
<li>JDK9.0.4</li>
<li>apache-maven-3.6.3</li>
<li>SpringBoot 2.4.1</li>
<li>Redis-x64-5.0.10</li>
<li>Elasticsearch-7.9.3</li>
<li>kafka_2.13-2.7.0</li>
<li>wkhtmltopdf(⻓图⽣成⼯具)</li>
<li>mysql 5.7(建议版本&gt;&#x3D;5.7)</li>
</ul>
<p><strong>SQL文件介绍</strong></p>
<ul>
<li>init_schema.sql –&gt; 建表sql</li>
<li>init_data.sql –&gt; 初始化数据库数据SQL</li>
<li>tables_mysql_innodb.sql –&gt; quarter定时任务表SQL</li>
</ul>
<h3 id="初识Spring-Boot，开发社区首页"><a href="#初识Spring-Boot，开发社区首页" class="headerlink" title="初识Spring Boot，开发社区首页"></a>初识Spring Boot，开发社区首页</h3><p><strong>技术架构</strong></p>
<ul>
<li>Spring Boot</li>
<li>Spring、Spring MVC 、MyBatis</li>
<li>Redis、Kafka(消息队列服务器)、Elasticsearch(搜索引擎)</li>
<li>Spring Security、Spring Actuator</li>
</ul>
<p><strong>开发环境</strong></p>
<ul>
<li>构建工具：Apache Maven</li>
<li>集成开发工具：IDEA</li>
<li>数据库：MySQL、Redis</li>
<li>应用服务器：Apache Tomcat</li>
<li>版本控制工具：Git</li>
</ul>
<h5 id="Apache-Maven"><a href="#Apache-Maven" class="headerlink" title="Apache Maven"></a>Apache Maven</h5><ul>
<li>可以帮助我们构建项目、管理项目中的jar包</li>
<li>Maven仓库：存放构件的位置<ul>
<li>本地仓库：默认是 ~&#x2F;.m2&#x2F;repository</li>
<li>远程仓库：中央仓库、镜像仓库、私服仓库</li>
</ul>
</li>
</ul>
<p>Maven官网：<a target="_blank" rel="noopener" href="http://maven.apache.org/">http://maven.apache.org</a></p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/1.png"  alt="1" style="zoom:67%;" />
下载zip压缩包解压即可

<ul>
<li><p>默认访问的远程仓库为maven的中央仓库，改为阿里云的镜像仓库</p>
<ul>
<li><p>修改<code>D:\Environment\apache-maven-3.9.8\conf</code>路径下的配置文件<code>settings.xml</code></p>
</li>
<li><p>在<code>maven.aliyun.com</code>查找仓库路径，此处选用<br><a target="_blank" rel="noopener" href="https://maven.aliyun.com/repository/central">https://maven.aliyun.com/repository/central</a></p>
</li>
<li><p>在<code>&lt;mirrors&gt;  &lt;/mirrors&gt;</code> 中添加内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>maven默认采用命令行的方式访问，命令行工具<code>mvn.cmd</code>的默认路径是<code>D:\Environment\apache-maven-3.9.8\bin</code></p>
</li>
<li><p>将路径配到系统环境变量Path中</p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/2.png"  alt="2" style="zoom:67%;" />

<p>cmd中查看版本号，检查是否成功配置</p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/3.png"  alt="3" style="zoom:67%;" />
</li>
<li><p>maven常用命令（创建、测试、编译）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`创建项目`</span><br><span class="line">mvn archetype:generate -DgroupId=com.nowcoder.mavendemo01 -DartifactId=mavendemo01 -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.5 -DinteractiveMode=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## archetype:generate 调用 Maven 的原型生成器</span></span><br><span class="line">以模板原型的方式生成一个文件</span><br><span class="line"><span class="comment">## -DgroupId=com.mycompany.app：组织ID，通常wei</span></span><br><span class="line"><span class="comment">## -DartifactId=my-app：指定项目的ID，项目目录名称也通常采用这个名称。</span></span><br><span class="line"><span class="comment">## -DarchetypeArtifactId=maven-archetype-quickstart：选择 Maven 快速入门原型，这个原型会生成一个简单的 Java 项目，包含基本的目录结构和示例代码（例如 App.java 和对应的测试类）。</span></span><br><span class="line"><span class="comment">## -DarchetypeVersion=1.5：指定使用的原型版本。</span></span><br><span class="line"><span class="comment">## -DinteractiveMode=false：关闭交互模式，所有必要的信息都通过命令行参数指定，不需要在运行过程中进一步输入</span></span><br></pre></td></tr></table></figure>

<p>创建的项目目录如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">my-app</span><br><span class="line">|-- pom.xml</span><br><span class="line">`-- src</span><br><span class="line">    |-- main</span><br><span class="line">    |   `-- java</span><br><span class="line">    |       `-- com</span><br><span class="line">    |           `-- mycompany</span><br><span class="line">    |               `-- app</span><br><span class="line">    |                   `-- App.java</span><br><span class="line">    `-- <span class="built_in">test</span></span><br><span class="line">        `-- java</span><br><span class="line">            `-- com</span><br><span class="line">                `-- mycompany</span><br><span class="line">                    `-- app</span><br><span class="line">                        `-- AppTest.java</span><br></pre></td></tr></table></figure>

<p>编译项目，切换到项目路径下（即含pom.xml文件的目录)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn compile <span class="comment">#编译项目</span></span><br><span class="line"><span class="comment">##编译后的结果在 D:\Work\workspace\mavendemo01\target 路径下</span></span><br><span class="line">mvn clean <span class="comment">#清除</span></span><br><span class="line">mvn clean compile <span class="comment">#先清除再编译</span></span><br><span class="line">mvn clean <span class="built_in">test</span> <span class="comment">##先清除再测试，test命令包含了compile</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h5><p>目前最流行的Java集成开发工具</p>
<p><a target="_blank" rel="noopener" href="http://www.jetbrains.com/idea">http://www.jetbrains.com/idea</a></p>
<p>安装参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44601637/article/details/126807513">https://blog.csdn.net/qq_44601637/article/details/126807513</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46381569/article/details/131121481">https://blog.csdn.net/m0_46381569/article/details/131121481</a></p>
<p>在IDEA中配置Maven：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Future_yzx/article/details/140469886">https://blog.csdn.net/Future_yzx/article/details/140469886</a></p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/4.png"  alt="4" style="zoom:67%;" />



<h5 id="Spring-Initializr"><a href="#Spring-Initializr" class="headerlink" title="Spring Initializr"></a>Spring Initializr</h5><p><strong>创建 Spring Boot 项目的引导工具</strong></p>
<p><a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io</a></p>
<p>项目依赖的包较多时，管理起来较麻烦</p>
<p>Spring Initializr对项目常用的包进行了整合，按照功能&#x2F;需求进行分类</p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/5.png"  alt="5" style="zoom:67%;" />

<p>点击<code>Generate</code>下载设置好的web项目，解压后在IDEA中打开</p>
<p>在项目xml文件下的<code>&lt;dependencies&gt;	 &lt;/dependencies&gt;</code>标签内手动添加AOP模块<br><img src="/2025/02/20/2025-02-20-仿牛客论坛项目/8.png"  alt="8" style="zoom:50%;" /></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行项目测试，返回信息中显示Tomcat服务器成功在8080端口运行</p>
<p>Spring Boot 以jar包的方式内嵌了tomcat<br><img src="/2025/02/20/2025-02-20-仿牛客论坛项目/6.png"  alt="6" style="zoom:67%;" /></p>
<p>在本地的8080端口成功访问，web项目模板未作设置，返回错误信息</p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/7.png"  alt="7" style="zoom: 50%;" />



<h4 id="Spring-Boot-入门示例"><a href="#Spring-Boot-入门示例" class="headerlink" title="Spring Boot 入门示例"></a>Spring Boot 入门示例</h4><ul>
<li>Spring Boot 核心作用<ul>
<li>起步依赖</li>
<li>自动配置</li>
<li>端点监控</li>
</ul>
</li>
</ul>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/9.png"  alt="9" style="zoom: 50%;" />

<p><strong>修改Tomcat端口</strong></p>
<p>tomcat默认端口是8080，有时候会与其他服务产生冲突，此时修改<code>community\src\main\resources</code>路径下的<code>application.properties</code>文件即可<br><img src="/2025/02/20/2025-02-20-仿牛客论坛项目/10.png"  alt="10" style="zoom: 50%;" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/02/17/2025-02-17-Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/17/2025-02-17-Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-17 12:00:00" itemprop="dateCreated datePublished" datetime="2025-02-17T12:00:00+08:00">2025-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-19 14:02:38" itemprop="dateModified" datetime="2025-02-19T14:02:38+08:00">2025-02-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="压力测试工具-Redis-benchmark"><a href="#压力测试工具-Redis-benchmark" class="headerlink" title="压力测试工具 Redis-benchmark"></a>压力测试工具 Redis-benchmark</h3><p>Redis-benchmark是官方自带的Redis性能测试工具&#x2F;压力测试工具，可以有效的测试Redis服务的性能。</p>
<p>默认安装路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rzy@rzysredis:/$ which redis-benchmark</span><br><span class="line">/usr/bin/redis-benchmark</span><br></pre></td></tr></table></figure>

<p>确认进程开启</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试一：100个并发连接，100000个请求，检测host为localhost 端口为6379的redis服务器性能</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class="line"><span class="comment"># 测试出来的所有命令只举例一个！</span></span><br><span class="line">====== SET ======</span><br><span class="line">100000 requests completed <span class="keyword">in</span> 1.88 seconds <span class="comment"># 对集合写入测试</span></span><br><span class="line">100 parallel clients <span class="comment"># 每次请求有100个并发客户端</span></span><br><span class="line">3 bytes payload <span class="comment"># 每次写入3个字节的数据，有效载荷</span></span><br><span class="line">keep alive: 1 <span class="comment"># 保持一个连接，一台服务器来处理这些请求</span></span><br><span class="line">17.05% &lt;= 1 milliseconds</span><br><span class="line">97.35% &lt;= 2 milliseconds</span><br><span class="line">99.97% &lt;= 3 milliseconds</span><br><span class="line">100.00% &lt;= 3 milliseconds <span class="comment"># 所有请求在 3 毫秒内完成</span></span><br><span class="line">53248.14 requests per second <span class="comment"># 每秒处理 53248.14 次请求</span></span><br></pre></td></tr></table></figure>

<p>redis 性能测试工具可选参数如下<br><img src="/2025/02/17/2025-02-17-Redis/1.png"  alt="1" style="zoom: 67%;" /></p>
<h3 id="基本知识说明"><a href="#基本知识说明" class="headerlink" title="基本知识说明"></a>基本知识说明</h3><p>Redis默认有16个数据库，类似数组下标从零开始，初始默认使用零号库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Select命令切换数据库</span></span><br><span class="line">127.0.0.1:6379&gt; select 7</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[7]&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Dbsize查看当前数据库的key的数量</span></span><br><span class="line">127.0.0.1:6379&gt; select 7</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[7]&gt; DBSIZE</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[7]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DBSIZE</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; keys * # 查看具体的key</span><br><span class="line">1) &quot;counter:__rand_int__&quot;</span><br><span class="line">2) &quot;mylist&quot;</span><br><span class="line">3) &quot;k1&quot;</span><br><span class="line">4) &quot;myset:__rand_int__&quot;</span><br><span class="line">5) &quot;key:__rand_int__&quot;</span><br></pre></td></tr></table></figure>

<p>清除数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flushdb		#清空当前库</span><br><span class="line">Flushall	#清空全部的库</span><br></pre></td></tr></table></figure>

<h5 id="为什么redis是单线程"><a href="#为什么redis是单线程" class="headerlink" title="为什么redis是单线程"></a>为什么redis是单线程</h5><p>Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽</p>
<p><strong>Redis为什么这么快？</strong></p>
<ol>
<li>多线程不一定比单线程效率高，效率与CPU 、内存 、硬盘的速度都有关系</li>
<li>redis 核心就是 <strong>数据全都在内存</strong>里，单线程的去操作就是效率最高的<ul>
<li>多线程的本质就是 CPU 模拟出来多个线程的情况，<br>这种模拟出来的情况就有一个代价，就是<strong>上下文的切换</strong>，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。</li>
<li>redis 用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。在内存的情况下，这个方案就是最佳方案。</li>
</ul>
</li>
</ol>
<p>Tips：一次CPU上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us，<br>	假设1MB的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，那么就有1500ns *1000 	&#x3D; 1500us ，单线程的读完	1MB数据耗时250us ,而此时时间上下文的切换就用了1500us了</p>
<h4 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name rzy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">exists key 的名字，判断某个key是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从当前数据库 0 移动到数据库 1</span> </span><br><span class="line">127.0.0.1:6379&gt; move name 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">expire key 秒钟：为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ttl key 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</span></span><br><span class="line">127.0.0.1:6379&gt; set name rzy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE name 10</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">type</span> key 查看你的key是什么类型</span></span><br><span class="line">127.0.0.1:6379&gt; set name rzy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; type name</span><br><span class="line">string</span><br></pre></td></tr></table></figure>



<h3 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h3><h4 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h4><p><strong>单值单Value</strong></p>
<ul>
<li><p>常用命令说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># set、get、</span></span><br><span class="line"><span class="comment"># del	删除key</span></span><br><span class="line"><span class="comment"># append	对已存在的字符串之后添加值，若不存在则等价set命令</span></span><br><span class="line"><span class="comment"># strlen	获取字符串的长度</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># incr、decr 对数字进行加减，+1 和 -1。</span></span><br><span class="line"><span class="comment"># incrby、decrby 将 key 中储存的数字加上指定的增量值。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># getrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部</span></span><br><span class="line"><span class="comment"># setrange 修改指定位置之后的值 格式是 setrange key值 具体值</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># setex（set with expire） 设置值，同时给key设置生存时间</span></span><br><span class="line"><span class="comment"># setnx（set if not exist） 仅key不存在时，才设置值和生存时间，key存在时设置失败</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># mset 同时设置一个或多个 key-value 对。</span></span><br><span class="line"><span class="comment"># mget 返回所有(一个或多个)给定 key 的值。</span></span><br><span class="line"><span class="comment"># 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。</span></span><br><span class="line"><span class="comment"># msetnx 当所有 key 都成功设置，返回 1 。</span></span><br><span class="line"><span class="comment"># 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。——原子操作</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># getset（先get再set）	——常用于更新操作</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># set、get、del、append、strlen</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 value1 <span class="comment"># 设置值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1 <span class="comment"># 获得key</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; del key1 <span class="comment"># 删除key</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看全部的key</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; exists key1 <span class="comment"># 确保 key1 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; append key1 <span class="string">&quot;hello&quot;</span> <span class="comment"># 对不存在的 key 进行 APPEND ，等同于 SET</span></span><br><span class="line">key1 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 5 <span class="comment"># 字符长度</span></span><br><span class="line">127.0.0.1:6379&gt; APPEND key1 <span class="string">&quot;-2333&quot;</span> <span class="comment"># 对已存在的字符串进行 APPEND</span></span><br><span class="line">(<span class="built_in">integer</span>) 10 <span class="comment"># 长度从 5 个字符增加到 10 个字符</span></span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;hello-2333&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN key1 <span class="comment"># # 获取字符串的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># incr、decr</span></span><br><span class="line"><span class="comment"># incrby、decrby</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0 <span class="comment"># 设置浏览量为0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr views <span class="comment"># 浏览 + 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views <span class="comment"># 浏览 + 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; decr views <span class="comment"># 浏览 - 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incrby views 10 <span class="comment"># +10</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; decrby views 10 <span class="comment"># -10</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># range</span></span><br><span class="line"><span class="comment"># getrange</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 abcd123456 <span class="comment"># 设置key2的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange key2 0 -1 <span class="comment"># 获得全部的值</span></span><br><span class="line"><span class="string">&quot;abcd123456&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key2 0 2 <span class="comment"># 截取部分字符串</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># setrange</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;abcd123456&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SETRANGE key2 1 xx <span class="comment"># 替换值</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;axxd123456&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># setex（set with expire）键秒值</span></span><br><span class="line"><span class="comment"># setnx（set if not exist）</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; setex key3 60 expire <span class="comment"># 设置过期时间</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3 <span class="comment"># 查看剩余的时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 55</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey <span class="string">&quot;redis&quot;</span> <span class="comment"># 如果不存在就设置，成功返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey <span class="string">&quot;mongodb&quot;</span> <span class="comment"># 如果存在就设置，失败返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># mset </span></span><br><span class="line"><span class="comment"># msetnx </span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; mset k10 v10 k11 v11 k12 v12</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k12&quot;</span></span><br><span class="line">2) <span class="string">&quot;k11&quot;</span></span><br><span class="line">3) <span class="string">&quot;k10&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k10 k11 k12 k13</span><br><span class="line">1) <span class="string">&quot;v10&quot;</span></span><br><span class="line">2) <span class="string">&quot;v11&quot;</span></span><br><span class="line">3) <span class="string">&quot;v12&quot;</span></span><br><span class="line">4) (nil)</span><br><span class="line">127.0.0.1:6379&gt; msetnx k10 v10 k15 v15 <span class="comment"># 原子性操作！</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get key15</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统对象缓存</span></span><br><span class="line"><span class="built_in">set</span> user:1 value(json数据)</span><br><span class="line"><span class="comment"># 可以用来缓存对象</span></span><br><span class="line">mset user:1:name zhangsan user:1:age 2</span><br><span class="line">mget user:1:name user:1:age</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># getset</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb <span class="comment"># 没有旧值，返回 nil</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;mongodb&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset db redis <span class="comment"># 返回旧值 mongodb</span></span><br><span class="line"><span class="string">&quot;mongodb&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure>

<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。</p>
<p>常规key-value缓存应用：常规计数：微博数，粉丝数等。</p>
<h4 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h4><p><strong>单值多Value</strong></p>
<p>- </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Lpush：将一个或多个值插入到列表头部。（左）</span></span><br><span class="line"><span class="comment"># rpush：将一个或多个值插入到列表尾部。（右）</span></span><br><span class="line"><span class="comment"># lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。</span></span><br><span class="line"><span class="comment"># 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。</span></span><br><span class="line"><span class="comment"># 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。</span></span><br><span class="line"><span class="comment"># rpop 移除列表的最后一个元素，返回值为移除的元素。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Lindex，按照索引下标获得元素（-1代表最后一个，0代表是第一个）</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># llen 用于返回列表的长度。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lrem key 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Ltrim key 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># rpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lset key index value 将列表 key 下标为 index 的元素的值设置为 value 。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># linsert key before/after pivot value 用于在列表的元素前或者后插入元素。</span></span><br><span class="line"><span class="comment"># 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Lpush、rpush、lrange</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH list <span class="string">&quot;right&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lrange list 0 1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lpop、rpop</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; Lpop list</span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Rpop list</span><br><span class="line"><span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Lindex</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; Lindex list 1</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; Lindex list 0</span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lindex list -1</span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># llen</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; Lpush list <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; Lpush list <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; Lpush list <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; Llen list <span class="comment"># 返回列表的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lrem key</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Ltrim key</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello2&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># rpoplpush</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;bar&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist myotherlist</span><br><span class="line"><span class="string">&quot;bar&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;foo&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myotherlist 0 -1</span><br><span class="line">1) <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lset key index value</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; exists list <span class="comment"># 对空列表(key 不存在)进行 LSET</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item <span class="comment"># 报错</span></span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list <span class="string">&quot;value1&quot;</span> <span class="comment"># 对非空列表进行 LSET</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 <span class="string">&quot;new&quot;</span> <span class="comment"># 更新值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;new&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 1 <span class="string">&quot;new&quot;</span> <span class="comment"># index 超出范围报错</span></span><br><span class="line">(error) ERR index out of range</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># linsert key before/after pivot value</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LINSERT mylist BEFORE <span class="string">&quot;World&quot;</span> <span class="string">&quot;There&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;There&quot;</span></span><br><span class="line">3) <span class="string">&quot;World&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h4><p><strong>单值多value</strong></p>
<p>- </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># sadd 将一个或多个成员元素加入到集合中，不能重复</span></span><br><span class="line"><span class="comment"># smembers 返回集合中的所有的成员。</span></span><br><span class="line"><span class="comment"># sismember 命令判断成员元素是否是集合的成员。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># scard，获取集合里面的元素个数</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># srem key value 用于移除集合中的一个或多个成员元素</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; srem myset <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># srandmember key 命令用于返回集合中的一个随机元素。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># spop key 用于移除集合中的指定 key 的一个或多个随机元素</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># smove SOURCE DESTINATION MEMBER</span></span><br><span class="line"><span class="comment"># 将指定成员 member 元素从 source 集合移动到 destination 集合。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 <span class="string">&quot;set2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;set2&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">- 数字集合类</span><br><span class="line">- 差集： sdiff</span><br><span class="line">- 交集： sinter</span><br><span class="line">- 并集： sunion</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; sadd key1 <span class="string">&quot;a&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 <span class="string">&quot;b&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 <span class="string">&quot;d&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 <span class="string">&quot;e&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SDIFF key1 key2 <span class="comment"># 差集</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER key1 key2 <span class="comment"># 交集</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION key1 key2 <span class="comment"># 并集</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;e&quot;</span></span><br><span class="line">5) <span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure>





<h4 id="哈希Hash"><a href="#哈希Hash" class="headerlink" title="哈希Hash"></a>哈希Hash</h4><p><strong>kv模式不变，但V是一个键值对</strong></p>
<p>- </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hset、hget 命令用于为哈希表中的字段赋值 。</span></span><br><span class="line"><span class="comment"># hmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段。</span></span><br><span class="line"><span class="comment"># hgetall 用于返回哈希表中，所有的字段和值。</span></span><br><span class="line"><span class="comment"># hdel 用于删除哈希表 key 中的一个或多个指定字段</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field1 <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line"><span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HMSET myhash field1 <span class="string">&quot;Hello&quot;</span> field2 <span class="string">&quot;World&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HGET myhash field1</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGET myhash field2</span><br><span class="line"><span class="string">&quot;World&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;World&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL myhash field1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field2&quot;</span></span><br><span class="line">2) <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hlen 获取哈希表中字段的数量。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET myhash field1 <span class="string">&quot;Hello&quot;</span> field2 <span class="string">&quot;World&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hexists 查看哈希表的指定字段是否存在。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hkeys 获取哈希表中的所有域（field）。</span></span><br><span class="line"><span class="comment"># hvals 返回哈希表所有域(field)的值。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; HKEYS myhash</span><br><span class="line">1) <span class="string">&quot;field2&quot;</span></span><br><span class="line">2) <span class="string">&quot;field1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HVALS myhash</span><br><span class="line">1) <span class="string">&quot;World&quot;</span></span><br><span class="line">2) <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hincrby 为哈希表中的字段值加上指定增量值。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field 5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field 1</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field -1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field -10</span><br><span class="line">(<span class="built_in">integer</span>) -5</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hsetnx 为哈希表中不存在的的字段赋值 。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX myhash field1 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 设置成功，返回 1 。</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX myhash field1 <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 如果给定字段已经存在，返回 0 。</span></span><br><span class="line">127.0.0.1:6379&gt; HGET myhash field1</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="有序集合Zset"><a href="#有序集合Zset" class="headerlink" title="有序集合Zset"></a>有序集合Zset</h4><p>在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2</p>
<p>- </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zadd 将一个或多个成员元素及其分数值加入到有序集当中。</span></span><br><span class="line"><span class="comment"># zrange 返回有序集中，指定区间内的成员</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 <span class="string">&quot;two&quot;</span> 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)</span></span><br><span class="line">次序排列。</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaoming</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 xiaohong</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 500 kuangshen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># Inf无穷大量+∞,同样地,-∞可以表示为-Inf。</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf <span class="comment"># 显示整个有序集</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores <span class="comment"># 递增排列</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">6) <span class="string">&quot;5000&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 WITHSCORES <span class="comment"># 递减排列</span></span><br><span class="line">1) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">2) <span class="string">&quot;5000&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">6) <span class="string">&quot;500&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 WITHSCORES <span class="comment"># 显示工资 &lt;=2500</span></span><br><span class="line">的所有成员</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zrem 移除有序集中的一个或多个成员</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE salary 0 -1</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem salary kuangshen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE salary 0 -1</span><br><span class="line">1) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zcard 命令用于计算集合中元素的数量。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zcount 计算有序集合中指定分数区间的成员数量。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 <span class="string">&quot;world&quot;</span> 3 <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myset 1 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myset 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaoming</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 xiaohong</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 500 kuangshen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES <span class="comment"># 显示所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">6) <span class="string">&quot;5000&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrank salary kuangshen <span class="comment"># 显示 kuangshen 的薪水排名，最少</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; zrank salary xiaohong <span class="comment"># 显示 xiaohong 的薪水排名，第三</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK salary kuangshen <span class="comment"># 狂神第三</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK salary xiaohong <span class="comment"># 小红第一</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>





<h3 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h3><h4 id="GEO地理位置"><a href="#GEO地理位置" class="headerlink" title="GEO地理位置"></a>GEO地理位置</h4><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><h3 id="配置文件-Redis-conf"><a href="#配置文件-Redis-conf" class="headerlink" title="配置文件 Redis.conf"></a>配置文件 Redis.conf</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/02/17/2025-02-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/17/2025-02-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/" class="post-title-link" itemprop="url">数据结构-数组相关算法题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-17 12:00:00" itemprop="dateCreated datePublished" datetime="2025-02-17T12:00:00+08:00">2025-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-04 14:07:57" itemprop="dateModified" datetime="2025-03-04T14:07:57+08:00">2025-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>归档用，每日刷题算法单独</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://programmercarl.com/">https://programmercarl.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/02/16/2025-02-16-VMware%E4%B8%8B%E9%85%8D%E7%BD%AEUbuntu-Server22.04.1%E5%B9%B6%E5%AE%89%E8%A3%85Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/16/2025-02-16-VMware%E4%B8%8B%E9%85%8D%E7%BD%AEUbuntu-Server22.04.1%E5%B9%B6%E5%AE%89%E8%A3%85Redis/" class="post-title-link" itemprop="url">VMware下配置Ubuntu-Server22.04.1并安装Redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-16 12:00:00" itemprop="dateCreated datePublished" datetime="2025-02-16T12:00:00+08:00">2025-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-18 14:29:26" itemprop="dateModified" datetime="2025-02-18T14:29:26+08:00">2025-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">配置</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、新建虚拟机"><a href="#一、新建虚拟机" class="headerlink" title="一、新建虚拟机"></a>一、新建虚拟机</h4><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/1.png"  alt="1" style="zoom:67%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/2.png"  alt="img" style="zoom:67%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/3.png"  alt="3" style="zoom:67%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/4.png"  alt="4" style="zoom:67%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/5.png"  alt="5" style="zoom:67%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/5-1739696139957.png"  alt="5" style="zoom:67%;" />

<p> Redis 是轻量级单线程应用并且主要依赖内存，对CPU要求不高<br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/7.png"  alt="7" style="zoom:67%;" /><br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/8.png"  alt="8" style="zoom:67%;" /></p>
<p>学习 Redis 的配置和使用，只是需要虚拟机能够联网下载包、更新系统，选用<strong>NAT 模式</strong><br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/9.png"  alt="9" style="zoom:67%;" /></p>
<p><strong>BusLogic</strong>不适用与64位系统，<strong>LSI Logic SAS</strong>配置上较复杂，选用默认配置<br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/10.png"  alt="10" style="zoom:67%;" /></p>
<p><strong>IDE</strong>属于较老的接口，主要用于旧系统，不适合现代64位客户机。<br><strong>SATA</strong>和<strong>NVMe</strong>在虚拟机环境中不如<strong>SCSI</strong>稳定，选用默认配置<br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/11.png"  alt="11" style="zoom:67%;" /></p>
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/12.png"  alt="12" style="zoom:67%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/13.png"  alt="13" style="zoom:67%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/14.png"  alt="14" style="zoom:67%;" />

<p>自定义硬件中选择镜像文件，完成UbuntuServer创建</p>
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/15.png"  alt="15" style="zoom:67%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/16.png"  alt="16" style="zoom:67%;" />

<h4 id="二、Ubuntu-22-04-安装部署"><a href="#二、Ubuntu-22-04-安装部署" class="headerlink" title="二、Ubuntu 22.04 安装部署"></a>二、Ubuntu 22.04 安装部署</h4><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/17.png"  alt="17" style="zoom:67%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/18.png"  alt="18" style="zoom: 50%;" />

<p>选择不更新到新版本<br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/19.png"  alt="19" style="zoom:50%;" /><br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/20.png"  alt="20" style="zoom:50%;" /><br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/21.png"  alt="21" style="zoom:50%;" /></p>
<p>配置阿里云(<a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a>) 镜像源地址</p>
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/25.png"  alt="25" style="zoom:50%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/26.png"  alt="26" style="zoom:50%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/27.png"  alt="27" style="zoom:50%;" />
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/28.png"  alt="28" style="zoom:50%;" />

<p><strong>设置计算机名、用户名及密码</strong><br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/29.png"  alt="29" style="zoom:50%;" /></p>
<p>不升级Ubuntu pro，选择跳过<br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/30-1739699938529.png"  alt="30" style="zoom:50%;" /></p>
<p>开启ssh服务<br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/31.png"  alt="31" style="zoom:50%;" /><br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/32.png"  alt="32" style="zoom:50%;" /><br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/33.png"  alt="33" style="zoom:50%;" /></p>
<p>点击重启，等待服务器自动重启<br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/34-1739781554269.png"  alt="34" style="zoom:50%;" /></p>
<p>按照设置的用户、密码登入后 确认ip地址，测试能否ping通其他ip地址<br>拍摄快照保存以便回档<br><img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/35-1739712940613.png"  alt="35" style="zoom:50%;" /></p>
<h4 id="三、安装Redis"><a href="#三、安装Redis" class="headerlink" title="三、安装Redis"></a>三、安装Redis</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update		更新apt软件包索引</span><br><span class="line">sudo apt install redis-server	安装redis服务和客户端</span><br><span class="line">sudo apt install redis-tools	</span><br><span class="line"></span><br><span class="line">redis-cli -v	查看版本</span><br><span class="line">redis-cli	测试连接</span><br><span class="line">127.0.0.1:6379&gt; ping	</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line">ps -ef | grep redis	查看Redis进程信息</span><br></pre></td></tr></table></figure>

<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/38.png"  alt="38" style="zoom:67%;" />



<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Redis 服务在 Ubuntu 中是由 systemd 管理的，其配置中设定了自动重启。</span><br><span class="line"><span class="bullet">-</span> 当您通过 <span class="code">`redis-cli shutdown`</span> 手动关闭 Redis 时，systemd 检测到该服务停止后，会立即将其重启，从而在进程列表中依然能看到 Redis 服务器。</span><br><span class="line"></span><br><span class="line">完全停止 Redis 服务，使用 systemd 命令</span><br><span class="line">sudo systemctl stop redis-server</span><br></pre></td></tr></table></figure>

<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/39.png"  alt="39" style="zoom:67%;" />

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59555392/article/details/144266235">https://blog.csdn.net/m0_59555392/article/details/144266235</a></p>
<h4 id="四、杂项"><a href="#四、杂项" class="headerlink" title="四、杂项"></a>四、杂项</h4><h5 id="window安装Redis"><a href="#window安装Redis" class="headerlink" title="window安装Redis"></a>window安装Redis</h5><p>进入github下载解压包或者安装包<br><a target="_blank" rel="noopener" href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p>
<p>解压到自己电脑的环境目录即可</p>
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/36.png"  alt="36" style="zoom:67%;" />
运行服务，Redis默认端口号为6379
<img src="/2025/02/16/2025-02-16-VMware下配置Ubuntu-Server22.04.1并安装Redis/37.png"  alt="37" style="zoom:67%;" />
测试连接，设置并获取Key-Value键值对

<p>Windows下使用Redis较简单，但Redis开发基本在Linux上完成，这里仅作了解就可以了</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_48577982/article/details/145010550">https://blog.csdn.net/m0_48577982/article/details/145010550</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1S54y1R7SB/?spm_id_from=333.788.videopod.episodes&vd_source=86cff7979e84d707a5b440f4d6bdecc0&p=8">https://www.bilibili.com/video/BV1S54y1R7SB/?spm_id_from=333.788.videopod.episodes&amp;vd_source=86cff7979e84d707a5b440f4d6bdecc0&amp;p=8</a></p>
<h5 id="Xshell、Xftp连接UbuntuService"><a href="#Xshell、Xftp连接UbuntuService" class="headerlink" title="Xshell、Xftp连接UbuntuService"></a>Xshell、Xftp连接UbuntuService</h5><p>…</p>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43824829/article/details/126975368">https://blog.csdn.net/weixin_43824829/article/details/126975368</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/NWVDI/article/details/143437653">https://blog.csdn.net/NWVDI/article/details/143437653</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="间"
      src="/images/new_avatar.png">
  <p class="site-author-name" itemprop="name">间</p>
  <div class="site-description" itemprop="description">面向就业学习，Java相关技术栈、面试八股文和算法题中...</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">间</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
