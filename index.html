<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/web-app-manifest-192x192.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-96x96.png">
  <link rel="mask-icon" href="/images/favicon/favicon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"souls5.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
<meta property="og:type" content="website">
<meta property="og:title" content="不是不是">
<meta property="og:url" content="https://souls5.github.io/index.html">
<meta property="og:site_name" content="不是不是">
<meta property="og:description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="间">
<meta property="article:tag" content="Java,JavaWeb,Redis,Nosql,Linux,算法,数据结构,面试,数据结构">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://souls5.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>不是不是</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不是不是</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习、挣扎和一些无关紧要的琐事...大概</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/19/2025-03-19-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2part01-%E5%AD%97%E7%AC%A6%E4%B8%B2part02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/19/2025-03-19-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2part01-%E5%AD%97%E7%AC%A6%E4%B8%B2part02/" class="post-title-link" itemprop="url">2025-03-20-第四章-字符串part01-字符串part02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-03-19 16:10:04 / 修改时间：16:15:32" itemprop="dateCreated datePublished" datetime="2025-03-19T16:10:04+08:00">2025-03-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a><strong>今日任务</strong></h3><p>part01： 344.反转字符串、 541. 反转字符串II、卡码网：54.替换数字</p>
<p>part02：151.翻转字符串里的单词、卡码网：55.右旋转字符串、 28. 实现 strStr()、<br>               459.重复的子字符串、字符串总结 、 双指针回顾 </p>
<h3 id="第四章字符串part01"><a href="#第四章字符串part01" class="headerlink" title="第四章字符串part01"></a>第四章字符串part01</h3><h5 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h5><h5 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541.反转字符串II"></a>541.反转字符串II</h5><h5 id="卡码网：54-替换数字"><a href="#卡码网：54-替换数字" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h5><h3 id="第四章字符串part02"><a href="#第四章字符串part02" class="headerlink" title="第四章字符串part02"></a>第四章字符串part02</h3><h5 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h5><h5 id="卡码网：55-右旋转字符串"><a href="#卡码网：55-右旋转字符串" class="headerlink" title="卡码网：55.右旋转字符串"></a>卡码网：55.右旋转字符串</h5><h5 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28.实现 strStr()"></a>28.实现 strStr()</h5><h5 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h5><h3 id="字符串总结"><a href="#字符串总结" class="headerlink" title="字符串总结"></a>字符串总结</h3><h3 id="双指针回顾"><a href="#双指针回顾" class="headerlink" title="双指针回顾"></a>双指针回顾</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/15/2025-03-15-%E7%AC%94%E8%AF%95%E6%9D%82%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/15/2025-03-15-%E7%AC%94%E8%AF%95%E6%9D%82%E9%A1%B9/" class="post-title-link" itemprop="url">2025-03-15-笔试杂项</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-15 19:21:41" itemprop="dateCreated datePublished" datetime="2025-03-15T19:21:41+08:00">2025-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-19 16:36:16" itemprop="dateModified" datetime="2025-03-19T16:36:16+08:00">2025-03-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">笔试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AF%95/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>记录2025春招遇到的笔试算法题为主（如果能找到的话…</p>
<h4 id="2025-03-15美团测开"><a href="#2025-03-15美团测开" class="headerlink" title="2025&#x2F;03&#x2F;15美团测开"></a>2025&#x2F;03&#x2F;15美团测开</h4><p>填空2*20，算法20+15+25</p>
<p>算法三道分别是字符串处理，加解密和fab</p>
<p>（找到题了再更新…</p>
<h4 id="2025-03-16-美团后端"><a href="#2025-03-16-美团后端" class="headerlink" title="2025&#x2F;03&#x2F;16 美团后端"></a>2025&#x2F;03&#x2F;16 美团后端</h4><p>填空3 * 20，算法2 * 20</p>
<p>第一道大概是这样<br><img src="/2025/03/15/2025-03-15-笔试杂项/6afde5f2406f53a1d49848691fb6deb.png"  alt="6afde5f2406f53a1d49848691fb6deb" style="zoom:60%;" /></p>
<p>应该是哈希，我猜重复一定次数过后就开始循环了，输出循环数组就行了（但是改烦了…<img src="/2025/03/15/2025-03-15-笔试杂项/QQ图片20250316173524.jpg"  alt="QQ图片20250316173524" style="zoom: 67%;" /></p>
<p>第二道题没怎么看…</p>
<h4 id="2025-03-16-深信服Java"><a href="#2025-03-16-深信服Java" class="headerlink" title="2025&#x2F;03&#x2F;16 深信服Java"></a>2025&#x2F;03&#x2F;16 深信服Java</h4><p>填空3*24 算法四道题一共58分</p>
<p>填空逻辑题和二叉树耽误时间有点多，算法前三道ac，最后一道读懂题目用掉的时间有长没来得及做…</p>
<h4 id="2025-03-19神州信息Java开发"><a href="#2025-03-19神州信息Java开发" class="headerlink" title="2025&#x2F;03&#x2F;19神州信息Java开发"></a>2025&#x2F;03&#x2F;19神州信息Java开发</h4><p>选择2*35，算法第一道ac，第二道状态不好没做出来</p>
<h4 id="2025-03-20小天才-步步高Web后台"><a href="#2025-03-20小天才-步步高Web后台" class="headerlink" title="2025&#x2F;03&#x2F;20小天才&amp;步步高Web后台"></a>2025&#x2F;03&#x2F;20小天才&amp;步步高Web后台</h4><h4 id="2025-03-20海康威视测试"><a href="#2025-03-20海康威视测试" class="headerlink" title="2025&#x2F;03&#x2F;20海康威视测试"></a>2025&#x2F;03&#x2F;20海康威视测试</h4><p>结束时间： 2025-03-20 23:59 星期四 </p>
<h4 id="2025-03-20中科创达Java"><a href="#2025-03-20中科创达Java" class="headerlink" title="2025&#x2F;03&#x2F;20中科创达Java"></a>2025&#x2F;03&#x2F;20中科创达Java</h4><p>结束时间：2025-03-20 23:59  星期四 </p>
<h4 id="2025-03-20绿盟科技安全服务"><a href="#2025-03-20绿盟科技安全服务" class="headerlink" title="2025&#x2F;03&#x2F;20绿盟科技安全服务"></a>2025&#x2F;03&#x2F;20绿盟科技安全服务</h4><p><strong>考试时间：2025-03-20 19:00:00 – 20:30:00</strong></p>
<h4 id="2025-03-22-360Web服务端开发"><a href="#2025-03-22-360Web服务端开发" class="headerlink" title="2025&#x2F;03&#x2F;22 360Web服务端开发"></a>2025&#x2F;03&#x2F;22 360Web服务端开发</h4><p>开始时间： 2025-03-22 15:00 星期六（为保证作答时间请在18:00前登陆）</p>
<p>结束时间： 2025-03-22 20:00 星期六 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/13/2025-03-13-%E5%93%88%E5%B8%8C%E8%A1%A8part01%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8part02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/13/2025-03-13-%E5%93%88%E5%B8%8C%E8%A1%A8part01%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8part02/" class="post-title-link" itemprop="url">2025-03-13-第三章-哈希表part01—哈希表part02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-13 14:18:50" itemprop="dateCreated datePublished" datetime="2025-03-13T14:18:50+08:00">2025-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-19 16:07:52" itemprop="dateModified" datetime="2025-03-19T16:07:52+08:00">2025-03-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"> 代码随想哈希表理论基础</a></p>
<h3 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a><strong>今日任务</strong></h3><p>part01：哈希表理论基础、 242.有效的字母异位词 、 349. 两个数组的交集 、202. 快乐数 、 1. 两数之和 </p>
<p>part02：454.四数相加II 、383. 赎金信  、15. 三数之和 、 18. 四数之和  </p>
<h3 id="第三章-哈希表part01"><a href="#第三章-哈希表part01" class="headerlink" title="第三章 哈希表part01"></a>第三章 哈希表part01</h3><h4 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h4><h5 id="哈希表-Hash-table"><a href="#哈希表-Hash-table" class="headerlink" title="哈希表(Hash table)"></a><strong>哈希表(Hash table)</strong></h5><p>国内也有一些算法书籍翻译为散列表</p>
<blockquote>
<p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
</blockquote>
<p>简单来讲其实数组就是一张哈希表。<br>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：<br><img src="/2025/03/13/2025-03-13-哈希表part01—哈希表part02/20210104234805168.png"  alt="哈希表1" style="zoom: 50%;" /></p>
<p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p>
<p>例如要查询一个名字是否在这所学校里。<br>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。<br>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p>
<p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p>
<h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a><strong>哈希函数</strong></h5><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p>
<p>哈希函数如下图所示，<br>通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，<br>可以<strong>将其他数据格式转化为不同的数值</strong>，这样就把学生名字映射为哈希表上的索引数字了。<br><img src="/2025/03/13/2025-03-13-哈希表part01—哈希表part02/2021010423484818.png"  alt="哈希表2" style="zoom:50%;" /></p>
<ul>
<li>如果hashCode得到的<strong>数值大于哈希表的大小</strong>了，也就是大于tableSize了，怎么办呢？<ul>
<li>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个<strong>取模</strong>的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</li>
</ul>
</li>
</ul>
<p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。如果学生的数量大于哈希表的大小怎么办，<br>此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。此时需要用到<strong>哈希碰撞</strong></p>
<h5 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a><strong>哈希碰撞</strong></h5><p>如图所示，小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。<br><img src="/2025/03/13/2025-03-13-哈希表part01—哈希表part02/2021010423494884.png"  alt="哈希表3" style="zoom:50%;" /></p>
<p>一般哈希碰撞有两种解决方法， <strong>拉链法</strong>和<strong>线性探测法</strong>。</p>
<ul>
<li><p><strong>拉链法</strong><br>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。<br>这样我们就可以通过索引找到小李和小王了</p>
<img src="/2025/03/13/2025-03-13-哈希表part01—哈希表part02/20210104235015226.png"  alt="哈希表4" style="zoom: 50%;" />
（数据规模是dataSize， 哈希表的大小为tableSize）
拉链法要选择适当的哈希表的大小，
既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。
</li>
<li><p><strong>线性探测法</strong><br>使用线性探测法，一定要保证tableSize大于dataSize。<br>我们需要依靠哈希表中的空位来解决碰撞问题。</p>
<ul>
<li>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。</li>
<li>所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。<img src="/2025/03/13/2025-03-13-哈希表part01—哈希表part02/20210104235109950.png"  alt="哈希表5" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h5 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h5><p>当我们需要使用哈希法来解决问题时，通常会选择以下三种数据结构：</p>
<ul>
<li>数组</li>
<li>Set（集合）</li>
<li>Map（映射）</li>
</ul>
<p>在 Java 中，<code>HashSet</code> 和 <code>HashMap</code> 是最常用的实现，它们的底层实现和使用方式如下：</p>
<h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong><code>HashSet</code></strong></h6><p><code>HashSet</code> 是一个<strong>不允许有重复元素</strong>的<strong>集合</strong>，其底层通过 <code>HashMap</code> 实现。<br>每个被添加到 <code>HashSet</code> 的元素实际上作为 <code>HashMap</code> 的键（<code>key</code>）存储，而值（<code>value</code>）则是一个固定的常量对象。</p>
<p><code>HashSet</code> 的主要特性：</p>
<ul>
<li><strong>无序</strong>：元素没有特定的顺序。</li>
<li><strong>唯一性</strong>：不允许有重复元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码：</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 重复元素，不会被添加</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>&quot;Alice&quot;</code> 被添加了两次，但在 <code>HashSet</code> 中只会存储一个 <code>&quot;Alice&quot;</code>，因为 <code>HashSet</code> 不允许重复元素。</p>
<h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong><code>HashMap</code></strong></h6><p><code>HashMap</code> 是一个<strong>键值对（<code>key-value</code>）映射</strong>的数据结构，允许根据键快速查找对应的值。其主要特性包括：</p>
<ul>
<li><strong>无序</strong>：键值对没有特定的顺序。</li>
<li><strong>键的唯一性</strong>：每个键只能对应一个值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码：</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">28</span>); <span class="comment">// 键相同，后面的值会覆盖前面的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>&quot;Alice&quot;</code> 的年龄先被设置为 <code>30</code>，随后又被更新为 <code>28</code>，因为在 <code>HashMap</code> 中，相同的键会覆盖之前的值。</p>
<h6 id="HashSet-与-HashMap-的底层实现"><a href="#HashSet-与-HashMap-的底层实现" class="headerlink" title="HashSet 与 HashMap 的底层实现"></a><strong><code>HashSet</code> 与 <code>HashMap</code> 的底层实现</strong></h6><p>在 Java 中，<code>HashSet</code> 的底层是通过 <code>HashMap</code> 实现的。<br>具体而言，<code>HashSet</code> 内部维护了一个 <code>HashMap</code> 实例，每当向 <code>HashSet</code> 中添加元素时，实际上是将该元素作为键存储到 <code>HashMap</code> 中，而值则是一个固定的常量对象。<br>这种设计利用了 <code>HashMap</code> 键的唯一性特性，确保了 <code>HashSet</code> 中元素的唯一性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>HashSet</code> 通过一个 <code>HashMap</code> 实例 <code>map</code> 来存储元素。<br><code>PRESENT</code> 是一个静态常量对象，作为所有键对应的值。<br>每次调用 <code>add</code> 方法时，实际上是向 <code>map</code> 中添加一个键值对，其中键是元素本身，值是 <code>PRESENT</code>。<br>这种设计确保了 <code>HashSet</code> 中元素的唯一性，因为 <code>HashMap</code> 的键是唯一的。</p>
<p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p>
<h5 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/submissions/610170724/">https://leetcode.cn/problems/valid-anagram/submissions/610170724/</a></p>
<p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li>
<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>
</ul>
<p><strong>字典解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution242</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">            <span class="comment">// 判断长度</span></span><br><span class="line">            <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始化计数数组</span></span><br><span class="line">            <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="comment">// 遍历字符串 s，增加计数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历字符串 t，减少计数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">                count[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查计数数组是否全为零</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>依次遍历字符串的每一位，将其字母出现的频率反应到计数数组上<ul>
<li><code>s.charAt(i)</code>将字符串作为数组处理返回第 i 个字母</li>
<li><code>a</code>将</li>
</ul>
</li>
</ul>
<p>**时间复杂度O(m+n) **<br><strong>空间复杂度O(1)</strong></p>
<h5 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">https://leetcode.cn/problems/intersection-of-two-arrays/description/</a></p>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 它们的 <em><strong>交集</strong></em>。<br>输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>
<p><strong>数组解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection_arr(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="type">int</span>[] hash1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">    <span class="type">int</span>[] hash2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums1)</span><br><span class="line">        hash1[i]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums2)</span><br><span class="line">        hash2[i]++;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1002</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash1[i] &gt; <span class="number">0</span> &amp;&amp; hash2[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            resList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[resList.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : resList)</span><br><span class="line">        res[index++] = i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义两个数组<code>hash1</code>、<code>hash2</code>，分别<strong>遍历</strong>数组<code>nums1</code>、<code>nums2</code>，更新<strong>hash数组</strong>中第<code>num[i]</code>给元素的值</li>
<li>定义集合<code>resList</code>，<strong>遍历hash数组</strong>，使用<code>resList</code>存储两<strong>hash数组</strong>中值均不为0的下标索引，即为数组<code>num1</code>、<code>num2</code><strong>交集</strong></li>
<li>将集合<code>resList</code>转化为数组<code>res</code>，返回数组</li>
</ul>
<p><strong>Set解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection_set(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历数组1，将其转化为哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">        set1.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组2，查询哈希表中是否存在该元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">            resSet.add(i);<span class="comment">//如果存在，将其添加至集合resSet中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将集合转化为数组</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[resSet.size()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : resSet)&#123;</span><br><span class="line">        res[j++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>遍历</strong>数组1，将其转化为<strong>Set</strong>结构的哈希表<code>HashSet</code></li>
<li><strong>遍历</strong>数组2，查询<code>HashSet</code>中是否存在该元素，如果存在，则说明该元素为两数组<strong>交集</strong>，将其添加至集合<code>resSet</code>中</li>
<li>将<code>resSet</code>转换为数组，返回数组<code>res</code></li>
</ul>
<h5 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></p>
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; n &lt;&#x3D; 2<sup>31</sup> - 1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// n = 1 或 集合record中包含元素 n 时结束循环</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !record.contains(n)) &#123;</span><br><span class="line">        record.add(n);</span><br><span class="line">        n = getNextNumber(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">        res += temp * temp;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>isHappy</code> 方法接受整数 <code>n</code> ，返回布尔值</p>
<ul>
<li>使用 <code>while</code> 循环：<strong>n &#x3D; 1</strong> 或 <strong>集合record中包含元素 n</strong> 时结束循环（表示出现循环，不是快乐数）<ul>
<li>将当前的 <code>n</code> 添加到 <code>record</code> 集合中。</li>
<li>调用 <code>getNextNumber(n)</code> 方法，计算并更新 <code>n</code> 为其各位数字的平方和。</li>
</ul>
</li>
<li>循环结束后，判断 <code>n</code> 是否为 1，如果是，则返回 <code>true</code>，否则返回 <code>false</code></li>
</ul>
</li>
<li><p><code>getNextNumber</code> 方法接受整数 <code>n</code> ，返回 <code>n</code> 的各位数字的平方和。</p>
<ul>
<li>使用 <code>while</code> 循环，直到 <code>n</code> 等于 0<ul>
<li>通过 <code>n % 10</code> 获取 <code>n</code> 的个位数字，并存储在 <code>temp</code> 中。</li>
<li>将 <code>temp</code> 的平方加到 <code>res</code> 上。</li>
<li>将 <code>n</code> 除以 10，以去掉个位数字。</li>
</ul>
</li>
<li>返回累加结果 <code>res</code></li>
</ul>
</li>
<li><p>时间复杂度: O(logn)</p>
</li>
<li><p>空间复杂度: O(logn)</p>
</li>
</ul>
<h5 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/description/">https://leetcode.cn/problems/two-sum/description/</a></p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，<br>请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>2 &lt;&#x3D; nums.length &lt;&#x3D; 10<sup>4</sup></li>
<li>-10<sup>9</sup> &lt;&#x3D; nums[i] &lt;&#x3D; 10<sup>9</sup></li>
<li>-10<sup>9</sup> &lt;&#x3D; target &lt;&#x3D; 10<sup>9</sup></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span>  target) &#123;</span><br><span class="line">    <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">            res[<span class="number">1</span>]=i;</span><br><span class="line">            res[<span class="number">0</span>]=map.get(temp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>twoSum</code>方法接收数组<code>nums</code>、整数<code>target</code>，返回大小为2的数组<code>res</code></li>
<li>数组<code>nums</code>为空时直接返回空数组[0, 0]</li>
<li>定义映射<code>map</code>为哈希表，遍历数组<ul>
<li>寻找哈希表中是否存在值为<code>target - num[i]</code>的元素<ul>
<li>若存在，则将该轮遍历的数组下标和<code>map</code>中键为<code>target - num[i]</code>的值存入数组<code>res</code>，使用<code>break</code>结束循环</li>
</ul>
</li>
<li>将该轮遍历的值存入映射<code>map</code>的键，数组下标存入值<ul>
<li>(循环中查找的是数组中的值，而需要返回的是数组下标</li>
</ul>
</li>
</ul>
</li>
<li>返回数组<code>res</code></li>
</ul>
<h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><ul>
<li><p><strong>需要使用哈希法的场景</strong>：</p>
<ul>
<li>快速判断元素是否存在于集合中、统计元素出现频率、<br>处理需要快速查找的场景、<br>检测重复元素、实现缓存机制</li>
</ul>
</li>
<li><p><strong>增强for循环的使用</strong>：简化数组和集合遍历</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (元素类型 变量名 : 遍历对象) &#123;</span><br><span class="line">    <span class="comment">// 操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : nums1)</span><br><span class="line">    hash1[i]++;</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">    hash1[nums1[i]]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>数组 or Set or Map</strong><ul>
<li><strong>数组</strong>：<ul>
<li>直接用下标作映射</li>
<li>数值较大&#x2F;较分散时，数组下标过大，会浪费存储空间</li>
</ul>
</li>
<li><strong>Set</strong>：<ul>
<li>每插入一个值都需要使用哈希运算将其转变为另一个值，<br>同时还需要开辟一个新空间</li>
<li>插入值较多时开销较大</li>
</ul>
</li>
<li><strong>Map</strong>：<ul>
<li>存储<strong>键值对</strong>，可根据<strong>键</strong>快速查找对应的<strong>值</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第三章-哈希表part02"><a href="#第三章-哈希表part02" class="headerlink" title="第三章 哈希表part02"></a>第三章 哈希表part02</h3><h5 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/description/">https://leetcode.cn/problems/4sum-ii/description/</a></p>
<p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，<br>请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：<br><code>0 &lt;= i, j, k, l &lt; n</code><br><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length</code>、<code>n == nums2.length</code>、<br><code>n == nums3.length</code>、<code>n == nums4.length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li>-2<sup>28</sup> &lt;&#x3D; nums1[i], nums2[i], nums3[i], nums4[i] &lt;&#x3D; 2<sup>28</sup></li>
</ul>
<p>暴力解法：四重for循环，时间复杂度为O(n) &#x3D; n<sup>4</sup>，不考虑</p>
<p> <strong>优化解法：使用哈希表</strong>：时间复杂度可降为O(n) &#x3D; n<sup>2</sup></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建哈希表，存储nums1和nums2元素之和及其出现次数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历nums3和nums4，查找其相反数是否存在于哈希表中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums3.length; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; nums4.length; l++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums3[k] + nums4[l];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(-sum)) &#123;</span><br><span class="line">                count += map.get(-sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法<code>fourSum</code>接受四个数组，返回满足条件的四元组数量</li>
<li>定义映射<code>map</code>为哈希表，遍历<code>nums1</code>、<code>nums2</code>两个数组，每轮遍历：<ul>
<li>将<code>num1[i]</code>和<code>num2[j]</code>相加，值为<code>sum</code></li>
<li><code>map.put(sum, map.getOrDefault(sum, 0) + 1)</code>：<ul>
<li>从 <code>map</code> 中获取键 <code>sum</code> 所对应的值：如果该键存在，将值+1，否则返回1 (0+1)</li>
<li>将键 <code>sum</code> 和更新后的值重新放入 <code>map</code> 中</li>
</ul>
</li>
</ul>
</li>
<li>遍历<code>nums3</code>nums4&#96;两个数组，每轮遍历：<ul>
<li>将<code>num3[k]</code>和<code>num4[l]</code>相加，值为<code>sum</code></li>
<li><code>map.containsKey(-sum)</code>：<br>在哈希表 <code>map</code> 中查找键 <code>0-sum</code>，如果存在则将值加到计数器<code>conut</code>上</li>
</ul>
</li>
</ul>
<h5 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">https://leetcode.cn/problems/ransom-note/</a></p>
<p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。<br>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。<br><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; <code>ransomNote.length</code>, <code>magazine.length</code> &lt;&#x3D; 10<sup>5</sup></li>
<li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li>
</ul>
<p>与<code>242.有效的字母异位词 </code>这道题思路大致相同：</p>
<p>遇到判断字符串&#x2F;字母类的题可优先考虑选用数组<code>int[26]</code>作为哈希表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断长度</span></span><br><span class="line">    <span class="keyword">if</span> (ransomNote.length() &gt; magazine.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">        hash[magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">        hash[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p>**注意：**答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code> -105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>哈希法</strong></p>
<p>两重循环，内层循环每次循环时使用<code>set.contains</code>查找是否存在满足条件的第三个数，不存在则将内层循环的数加入集合<code>set</code>中</p>
<p>注意题目中要求不能取重复位置的数，本题使用哈希法<strong>去重条件</strong>较复杂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSumHash</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 用于存储结果的列表</span></span><br><span class="line">    Arrays.sort(nums);<span class="comment">// 数组排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，固定第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果排序后的当前元素大于0，后续元素也会大于0，不可能组成和为0的三元组</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过重复的元素，避免结果中出现重复的三元组</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用哈希集合存储已经遍历过的元素</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历数组中剩余的元素，寻找符合条件的三元组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复的元素</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">2</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] &amp;&amp; nums[j - <span class="number">1</span>] == nums[j - <span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算第三个数的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -nums[i] - nums[j];</span><br><span class="line">            <span class="comment">// 如果集合中包含这个值，说明找到了一个符合条件的三元组</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(c)) &#123;</span><br><span class="line">                result.add(Arrays.asList(nums[i], nums[j], c));</span><br><span class="line">                <span class="comment">// 移除集合中的该值，避免重复</span></span><br><span class="line">                set.remove(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将当前元素添加到集合中</span></span><br><span class="line">                set.add(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>threeSumDoubleIndex</code>方法接收数组<code>nums</code>，返回列表（二维数组）</li>
<li>定义列表<code>result</code>存储结果，调用<code>Arrays.sort()</code>方法给数组排序</li>
<li></li>
</ul>
<p><strong>双指针法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSumDoubleIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 用于存储结果的列表</span></span><br><span class="line">    Arrays.sort(nums); <span class="comment">// 对数组进行排序</span></span><br><span class="line">    <span class="comment">// 遍历数组，固定第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素大于0，后续元素也会大于0，不可能组成和为0的三元组</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过重复的元素，避免结果中出现重复的三元组</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当左指针小于右指针时，进行循环</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果三数之和大于0，说明右指针指向的值过大，需要左移</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果三数之和小于0，说明左指针指向的值过小，需要右移</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到一个符合条件的三元组</span></span><br><span class="line">                result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                <span class="comment">// 跳过重复的元素</span></span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                <span class="comment">// 移动指针，寻找下一个可能的三元组</span></span><br><span class="line">                right--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>threeSumDoubleIndex</code>方法接收数组<code>nums</code>，返回列表（二维数组）</li>
<li>定义列表<code>result</code>存储结果，调用<code>Arrays.sort()</code>方法给数组排序</li>
</ul>
<h5 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h5><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/10/2025-03-10-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%93%BE%E8%A1%A8part01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/10/2025-03-10-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%93%BE%E8%A1%A8part01/" class="post-title-link" itemprop="url">2025-03-11-第二章-链表part01—链表part02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-10 16:59:00" itemprop="dateCreated datePublished" datetime="2025-03-10T16:59:00+08:00">2025-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-13 14:13:47" itemprop="dateModified" datetime="2025-03-13T14:13:47+08:00">2025-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"> 代码随想链表理论基础</a></p>
<h3 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a><strong>今日任务</strong></h3><p>part01：链表理论基础 、203.移除链表元素 、707.设计链表 、206.反转链表 </p>
<p>part02：24. 两两交换链表中的节点 、19.删除链表的倒数第N个节点 、<br>               面试题 02.07. 链表相交、142.环形链表II 、总结</p>
<h3 id="第二章-链表part01"><a href="#第二章-链表part01" class="headerlink" title="第二章 链表part01"></a>第二章 链表part01</h3><h5 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h5><p>链表是一种通过指针串联在一起的线性结构，<br>每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
<p>链表的入口节点称为链表的头结点也就是head。<br>如图所示：<br><img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806194529815.png"  alt="链表1" style="zoom: 50%;" /></p>
<p><strong>链表的类型</strong></p>
<ul>
<li><p><strong>单链表</strong>：如上所述</p>
</li>
<li><p><strong>双链表</strong>：<br>单链表中的指针域只能指向节点的下一个节点。<br>而双链表每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。<br>所以双链表 既可以向前查询也可以向后查询。</p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806194559317.png"  alt="链表2" style="zoom:50%;" />
</li>
<li><p><strong>循环链表</strong>：链表首尾相连，可以用来解决约瑟夫环问题</p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806194629603.png"  alt="链表4" style="zoom:50%;" /></li>
</ul>
<p><strong>链表的存储方式</strong></p>
<p>链表是通过指针域的指针链接在内存中各个节点。</p>
<p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。<br><img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806194613920.png"  alt="链表3" style="zoom:67%;" /></p>
<p><strong>链表的定义</strong> (使用 <strong>自定义类 <code>ListNode</code></strong> 来定义链表节点)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;      <span class="comment">// 存储节点的值</span></span><br><span class="line">    ListNode next; <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 只有值的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有值和下一个节点指针的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Java 的构造函数</strong>： Java 类中的一种特殊方法，当创建对象时自动调用</p>
<ul>
<li><strong>初始化对象</strong>，为对象的字段（变量）赋初值。</li>
<li><strong>与类同名</strong>，且 <strong>没有返回值</strong>（包括 <code>void</code> 也不能写）</li>
<li><strong>可以重载</strong>（即<strong>多个构造方法</strong>），以支持不同的初始化方式</li>
</ul>
</li>
<li><p><code>ListNode</code> 类中的构造函数解析</p>
</li>
<li><p><strong>无参构造函数</strong>：</p>
<ul>
<li><p><strong>不设置任何初始值</strong>，即 <code>val</code> 默认为 <code>0</code>，<code>next</code> 默认为 <code>null</code>。</p>
<ul>
<li>适用于 <strong>先创建空节点，再赋值</strong> 的情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(); <span class="comment">// val = 0, next = null</span></span><br><span class="line">node.val = <span class="number">10</span>;</span><br><span class="line">node.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>只有值的构造函数</strong>：</p>
<ul>
<li>创建 <strong>仅存储数据、不指向其他节点</strong> 的单个节点，适用于 <strong>逐步构造链表</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>); <span class="comment">// 创建一个值为 5 的节点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有值和下一个节点指针的构造函数</strong>：</p>
<ul>
<li><strong>同时初始化节点的值和指向的下一个节点</strong>，适用于 <strong>创建多个节点连接的链表</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>, node1); <span class="comment">// node2 -&gt; node1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>)));</span><br><span class="line"><span class="comment">// 生成链表： 1 -&gt; 2 -&gt; 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这样可以<strong>一行代码创建链表</strong>，简化构造流程。</li>
</ul>
</li>
<li><p>为什么需要三种构造函数</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>构造函数</th>
<th>适用场景</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>无参构造</td>
<td>先创建节点再赋值</td>
<td>适用于动态添加节点</td>
</tr>
<tr>
<td>只有值的构造</td>
<td>只存储值，不指定后续节点</td>
<td>适用于<strong>构建独立节点</strong></td>
</tr>
<tr>
<td>值 + 指针构造</td>
<td>直接构建完整链表结构</td>
<td><strong>简化链表创建</strong>，减少手动赋值</td>
</tr>
</tbody></table>
<ul>
<li>三种构造函数的使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 无参构造（手动赋值）</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        node1.val = <span class="number">10</span>;</span><br><span class="line">        node1.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 只有值的构造</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 值 + 指针构造</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">40</span>, node2); <span class="comment">// node3 -&gt; node2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 一行构造完整链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">        printList(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>链表的操作</strong></p>
<ul>
<li><p><strong>删除节点</strong></p>
<p>删除D节点，如图所示：</p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806195114541-20230310121459257.png"  alt="链表-删除节点" style="zoom:33%;" />
只要将C节点的next指针 指向E节点就可以了。

<p>此时D节点依然存留在内存里，只不过是没有在这个链表里而已。所以在C++里最好是再手动释放这个D节点，释放这块内存。</p>
<p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p>
</li>
<li><p><strong>添加节点</strong></p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806195134331-20230310121503147.png"  alt="链表-添加节点" style="zoom: 33%;" />
可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。

<p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p>
</li>
</ul>
<p><strong>性能分析</strong></p>
<p>再把链表的特性和数组的特性进行一个对比，如图所示：<br><img src="/2025/03/10/2025-03-10-第二章-链表part01/20200806195200276.png"  alt="链表-链表与数据性能对比" style="zoom: 50%;" /></p>
<p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>
<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<h5 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/description/">https://leetcode.cn/problems/remove-linked-list-elements/description/</a></p>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，<br>请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/removelinked-list.jpg"  alt="img" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数目在范围 [0, 10<sup>4</sup>] 内</li>
<li><code>1 &lt;= Node.val &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
<p><strong>原链表删除元素</strong></p>
<ul>
<li>判断是否移除头结点（可能需要连续移除，使用while循环作判断）<ul>
<li>删除元素为头结点则将头结点后移，</li>
</ul>
</li>
<li>定义临时指针curr，从head开始 ——&gt; 避免单向链表找不到上一个节点的问题<ul>
<li>使用临时指针 <code>curr</code> 来遍历和操作链表</li>
</ul>
</li>
<li>循环条件包含 <code>head != null</code> &#x2F; <code>curr!= null</code> ——&gt;避免操作空指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements1</span><span class="params">(ListNode head, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义临时指针curr，从head开始 ——&gt; 避免单向链表找不到上一个节点的问题</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head; </span><br><span class="line">    <span class="keyword">while</span>(curr!= <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.next.val == val)&#123;</span><br><span class="line">            curr.next = curr.next.next; <span class="comment">// 删除元素，将指针指向下一个元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            curr = curr.next; <span class="comment">//无需删除元素，遍历下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head; <span class="comment">//返回链表头节点，通过打印链表方法可输出整个链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用虚拟头结点</strong></p>
<ul>
<li>引入虚拟头节点来简化对头节点的删除操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements2</span><span class="params">(ListNode head, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个值为 0 的虚拟头节点 dummy，并将其 next 指向原链表的头节点 head。</span></span><br><span class="line">    <span class="comment">//这样，即使需要删除头节点，也能方便地处理。</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">//临时指针 curr用于遍历链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span>(curr.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.next.val == val)&#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/description/">https://leetcode.cn/problems/design-linked-list/description/</a></p>
<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>
<p>实现 <code>MyLinkedList</code> 类：</p>
<ul>
<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>
<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>
<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>
<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>
<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	输入</span></span><br><span class="line"><span class="code">[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]</span></span><br><span class="line"><span class="code">[[], [1], [3], [1, 2], [1], [1], [1]]</span></span><br><span class="line"><span class="code">	输出</span></span><br><span class="line"><span class="code">[null, null, null, null, 2, null, 3]</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	解释</span></span><br><span class="line"><span class="code">MyLinkedList myLinkedList = new MyLinkedList();</span></span><br><span class="line"><span class="code">myLinkedList.addAtHead(1);</span></span><br><span class="line"><span class="code">myLinkedList.addAtTail(3);</span></span><br><span class="line"><span class="code">myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span></span><br><span class="line"><span class="code">myLinkedList.get(1);              // 返回 2</span></span><br><span class="line"><span class="code">myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span></span><br><span class="line"><span class="code">myLinkedList.get(1);              // 返回 3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= index, val &lt;= 1000</code></li>
<li>请不要使用内置的 LinkedList 库。</li>
<li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li>
</ul>
<p><strong>定义一个链表节点类</strong><br>包含节点的值 <code>val</code> 、指向下一个节点的引用 <code>next</code><br>	以及两个成员变量：<code>size</code> 用于存储链表元素的个数，<code>head</code> 记录的是虚拟头结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val=val;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//size存储链表元素的个数</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"> <span class="comment">//注意这里记录的是虚拟头结点</span></span><br><span class="line"> <span class="keyword">private</span> ListNode head;</span><br></pre></td></tr></table></figure>

<p><strong>需要实现功能如下：</strong></p>
<ul>
<li>初始化链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取第N个节点的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//第0个节点是虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>头部插入节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    newNode.next = head.next;</span><br><span class="line">    head.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 在链表最前面插入一个节点，等价于在第0个元素前添加</span></span><br><span class="line">    <span class="comment">// addAtIndex(0, val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尾部插入节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span></span><br><span class="line">    <span class="comment">// addAtIndex(size, val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第N个节点前插入节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line"><span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line"><span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">    newNode.next = pre.next;</span><br><span class="line">    pre.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除第N个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为有虚拟头节点，所以不用对index=0的情况进行特殊处理</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = pre.next.next;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//注意这里记录的是虚拟头结点</span></span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值，注意index是从0开始的，第0个节点就是虚拟头结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//第0个节点是虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = head.next;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">// 在链表最前面插入一个节点，等价于在第0个元素前添加</span></span><br><span class="line">        <span class="comment">// addAtIndex(0, val);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span></span><br><span class="line">        <span class="comment">// addAtIndex(size, val);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = pre.next;</span><br><span class="line">        pre.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为有虚拟头节点，所以不用对index=0的情况进行特殊处理</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h5><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/rev1ex1.jpg"  alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/rev1ex2.jpg"  alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶</strong>：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p><strong>双指针解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义一个临时指针，用于循环的时候保存下一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        temp = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>cur</code>指向头节点遍历链表，<br><code>prve</code>为当前节点的上一个节点，初值为null —&gt; 链表反转后，原链表头节点的下一个节点为null<br>定义一个临时指针<code>temp</code>，用于循环的时候保存下一个节点</p>
</li>
<li><p>每次循环完成如下操作，直至<code>cur</code>循环到null</p>
<ul>
<li><strong>暂存下一个节点：</strong> 使用 <code>nextTemp</code> 暂存 <code>curr</code> 的下一个节点，防止链表断裂。</li>
<li><strong>反转指针：</strong> 将 <code>curr</code> 的 <code>next</code> 指向 <code>prev</code>，实现当前节点指针反转。</li>
<li><strong>移动指针：</strong> 将 <code>prev</code> 移动到 <code>curr</code>，<code>curr</code> 移动到 <code>nextTemp</code>，即下一个节点。</li>
</ul>
</li>
<li><p>遍历结束后，<code>prev</code> 即为新的头节点，返回 <code>prev</code></p>
</li>
</ul>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/screenshot_2025_03_12T16_42_01+0800.png"  alt="screenshot_2025_03_12T16_42_01+0800" style="zoom:33%;" />



<p><strong>递归解法</strong></p>
<p><strong>递归解法在逻辑上和是双指针法等效的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList2</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode prev, ListNode cur)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    temp = cur.next;</span><br><span class="line">    cur.next = prev;</span><br><span class="line">    <span class="comment">// 更新prev、cur位置</span></span><br><span class="line">    <span class="comment">// prev = cur;</span></span><br><span class="line">    <span class="comment">// cur = temp;</span></span><br><span class="line">    <span class="keyword">return</span> reverse(cur, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>递归终止条件：</strong> 当链表为空（<code>head == null</code>）或仅有一个节点（<code>head.next == null</code>）时，直接返回该节点作为新的头节点。</li>
<li><strong>递归调用：</strong> 对 <code>head.next</code> 进行递归调用，反转剩余的链表，返回新的头节点 <code>newHead</code>。</li>
<li><strong>反转指针：</strong> 将当前节点的下一个节点的 <code>next</code> 指向当前节点，即 <code>head.next.next = head</code>，实现当前节点与下一个节点的连接反转。</li>
<li><strong>断开连接：</strong> 将当前节点的 <code>next</code> 设为 <code>null</code>，断开原始链表中当前节点与下一个节点的连接，防止形成环。</li>
<li><strong>返回新头节点：</strong> 递归完成后，<code>newHead</code> 即为反转后的新头节点，返回 <code>newHead</code>。</li>
</ul>
<p>两种写法时间复杂度都为: O(n)；<br>双指针空间复杂度为: O(1)、递归写法空间复杂度: O(n), 递归调用了 n 层栈空间；</p>
<h3 id="第二章-链表part02"><a href="#第二章-链表part02" class="headerlink" title="第二章 链表part02"></a>第二章 链表part02</h3><h5 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。<br>你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/swap_ex1.jpg"  alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dumyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dumyhead.next = head; <span class="comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dumyhead;</span><br><span class="line">        ListNode temp; <span class="comment">// 临时节点，保存两个节点后面的节点</span></span><br><span class="line">        ListNode firstnode; <span class="comment">// 临时节点，保存两个节点之中的第一个节点</span></span><br><span class="line">        ListNode secondnode; <span class="comment">// 临时节点，保存两个节点之中的第二个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = cur.next.next.next;</span><br><span class="line">            firstnode = cur.next;</span><br><span class="line">            secondnode = cur.next.next;</span><br><span class="line">            cur.next = secondnode;       <span class="comment">// 步骤一</span></span><br><span class="line">            secondnode.next = firstnode; <span class="comment">// 步骤二</span></span><br><span class="line">            firstnode.next = temp;      <span class="comment">// 步骤三</span></span><br><span class="line">            cur = firstnode; <span class="comment">// cur移动，准备下一轮交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>创建虚拟头结点：</strong> 为了方便处理头节点的交换情况，创建一个虚拟头结点 <code>dummyHead</code>，其 <code>next</code> 指向原链表的头节点 <code>head</code>。</li>
<li><strong>初始化指针：</strong> 使用指针 <code>cur</code> 指向虚拟头结点 <code>dummyHead</code>，以便在循环中进行节点交换操作。</li>
<li><strong>遍历链表：</strong> 在 <code>cur.next</code> 和 <code>cur.next.next</code> 都不为 <code>null</code> 的情况下，进行以下操作：<ul>
<li><strong>定义要交换的节点：</strong> <code>firstNode</code> 指向 <code>cur.next</code>，即第一个要交换的节点；<code>secondNode</code> 指向 <code>cur.next.next</code>，即第二个要交换的节点。</li>
<li><strong>交换节点：</strong> 首先将 <code>firstNode.next</code> 指向 <code>secondNode.next</code>，然后将 <code>secondNode.next</code> 指向 <code>firstNode</code>，最后将 <code>cur.next</code> 指向 <code>secondNode</code>。这样就完成了两个节点的交换。</li>
<li><strong>移动指针：</strong> 将 <code>cur</code> 移动到 <code>firstNode</code>，为下一次交换做准备。</li>
</ul>
</li>
<li><strong>返回新头节点：</strong> 循环结束后，返回 <code>dummyHead.next</code>，即交换后的新头节点。</li>
</ol>
<p><strong>在每轮循环结束后，指针 <code>cur</code> 会移动到下一轮需要操作的第一个节点的前一个节点</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/screenshot_2025_03_13T09_35_32+0800.png"  alt="screenshot_2025_03_13T09_35_32+0800" style="zoom: 25%;" /></p>
<h5 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h5><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<img src="/2025/03/10/2025-03-10-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%93%BE%E8%A1%A8part01/remove_ex1.jpg" class="" title="img">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>双指针法</strong></p>
<p>让<code>fast</code>先移动n步，然后让<code>fast</code>和<code>slow</code>同时移动，<br>直到<code>fast</code>指向null。删掉<code>slow</code>所指向的节点就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="面试题-02-07-链表相交略"><a href="#面试题-02-07-链表相交略" class="headerlink" title="面试题 02.07. 链表相交	略"></a>面试题 02.07. 链表相交	略</h5><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交**：**<br><img src="/2025/03/10/2025-03-10-第二章-链表part01/160_statement.png"  alt="img" style="zoom: 50%;" />]</p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>示例 1：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/160_example_1.png"  alt="img" style="zoom: 50%;" />]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/160_example_2.png"  alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/160_example_3.png"  alt="img" style="zoom: 50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>0 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>
</ul>
<p>**进阶：**你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<h5 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h5><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/circularlinkedlist.png"  alt="img" style="zoom: 67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/circularlinkedlist_test2.png"  alt="img" style="zoom: 67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong><br><img src="/2025/03/10/2025-03-10-第二章-链表part01/circularlinkedlist_test3.png"  alt="img" style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p>**进阶：**你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<ul>
<li><p><strong>142.1确认是否有环</strong>：</p>
<ul>
<li>使用快慢指针，快指针步长为2，慢指针步长为1</li>
<li>快指针追上慢指针则说明链表中存在环</li>
</ul>
</li>
<li><p><strong>142.2找环的入口</strong></p>
<img src="/2025/03/10/2025-03-10-第二章-链表part01/screenshot_2025_03_13T14_05_44+0800.png"  alt="screenshot_2025_03_13T14_05_44+0800" style="zoom: 33%;" />

<p>综上，快慢指针相遇时，定义两个新指针以同样步长分别从头结点和相遇位置出发直到相遇，相遇点即为环入口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution142</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/07/2025-03-07-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E7%BB%84part01-%E6%95%B0%E7%BB%84part02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/07/2025-03-07-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E7%BB%84part01-%E6%95%B0%E7%BB%84part02/" class="post-title-link" itemprop="url">2025-03-07-第一章-数组part01-数组part02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-07 11:55:15" itemprop="dateCreated datePublished" datetime="2025-03-07T11:55:15+08:00">2025-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-11 10:33:38" itemprop="dateModified" datetime="2025-03-11T10:33:38+08:00">2025-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"> 代码随想录数组理论基础</a></p>
<h3 id="今日任务"><a href="#今日任务" class="headerlink" title="今日任务"></a><strong>今日任务</strong></h3><p>part01：数组理论基础，704. 二分查找，27. 移除元素，<br>part02：209.长度最小的子数组， 59.螺旋矩阵II，<br>补充可选（可复习时做）：58.区间和，开发商购买土地</p>
<h3 id="第一章-数组part01"><a href="#第一章-数组part01" class="headerlink" title="第一章  数组part01"></a><strong>第一章  数组part01</strong></h3><h5 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a><strong>数组理论基础</strong></h5><p>**数组是存放在连续内存空间上的相同类型数据的集合。**通过下标索引的方式获取到下标对应的数据。</p>
<img src="/2025/03/07/2025-03-07-第一章-数组part01-数组part02/算法通关数组.png"  alt="算法通关数组" style="zoom: 50%;" />

<ul>
<li><strong>数组下标都是从0开始的。</strong></li>
<li><strong>数组内存空间的地址是连续的</strong></li>
</ul>
<p>正是因为数组在内存空间的地址是连续的，所以删除或者增添元素的时候，就难免要移动其他元素的地址。<br><img src="/2025/03/07/2025-03-07-第一章-数组part01-数组part02/算法通关数组1.png"  alt="算法通关数组1" style="zoom: 50%;" /></p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<p><strong>二维数组在内存的空间地址是连续的么？</strong></p>
<p>C++中 二维数组在地址空间上是连续的</p>
<p>Java 没有指针，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机</p>
<ul>
<li>Java中二维数组相当于多个一维数组，每个数组起始地址地址不同</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test_arr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[I@7852e922</span><br><span class="line">[I@4e25154f</span><br><span class="line">[I@70dea4e</span><br><span class="line">[I@5c647e05</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在 Java 中，<code>System.out.println(arr[i]) </code>默认调用的是 toString() 方法，<br>而 toString() 方法的默认实现是：<br><code>getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</code></p>
<ul>
<li><p><code>getClass().getName()</code>：返回类型名（[I 表示 int[] 数组）<br><code>Integer.toHexString(hashCode())</code>：返回数组对象的哈希值（与内存地址相关）</p>
</li>
<li><p>这意味着，arr[0]、arr[1] 等打印出来的并不是数组内容，<br>而是它们在 JVM 内存中的标识符。</p>
</li>
</ul>
</li>
<li><p><strong>为什么 arr[0]、arr[1] 的地址不同？</strong></p>
<ul>
<li>Java 没有真正的二维数组，它的二维数组实际上是**”数组的数组”**。</li>
<li>arr[0]、arr[1]、arr[2]、arr[3] 分别是 4 个不同的一维数组对象，存储在不同的内存位置。</li>
<li>arr 本质上是一个 int[][] 类型的 引用数组，它存储的是 4 个 int[] 数组的引用，而这些 int[] 可能分散在堆内存的不同位置，因此它们的地址不连续。</li>
</ul>
</li>
</ul>
<h5 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><strong>704. 二分查找</strong></h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，</span><br><span class="line">写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</span><br><span class="line"><span class="code">	示例 1:</span></span><br><span class="line"><span class="code">	输入: nums = [-1,0,3,5,9,12], target = 9     </span></span><br><span class="line"><span class="code">	输出: 4       </span></span><br><span class="line"><span class="code">	解释: 9 出现在 nums 中并且下标为 4     </span></span><br><span class="line"><span class="code">	示例 2:</span></span><br><span class="line"><span class="code">	输入: nums = [-1,0,3,5,9,12], target = 2     </span></span><br><span class="line"><span class="code">	输出: -1        </span></span><br><span class="line"><span class="code">	解释: 2 不存在 nums 中因此返回 -1        </span></span><br><span class="line"><span class="code">提示：</span></span><br><span class="line"><span class="code">- 你可以假设 nums 中的所有元素是不重复的。</span></span><br><span class="line"><span class="code">- n 将在 [1, 10000]之间。</span></span><br><span class="line"><span class="code">- nums 的每个元素都将在 [-9999, 9999]之间。</span></span><br></pre></td></tr></table></figure>

<p><strong>左闭右闭	[left,right]</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>左闭右开	[left,right)</strong></p>
<p>跟左闭右闭相比，</p>
<ul>
<li><code>right</code>初值为<code>nums.length</code>、</li>
<li><strong>循环条件</strong>改为<code>while (left &lt; right)</code>、</li>
<li><strong>边界更新</strong>时若 <code>nums[mid] &gt; target</code>，则 <code>right = mid</code>，<ul>
<li>因为 <code>mid</code> 已经检查过，且不等于目标值，且 <code>right</code> 为开区间。</li>
</ul>
</li>
</ul>
<p>视频讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fA4y1o715">https://www.bilibili.com/video/BV1fA4y1o715</a></p>
<h5 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><strong>27. 移除元素</strong></h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a> </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。</span><br><span class="line">元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。</span><br><span class="line"><span class="code">	假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：</span></span><br><span class="line"><span class="code">    1. 更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。</span></span><br><span class="line"><span class="code">       nums 的其余元素和 nums 的大小并不重要。</span></span><br><span class="line"><span class="code">    2. 返回 k。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	示例 1：</span></span><br><span class="line"><span class="code">	输入：nums = [3,2,2,3], val = 3	</span></span><br><span class="line"><span class="code">	输出：2, nums = [2,2,_,_]</span></span><br><span class="line"><span class="code">	解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span></span><br><span class="line"><span class="code">		你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span></span><br><span class="line"><span class="code">	示例 2：</span></span><br><span class="line"><span class="code">	输入：nums = [0,1,2,2,3,0,4,2], val = 2</span></span><br><span class="line"><span class="code">	输出：5, nums = [0,1,4,0,3,_,_,_]</span></span><br><span class="line"><span class="code">	解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span></span><br><span class="line"><span class="code">		注意这五个元素可以任意顺序返回。</span></span><br><span class="line"><span class="code">		你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span></span><br><span class="line"><span class="code">提示：</span></span><br><span class="line"><span class="code">- 0 &lt;= nums.length &lt;= 100</span></span><br><span class="line"><span class="code">- 0 &lt;= nums[i] &lt;= 50</span></span><br><span class="line"><span class="code">- 0 &lt;= val &lt;= 100</span></span><br></pre></td></tr></table></figure>



<p><strong>暴力解法</strong></p>
<p><code>fori</code>循环，发现目标值则通过内层循环<code>forj</code>将后续元素左移一位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">removeElement01</span> <span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">       System.out.println(n);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; ) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                   nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">               n--;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Tips：</p>
<ul>
<li>注意外层循环仅<code>num[i] != val</code>才有<code>i++</code>（连续两个目标元素出现时会漏判断）</li>
<li>每移除一个目标数字，都应该减小有效长度<code>n</code></li>
</ul>
</li>
<li><p>最坏情况下，每次遇到目标元素都需要将后续所有元素左移一位，总的移动次数为:   <code>O((n-1) + (n-2) + … + 1) = O(n²)</code></p>
<ul>
<li>因此时间复杂度为 O(n²)。</li>
<li>而该解法只用了常数个额外变量，不依赖于输入规模，<br>所以空间复杂度为 O(1) .</li>
</ul>
</li>
</ul>
<p><strong>⭐双指针法</strong></p>
<p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>快指针指向新数组所需元素，下标为慢指针，慢指针大小即为新数组长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">removeElement02</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">               nums[slow] = nums[fast];</span><br><span class="line">               slow++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slow;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>视频讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12A4y1Z7LP">https://www.bilibili.com/video/BV12A4y1Z7LP</a> </p>
<h5 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a><strong>977.有序数组的平方</strong></h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给你一个按 <span class="strong">**非递减顺序**</span> 排序的整数数组 <span class="code">`nums`</span>，</span><br><span class="line">返回 <span class="strong">**每个数字的平方**</span> 组成的新数组，要求也按 <span class="strong">**非递减顺序**</span> 排序。</span><br><span class="line"></span><br><span class="line"><span class="code">	示例 1：</span></span><br><span class="line"><span class="code">	输入：nums = [-4,-1,0,3,10]</span></span><br><span class="line"><span class="code">	输出：[0,1,9,16,100]</span></span><br><span class="line"><span class="code">	解释：平方后，数组变为 [16,1,0,9,100]</span></span><br><span class="line"><span class="code">	排序后，数组变为 [0,1,9,16,100]</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	示例 2：</span></span><br><span class="line"><span class="code">	输入：nums = [-7,-3,2,3,11]</span></span><br><span class="line"><span class="code">	输出：[4,9,9,49,121]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>提示：</strong><ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<sup>4</sup></li>
<li>-10<sup>4</sup> &lt;&#x3D; nums[i] &lt;&#x3D; 10<sup>4</sup></li>
<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>
</ul>
</li>
</ul>
<p><strong>暴力解法</strong>：先平方，再排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>⭐双指针法</strong></p>
<p>原始数组已按 <strong>非递减顺序</strong> 排序，则原始数组平方应变为由两端向中间递减的数组</p>
<p>定义新数组，依次从原数组两端取数，从新数组尾端开始放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sortedSquares3(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> result.length - <span class="number">1</span>; <span class="comment">//结果数组的末尾索引</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;</span><br><span class="line">               <span class="comment">// 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置</span></span><br><span class="line">               result[index] = nums[left] * nums[left];</span><br><span class="line">               left++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               result[index] = nums[right] * nums[right];</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">           index--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>视频讲解： <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1QB4y1D7ep">https://www.bilibili.com/video/BV1QB4y1D7ep</a></strong> </p>
<h3 id="第一章-数组part02"><a href="#第一章-数组part02" class="headerlink" title="第一章  数组part02"></a>第一章  数组part02</h3><h5 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a><strong>209.长度最小的子数组</strong></h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其总和大于等于 target 的长度最小的<strong>子数组</strong>[nums<sub>l</sub>, nums<sub>l+1</sub>, …, nums<sub>r-1</sub>, nums<sub>r</sub>] ，并返回其长度。<br>如果不存在符合条件的子数组，返回 0 。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>1 &lt;&#x3D; target &lt;&#x3D; 10<sup>9</sup><br>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<sup>5</sup><br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10<sup>4</sup></p>
<p><strong>暴力解法</strong>：</p>
<ul>
<li><strong>错误示例</strong><ul>
<li>1.<code>sum &gt; = target</code>时直接跳出循环 —&gt; 找到的可能不是最小数组</li>
<li>2.<code>return subLength == nums.length ? 0 : subLength;</code><br>数组之和小于<code>target</code>时返回的值为数组长度，而非 0<br>—&gt; 将<code>subLength</code>初值设为 <code>Integer.MAX_VALUE</code> (<code>int</code> 类型所能表示的最大值)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubArrayLen1</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i+<span class="number">1</span> &lt; subLength)&#123;</span><br><span class="line">                    subLength = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subLength == Integer.MAX_VALUE ? <span class="number">0</span> : subLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码逻辑正确，但无法通过所有测试用例（时间复杂度为O(n<sup>2</sup>)）</li>
</ul>
<p><strong>滑动窗口</strong>（与双指针类似，使用动态思想将两层for循环简化为一层）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubArrayLen2</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>for循环中累加到sum&gt;&#x3D;target后，进入while循环<ul>
<li>左边界逐步向右移动作判断<ul>
<li><code>result = Math.min(result, right - left + 1);</code><br><code> sum -= nums[left++];</code></li>
<li>若仍&gt;&#x3D;sum，继续右移</li>
<li>若&lt;sum，则退出while循环，进入下一层的for循环</li>
</ul>
</li>
</ul>
</li>
<li>虽然算法中可能存在嵌套的 while 循环，但这两个指针都是单向向右移动的，<br>每个元素最多被访问两次（一次被右指针访问，另一次被左指针访问）。<br>因此，总的操作次数不会超过 2n 次，时间复杂度为 O(n)。</li>
</ul>
<img src="/2025/03/07/2025-03-07-第一章-数组part01-数组part02/滑动窗口.png"  alt="滑动窗口" style="zoom:25%;" />

<p>视频讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tZ4y1q7XE">https://www.bilibili.com/video/BV1tZ4y1q7XE</a></p>
<h5 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a><strong>59.螺旋矩阵II</strong></h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p>
<p>给你一个正整数 <code>n</code> ，生成一个包含 1 到 n<sup>2</sup> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>示例 1：</strong></p>
<img src="/2025/03/07/2025-03-07-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E7%BB%84part01-%E6%95%B0%E7%BB%84part02/spiraln.jpg" class="" title="img">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
<p><strong>循环不变量</strong>：尽量使用一个规则处理边界—&gt;此处采用左闭右开处理<br><img src="/2025/03/07/2025-03-07-第一章-数组part01-数组part02/螺旋矩阵.png"  alt="螺旋矩阵" style="zoom:25%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] generateMatrix (<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span>[][] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="number">0</span>, startY = <span class="number">0</span>;  <span class="comment">// 每一圈的起始点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">// 终止位置随每圈循环递减</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 矩阵中需要填写的数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 记录当前的圈数</span></span><br><span class="line">    <span class="type">int</span> i, j; <span class="comment">// j 代表列, i 代表行;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop &lt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 顶部	左闭右开，所以判断循环结束时， j 不能等于 n - offset</span></span><br><span class="line">        <span class="keyword">for</span> (j = startY; j &lt; n - offset; j++) &#123;</span><br><span class="line">            nums[startX][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右列	左闭右开，所以判断循环结束时， i 不能等于 n - offset</span></span><br><span class="line">        <span class="keyword">for</span> (i = startX; i &lt; n - offset; i++) &#123;</span><br><span class="line">            nums[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 底部	左闭右开，所以判断循环结束时， j != startY</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt; startY; j--) &#123;</span><br><span class="line">            nums[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左列	左闭右开，所以判断循环结束时， i != startX</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt; startX; i--) &#123;</span><br><span class="line">            nums[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line">        offset++;</span><br><span class="line">        loop++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// n 为奇数时，单独处理矩阵中心的值</span></span><br><span class="line">        nums[startX][startY] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>视频讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1SL4y1N7mV/">https://www.bilibili.com/video/BV1SL4y1N7mV/</a></p>
<h5 id="58-区间和"><a href="#58-区间和" class="headerlink" title="58.区间和"></a><strong>58.区间和</strong></h5><h5 id="44-开发商购买土地"><a href="#44-开发商购买土地" class="headerlink" title="44.开发商购买土地"></a>44.<strong>开发商购买土地</strong></h5><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/03/04/2025-03-04-SELinux%E7%AD%96%E7%95%A5%E5%86%B2%E7%AA%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/04/2025-03-04-SELinux%E7%AD%96%E7%95%A5%E5%86%B2%E7%AA%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">SELinux策略冲突分析工具的设计与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-04 15:30:00" itemprop="dateCreated datePublished" datetime="2025-03-04T15:30:00+08:00">2025-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-09 21:28:17" itemprop="dateModified" datetime="2025-03-09T21:28:17+08:00">2025-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%95%E8%AE%BE/" itemprop="url" rel="index"><span itemprop="name">毕设</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="开题报告"><a href="#开题报告" class="headerlink" title="开题报告"></a>开题报告</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#### 开题报告</span></span><br><span class="line"><span class="section">##### 一、选题背景</span></span><br><span class="line"><span class="strong">**研究现状**</span></span><br><span class="line">SELinux（Security-Enhanced Linux）是美国国家安全局（NSA）研发的一种强制访问控制机制，目前广泛应用于Linux系统安全领域。其通过安全策略对系统访问权限进行细粒度管控，能够有效遏制恶意操作。然而，随着应用场景复杂度增加，SELinux策略文件的规模呈现指数增长，由此带来的冗余与冲突问题逐步显现。这类问题可能导致系统安全漏洞、性能衰减甚至功能障碍。</span><br><span class="line"></span><br><span class="line">在国际研究中，学者们围绕SELinux的访问控制模型及策略优化展开了深入探讨。例如，Pahuja等（2023）提出了改进的逻辑推理冲突检测算法，大幅提高了检测效率。但多数研究侧重理论验证，实际工具开发较少涉及。在国内，研究集中于SELinux策略定制与优化，部分开源工具虽具备检测功能，但多局限于单一任务，难以应对复杂环境需求。</span><br><span class="line"></span><br><span class="line"><span class="strong">**选题目的及意义**</span></span><br><span class="line">本课题旨在开发一款SELinux策略冲突分析工具，解决当前工具在冲突检测及优化建议方面的不足。通过自动检测与实时优化建议，该工具帮助管理员迅速发现并处理冲突，提升系统安全性与运维效率。本研究既能为SELinux的应用提供技术支持，也有助于推动该领域的理论研究发展。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 二、研究目标和内容</span></span><br><span class="line">2.1 研究目标</span><br><span class="line">1.策略解析：构建功能模块，解析SELinux策略文件并转化为结构化数据。</span><br><span class="line">2.冲突检测：设计高效算法，定位并识别规则冗余及权限冲突问题。</span><br><span class="line">3.实时告警与优化：通过可视化和告警功能，辅助用户快速排查并解决问题。</span><br><span class="line"></span><br><span class="line">2.2 主要研究内容</span><br><span class="line">1.理论分析：梳理SELinux策略语法和冲突类型，搭建冲突检测的理论框架。</span><br><span class="line">2.算法设计：基于图算法或逻辑推理方法，开发适配Java语言的检测算法。</span><br><span class="line">3.工具开发：基于Java语言实现具备解析、检测及告警功能的工具。</span><br><span class="line">系统验证：在多种Linux系统环境中对工具进行功能和性能测试，并优化算法以提高准确性。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 三、研究方案</span></span><br><span class="line"><span class="strong">**3.1 研究方法**</span></span><br><span class="line">1.理论分析</span><br><span class="line">   系统分析 SELinux 策略文件结构，提取其语法规则和常见冲突类型。</span><br><span class="line">   总结现有文献中的冲突检测方法，为工具开发提供理论依据。</span><br><span class="line">2.算法设计</span><br><span class="line">   使用基于图模型的算法表示策略规则之间的依赖关系，定位可能的冲突点。</span><br><span class="line">   引入逻辑推理模块，通过对权限的推导分析潜在冲突。</span><br><span class="line">3.工具开发</span><br><span class="line">   语言选择：采用 Java 语言开发核心功能模块，确保工具的跨平台兼容性。</span><br><span class="line">   模块设计：</span><br><span class="line"><span class="code">     策略解析模块：利用 ANTLR 等工具解析 SELinux 策略文件。</span></span><br><span class="line"><span class="code">     冲突检测模块：实现基于图算法的冲突分析逻辑。</span></span><br><span class="line"><span class="code">     用户界面模块：通过 JavaFX 提供交互式可视化界面。</span></span><br><span class="line"><span class="code">     告警与日志模块：通过日志记录和实时通知功能，协助用户快速处理问题。</span></span><br><span class="line"><span class="code">4.测试验证</span></span><br><span class="line"><span class="code">   在多种 Linux 发行版（如 CentOS、Ubuntu）中进行功能测试，评估工具的兼容性与性能表现。</span></span><br><span class="line"><span class="code">   通过真实策略文件验证检测算法的准确率，优化算法以降低误报与漏报率。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="strong">**3.2 实施步骤**</span></span><br><span class="line">2025年1月：调研SELinux策略特性，明确工具设计需求。</span><br><span class="line">2025年2月：完成冲突检测算法的设计与初步实现。</span><br><span class="line">2025年3月：开发策略解析、检测和用户界面模块。</span><br><span class="line">2025年4月：部署工具并进行功能与性能优化，撰写相关文档与论文。</span><br><span class="line"></span><br><span class="line"><span class="strong">**3.3 拟解决的主要问题及措施**</span></span><br><span class="line">问题1：策略解析复杂度高，可能影响性能。</span><br><span class="line">措施：优化解析算法，并结合多线程技术提高效率。</span><br><span class="line"></span><br><span class="line">问题2：检测算法误报率较高。</span><br><span class="line">措施：通过逻辑推理及依赖分析，减少误报并提升检测准确性。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 参考资料</span></span><br></pre></td></tr></table></figure>

<h3 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h3><ul>
<li><strong>操作系统</strong>：ubuntu-22.04.3-live-server-amd64<br>此处密码直接设置为<code>123</code><img src="/2025/03/04/2025-03-04-SELinux策略冲突分析工具的设计与实现/ubuntu_sever.png"  style="zoom:50%;" /></li>
<li><strong>开发环境</strong>：JDK1.8<ul>
<li><strong>IDE</strong>：IntelliJ IDEA</li>
</ul>
</li>
<li><strong>SELinux策略分析工具</strong>：sealert</li>
<li><strong>版本控制</strong>：Git</li>
</ul>
<h3 id="理论研究"><a href="#理论研究" class="headerlink" title="理论研究"></a>理论研究</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/02/20/2025-02-20-%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/20/2025-02-20-%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">从零开始搭建仿牛客论坛项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-20 13:57:01" itemprop="dateCreated datePublished" datetime="2025-02-20T13:57:01+08:00">2025-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-21 17:35:09" itemprop="dateModified" datetime="2025-02-21T17:35:09+08:00">2025-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h2><ul>
<li>JDK9.0.4</li>
<li>apache-maven-3.6.3</li>
<li>SpringBoot 2.4.1</li>
<li>Redis-x64-5.0.10</li>
<li>Elasticsearch-7.9.3</li>
<li>kafka_2.13-2.7.0</li>
<li>wkhtmltopdf(⻓图⽣成⼯具)</li>
<li>mysql 5.7(建议版本&gt;&#x3D;5.7)</li>
</ul>
<p><strong>SQL文件介绍</strong></p>
<ul>
<li>init_schema.sql –&gt; 建表sql</li>
<li>init_data.sql –&gt; 初始化数据库数据SQL</li>
<li>tables_mysql_innodb.sql –&gt; quarter定时任务表SQL</li>
</ul>
<h3 id="初识Spring-Boot，开发社区首页"><a href="#初识Spring-Boot，开发社区首页" class="headerlink" title="初识Spring Boot，开发社区首页"></a>初识Spring Boot，开发社区首页</h3><p><strong>技术架构</strong></p>
<ul>
<li>Spring Boot</li>
<li>Spring、Spring MVC 、MyBatis</li>
<li>Redis、Kafka(消息队列服务器)、Elasticsearch(搜索引擎)</li>
<li>Spring Security、Spring Actuator</li>
</ul>
<p><strong>开发环境</strong></p>
<ul>
<li>构建工具：Apache Maven</li>
<li>集成开发工具：IDEA</li>
<li>数据库：MySQL、Redis</li>
<li>应用服务器：Apache Tomcat</li>
<li>版本控制工具：Git</li>
</ul>
<h5 id="Apache-Maven"><a href="#Apache-Maven" class="headerlink" title="Apache Maven"></a>Apache Maven</h5><ul>
<li>可以帮助我们构建项目、管理项目中的jar包</li>
<li>Maven仓库：存放构件的位置<ul>
<li>本地仓库：默认是 ~&#x2F;.m2&#x2F;repository</li>
<li>远程仓库：中央仓库、镜像仓库、私服仓库</li>
</ul>
</li>
</ul>
<p>Maven官网：<a target="_blank" rel="noopener" href="http://maven.apache.org/">http://maven.apache.org</a></p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/1.png"  alt="1" style="zoom:67%;" />
下载zip压缩包解压即可

<ul>
<li><p>默认访问的远程仓库为maven的中央仓库，改为阿里云的镜像仓库</p>
<ul>
<li><p>修改<code>D:\Environment\apache-maven-3.9.8\conf</code>路径下的配置文件<code>settings.xml</code></p>
</li>
<li><p>在<code>maven.aliyun.com</code>查找仓库路径，此处选用<br><a target="_blank" rel="noopener" href="https://maven.aliyun.com/repository/central">https://maven.aliyun.com/repository/central</a></p>
</li>
<li><p>在<code>&lt;mirrors&gt;  &lt;/mirrors&gt;</code> 中添加内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>maven默认采用命令行的方式访问，命令行工具<code>mvn.cmd</code>的默认路径是<code>D:\Environment\apache-maven-3.9.8\bin</code></p>
</li>
<li><p>将路径配到系统环境变量Path中</p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/2.png"  alt="2" style="zoom:67%;" />

<p>cmd中查看版本号，检查是否成功配置</p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/3.png"  alt="3" style="zoom:67%;" />
</li>
<li><p>maven常用命令（创建、测试、编译）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`创建项目`</span><br><span class="line">mvn archetype:generate -DgroupId=com.nowcoder.mavendemo01 -DartifactId=mavendemo01 -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.5 -DinteractiveMode=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## archetype:generate 调用 Maven 的原型生成器</span></span><br><span class="line">以模板原型的方式生成一个文件</span><br><span class="line"><span class="comment">## -DgroupId=com.mycompany.app：组织ID，通常wei</span></span><br><span class="line"><span class="comment">## -DartifactId=my-app：指定项目的ID，项目目录名称也通常采用这个名称。</span></span><br><span class="line"><span class="comment">## -DarchetypeArtifactId=maven-archetype-quickstart：选择 Maven 快速入门原型，这个原型会生成一个简单的 Java 项目，包含基本的目录结构和示例代码（例如 App.java 和对应的测试类）。</span></span><br><span class="line"><span class="comment">## -DarchetypeVersion=1.5：指定使用的原型版本。</span></span><br><span class="line"><span class="comment">## -DinteractiveMode=false：关闭交互模式，所有必要的信息都通过命令行参数指定，不需要在运行过程中进一步输入</span></span><br></pre></td></tr></table></figure>

<p>创建的项目目录如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">my-app</span><br><span class="line">|-- pom.xml</span><br><span class="line">`-- src</span><br><span class="line">    |-- main</span><br><span class="line">    |   `-- java</span><br><span class="line">    |       `-- com</span><br><span class="line">    |           `-- mycompany</span><br><span class="line">    |               `-- app</span><br><span class="line">    |                   `-- App.java</span><br><span class="line">    `-- <span class="built_in">test</span></span><br><span class="line">        `-- java</span><br><span class="line">            `-- com</span><br><span class="line">                `-- mycompany</span><br><span class="line">                    `-- app</span><br><span class="line">                        `-- AppTest.java</span><br></pre></td></tr></table></figure>

<p>编译项目，切换到项目路径下（即含pom.xml文件的目录)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn compile <span class="comment">#编译项目</span></span><br><span class="line"><span class="comment">##编译后的结果在 D:\Work\workspace\mavendemo01\target 路径下</span></span><br><span class="line">mvn clean <span class="comment">#清除</span></span><br><span class="line">mvn clean compile <span class="comment">#先清除再编译</span></span><br><span class="line">mvn clean <span class="built_in">test</span> <span class="comment">##先清除再测试，test命令包含了compile</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h5><p>目前最流行的Java集成开发工具</p>
<p><a target="_blank" rel="noopener" href="http://www.jetbrains.com/idea">http://www.jetbrains.com/idea</a></p>
<p>安装参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44601637/article/details/126807513">https://blog.csdn.net/qq_44601637/article/details/126807513</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46381569/article/details/131121481">https://blog.csdn.net/m0_46381569/article/details/131121481</a></p>
<p>在IDEA中配置Maven：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Future_yzx/article/details/140469886">https://blog.csdn.net/Future_yzx/article/details/140469886</a></p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/4.png"  alt="4" style="zoom:67%;" />



<h5 id="Spring-Initializr"><a href="#Spring-Initializr" class="headerlink" title="Spring Initializr"></a>Spring Initializr</h5><p><strong>创建 Spring Boot 项目的引导工具</strong></p>
<p><a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io</a></p>
<p>项目依赖的包较多时，管理起来较麻烦</p>
<p>Spring Initializr对项目常用的包进行了整合，按照功能&#x2F;需求进行分类</p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/5.png"  alt="5" style="zoom:67%;" />

<p>点击<code>Generate</code>下载设置好的web项目，解压后在IDEA中打开</p>
<p>在项目xml文件下的<code>&lt;dependencies&gt;	 &lt;/dependencies&gt;</code>标签内手动添加AOP模块<br><img src="/2025/02/20/2025-02-20-仿牛客论坛项目/8.png"  alt="8" style="zoom:50%;" /></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行项目测试，返回信息中显示Tomcat服务器成功在8080端口运行</p>
<p>Spring Boot 以jar包的方式内嵌了tomcat<br><img src="/2025/02/20/2025-02-20-仿牛客论坛项目/6.png"  alt="6" style="zoom:67%;" /></p>
<p>在本地的8080端口成功访问，web项目模板未作设置，返回错误信息</p>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/7.png"  alt="7" style="zoom: 50%;" />



<h4 id="Spring-Boot-入门示例"><a href="#Spring-Boot-入门示例" class="headerlink" title="Spring Boot 入门示例"></a>Spring Boot 入门示例</h4><ul>
<li>Spring Boot 核心作用<ul>
<li>起步依赖</li>
<li>自动配置</li>
<li>端点监控</li>
</ul>
</li>
</ul>
<img src="/2025/02/20/2025-02-20-仿牛客论坛项目/9.png"  alt="9" style="zoom: 50%;" />

<p><strong>修改Tomcat端口</strong></p>
<p>tomcat默认端口是8080，有时候会与其他服务产生冲突，此时修改<code>community\src\main\resources</code>路径下的<code>application.properties</code>文件即可<br><img src="/2025/02/20/2025-02-20-仿牛客论坛项目/10.png"  alt="10" style="zoom: 50%;" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/19/2025-02-19-%E5%8D%A1%E7%A0%81%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">卡码八股训练营记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-19T00:00:00+08:00">2025-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-12 14:49:55" itemprop="dateModified" datetime="2025-03-12T14:49:55+08:00">2025-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h3><h4 id="介绍一下TCP-IP模型和OSI模型的区别"><a href="#介绍一下TCP-IP模型和OSI模型的区别" class="headerlink" title="介绍一下TCP&#x2F;IP模型和OSI模型的区别"></a>介绍一下TCP&#x2F;IP模型和OSI模型的区别</h4><p><strong>TCP&#x2F;IP 模型与 OSI 模型的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>OSI 模型（七层）</strong></th>
<th><strong>TCP&#x2F;IP 模型（四层）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>层次划分</strong></td>
<td>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</td>
<td>应用层、传输层、网络层、网络接口层</td>
</tr>
<tr>
<td><strong>设计理念</strong></td>
<td>理想化、理论性强，定义清晰的层次关系，每层独立</td>
<td>结合实际网络设计，更符合互联网协议</td>
</tr>
<tr>
<td><strong>协议示例</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>应用层</strong></td>
<td>HTTP、FTP、SMTP、DNS 等</td>
<td>HTTP、FTP、SMTP、DNS 等（合并 OSI 的应用层、表示层、会话层）</td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td>TCP、UDP</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td>IP、ICMP、ARP</td>
<td>IP、ICMP、ARP</td>
</tr>
<tr>
<td><strong>数据链路层 &#x2F; 物理层</strong></td>
<td>以太网、Wi-Fi、PPP</td>
<td>以太网、Wi-Fi、PPP（合并 OSI 的数据链路层、物理层）</td>
</tr>
<tr>
<td><strong>适用范围</strong></td>
<td>理论上更全面</td>
<td>实际网络通信中更为实用。</td>
</tr>
<tr>
<td><strong>数据封装单位</strong></td>
<td><strong>比特流（物理层） → 帧（数据链路层） → 数据包（网络层） → 段（传输层） → 数据（应用层）</strong></td>
<td><strong>比特流 → 帧 → 数据包 → 段 → 数据</strong></td>
</tr>
</tbody></table>
<p>TCP&#x2F;IP 模型的<strong>应用层</strong>相当于 OSI 的 <strong>应用层 + 表示层 + 会话层</strong>，<br>而 TCP&#x2F;IP 的<strong>网络接口层</strong>相当于 OSI 的 <strong>数据链路层 + 物理层</strong>。</p>
<h4 id="从输入-URL-到页面展示到底发生了什么？"><a href="#从输入-URL-到页面展示到底发生了什么？" class="headerlink" title="从输入 URL 到页面展示到底发生了什么？"></a>从输入 URL 到页面展示到底发生了什么？</h4><ul>
<li><strong>浏览器网络请求</strong><ul>
<li><strong>输入网址，解析 URL 信息</strong><ul>
<li>解析 URL，提取协议（<code>https</code>）、域名（<code>www.example.com</code>）、路径（<code>/</code>）</li>
</ul>
</li>
<li><strong>检查浏览器缓存</strong><ul>
<li>有缓存并且仍然有效，则直接加载页面</li>
</ul>
</li>
<li><strong>DNS 解析 （域名 → IP 地址）</strong><ul>
<li>浏览器缓存 —&gt; 本地 <code>hosts</code> 文件 —&gt; 本地 DNS 服务器（ISP 提供）—&gt;权威 DNS 服务器（根 DNS → 顶级域名 DNS → 权威 DNS）</li>
</ul>
</li>
<li><strong>建立 TCP 连接（三次握手）</strong><ul>
<li><strong>第一步</strong>：客户端发送 SYN 报文请求连接。</li>
<li><strong>第二步</strong>：服务器回复 SYN-ACK 报文，确认连接请求。</li>
<li><strong>第三步</strong>：客户端回复 ACK，连接建立成功。</li>
</ul>
</li>
<li><strong>发送 HTTP 请求</strong><ul>
<li>浏览器构造 HTTP 请求：<ul>
<li><strong>请求行</strong>（请求方法 <code>GET</code>、请求路径 <code>/</code>、协议版本 <code>HTTP/1.1</code>）</li>
<li><strong>请求头</strong>（包含 <code>User-Agent</code>、<code>Cookie</code> 等）</li>
</ul>
</li>
<li>如果是 HTTPS，还涉及 <strong>TLS 握手</strong> 进行加密通信。</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务器处理请求</strong><ul>
<li><strong>服务器解析HTTP请求</strong><ul>
<li>接收 HTTP 请求，解析 URL 和请求头，查询静态资源和数据库、渲染动态页面</li>
</ul>
</li>
<li><strong>服务器返回HTTP响应</strong><ul>
<li><strong>响应状态码</strong>（如 <code>200 OK</code>，<code>404 Not Found</code>）</li>
<li><strong>响应头</strong>（<code>Content-Type: text/html</code>）</li>
<li><strong>响应体</strong>（HTML、CSS、JavaScript）</li>
</ul>
</li>
<li><strong>TCP 连接断开（四次挥手）</strong><ul>
<li><strong>客户端发送 FIN</strong>（请求关闭连接）</li>
<li><strong>服务器回复 ACK</strong>  此时若有剩余数据则继续发送</li>
<li><strong>服务器发送 FIN</strong>（服务器准备关闭）</li>
<li><strong>客户端回复 ACK</strong>（最终确认关闭）</li>
</ul>
</li>
</ul>
</li>
<li><strong>浏览器解析并渲染页面</strong><ul>
<li><strong>解析响应头</strong><ul>
<li>301，302重定向，为字节流则下载，为HTML文件则解析html文件</li>
</ul>
</li>
<li><strong>解析HTML 并渲染页面</strong><ul>
<li><strong>解析 HTML</strong>，构建 <strong>DOM 树</strong>    <strong>解析 CSS</strong>，构建 <strong>CSSOM 树</strong>，进行 <strong>样式计算</strong></li>
<li><strong>合成渲染树</strong>（DOM + CSSOM），<strong>布局（Layout）</strong> 计算元素的具体位置，<strong>绘制（Painting）</strong> 将页面渲染到屏幕上</li>
<li><strong>执行 JavaScript</strong>，更新页面内容</li>
</ul>
</li>
<li><strong>页面显示</strong><ul>
<li>页面最终呈现给用户，加载其他资源（图片、视频、异步数据等）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h3><h4 id="HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"><a href="#HTTP请求报文和响应报文是怎样的，有哪些常见的字段？" class="headerlink" title="HTTP请求报文和响应报文是怎样的，有哪些常见的字段？"></a>HTTP请求报文和响应报文是怎样的，有哪些常见的字段？</h4><h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><ul>
<li><p><strong>请求行</strong>（Request Line）</p>
<ul>
<li><p><strong>请求方法（Method）</strong>：如 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等</p>
</li>
<li><p><strong>资源路径（Resource Path）</strong>：要访问的资源地址</p>
</li>
<li><p><strong>HTTP 版本（HTTP Version）</strong>：如 <code>HTTP/1.1</code>、<code>HTTP/2.0</code></p>
</li>
<li><p>例如：<code>GET /index.html HTTP/1.1</code></p>
</li>
</ul>
</li>
<li><p><strong>请求头</strong>（Request Headers）：提供额外的信息，例如浏览器类型、缓存策略等</p>
<ul>
<li><p>常见请求头字段：</p>
<ul>
<li><p><strong>客户端环境&#x2F;请求资源</strong></p>
<ul>
<li><code>Host</code>：请求的服务器域名（必须字段）</li>
<li><code>User-Agent</code>：客户端信息（如浏览器、操作系统）</li>
<li><code>Accept</code>：客户端能接受的数据类型（如 <code>text/html</code>）</li>
<li><code>Accept-Encoding</code>：支持的压缩格式（如 <code>gzip</code>）</li>
</ul>
</li>
<li><p><strong>身份认证与安全</strong></p>
<ul>
<li><code>Authorization</code>：身份认证信息（如 <code>Bearer Token</code>）</li>
</ul>
</li>
<li><p><strong>缓存控制</strong></p>
<ul>
<li><code>If-None-Match </code> &#x2F; <code> If-Modified-Since</code>：资源的ETag &#x2F; 最后修改时间 值，用于缓存控制。</li>
</ul>
</li>
<li><p><strong>请求内容描述</strong></p>
<ul>
<li><code>Content-Length</code>：请求体的长度（仅适用于带请求体的方法）</li>
<li><code>Content-Type</code>：请求体的媒体类型（如 <code>application/json</code>）</li>
<li><code>Cookie</code>：发送存储在客户端的 Cookie</li>
</ul>
</li>
<li><p><code>Connection</code>：管理连接的选项，如 keep-alive</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>空行</strong>：用于分隔请求头和请求体。</p>
</li>
<li><p><strong>请求体</strong>（Request Body）：用于 <code>POST</code>、<code>PUT</code> 请求，包含要发送的数据（如 JSON、表单数据等）。</p>
</li>
</ul>
<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><ul>
<li><p><strong>状态行</strong>（Status Line）：包含 HTTP 版本、状态码、状态描述</p>
<ul>
<li><p><strong>HTTP 版本</strong>：如 <code>HTTP/1.1</code></p>
</li>
<li><p><strong>状态码</strong>（Status Code）</p>
<ul>
<li><code>2xx</code>（成功）：<code>200 OK</code>、<code>201 Created</code></li>
<li><code>3xx</code>（重定向）：<code>301 Moved Permanently</code>、<code>302 Found</code></li>
<li><code>4xx</code>（客户端错误）：<code>400 Bad Request</code>、<code>404 Not Found</code></li>
<li><code>5xx</code>（服务器错误）：<code>500 Internal Server Error</code></li>
</ul>
</li>
<li><p><strong>状态描述</strong>：对状态码的解释（如 <code>OK</code>、<code>Not Found</code>）</p>
</li>
<li><p>例如：<code>HTTP/1.1 200 OK</code></p>
</li>
</ul>
</li>
<li><p><strong>响应头</strong>（Response Headers）：提供额外信息，如内容类型、缓存控制等</p>
<ul>
<li><p>常见响应头字段</p>
<ul>
<li><p><strong>重定向</strong></p>
<ul>
<li><code>Location</code>：重定向地址（适用于 301、302）</li>
</ul>
</li>
<li><p><strong>描述响应内容</strong></p>
<ul>
<li><code>Content-Type</code>：返回数据的 MIME 类型（如 <code>text/html</code>）</li>
<li><code>Content-Length</code>：响应体长度（字节）</li>
</ul>
</li>
<li><p><strong>控制缓存</strong></p>
<ul>
<li><code>Expires</code>：指定响应的过期时间，用于缓存控制。</li>
<li><code>ETag</code>：资源的实体标签，用于缓存验证。</li>
<li><code>Last-Modified</code>：资源最后修改的日期和时间。</li>
</ul>
</li>
<li><p><strong>管理连接和安全</strong></p>
<ul>
<li><code>Server</code>：服务器软件信息（如 <code>nginx/1.18.0</code>）</li>
<li><code>Set-Cookie</code>：设置 Cookie</li>
<li><code>Access-Control-Allow-Origin</code>：指示哪些域名可以访问资源，涉及跨域资源共享（CORS）策略</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>空行</strong>：用于分隔响应头和响应体。</p>
</li>
<li><p><strong>响应体</strong>（Response Body）：实际的返回数据，如 HTML 页面、JSON 数据、图片等。</p>
</li>
</ul>
<h4 id="HTTP有哪些请求方式？"><a href="#HTTP有哪些请求方式？" class="headerlink" title="HTTP有哪些请求方式？"></a>HTTP有哪些请求方式？</h4><p><strong>幂等性</strong>：表示多次执行相同请求，服务器状态不变。</p>
<p><strong>安全性</strong>：表示请求不会修改服务器数据（如 <code>GET</code>、<code>HEAD</code>、<code>OPTIONS</code>）。</p>
<p>HTTP 定义了多种请求方法，每种方法适用于不同的场景。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>用途</strong></th>
<th><strong>幂等性</strong></th>
<th><strong>安全性</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>GET</strong></td>
<td>获取资源</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>POST</strong></td>
<td>提交数据</td>
<td>❌ 非幂等</td>
<td>❌ 不安全（数据在请求体中）</td>
</tr>
<tr>
<td><strong>PUT</strong></td>
<td>更新资源（完整更新）</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>DELETE</strong></td>
<td>删除资源</td>
<td>✅ 幂等</td>
<td>❌ 不安全（改变服务器状态）</td>
</tr>
<tr>
<td><strong>HEAD</strong></td>
<td>获取资源的头部信息</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>OPTIONS</strong></td>
<td>获取服务器支持的请求方法</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
<tr>
<td><strong>TRACE</strong></td>
<td>回显请求，用于调试</td>
<td>✅ 幂等</td>
<td>❌ 不安全（容易被攻击）</td>
</tr>
<tr>
<td><strong>CONNECT</strong></td>
<td>建立隧道连接（如 HTTPS 代理）</td>
<td>✅ 幂等</td>
<td>✅ 安全</td>
</tr>
</tbody></table>
<h4 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h4><ul>
<li><code>GET</code> <strong>适用于获取数据</strong>，参数放在 URL，容易被缓存，幂等且安全。</li>
<li><code>POST</code> <strong>适用于提交数据</strong>，参数放在请求体，不容易被缓存，不幂等。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>参数位置</strong></td>
<td>URL 查询参数（<code>?key=value</code>）</td>
<td>请求体</td>
</tr>
<tr>
<td><strong>参数长度</strong></td>
<td>受 URL 长度限制</td>
<td>理论上无限制</td>
</tr>
<tr>
<td><strong>缓存</strong></td>
<td>可被缓存</td>
<td>不会被浏览器缓存</td>
</tr>
<tr>
<td><strong>可见性</strong></td>
<td>参数暴露在 URL 中</td>
<td>参数在请求体，不易暴露</td>
</tr>
<tr>
<td><strong>幂等性</strong></td>
<td>✅ 幂等</td>
<td>❌ 非幂等</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>查询数据（如获取用户信息）</td>
<td>提交数据（如用户注册、登录）</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>❌ 不适合传输敏感信息（如密码）</td>
<td>✅ 相对更安全，但仍需 HTTPS</td>
</tr>
</tbody></table>
<h3 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h3><h4 id="HTTP请求中常见的状态码"><a href="#HTTP请求中常见的状态码" class="headerlink" title="HTTP请求中常见的状态码"></a><strong>HTTP请求中常见的状态码</strong></h4><p>HTTP 状态码用于指示服务器对请求的处理结果，按照功能分为 5 类</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>分类名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1xx</strong></td>
<td><strong>信息性状态码</strong></td>
<td>服务器已收到请求，正在继续处理</td>
</tr>
<tr>
<td><strong>2xx</strong></td>
<td><strong>成功状态码</strong></td>
<td>请求成功并返回预期的响应</td>
</tr>
<tr>
<td><strong>3xx</strong></td>
<td><strong>重定向状态码</strong></td>
<td>需要客户端执行进一步操作（重定向）</td>
</tr>
<tr>
<td><strong>4xx</strong></td>
<td><strong>客户端错误码</strong></td>
<td>客户端请求有错误（参数错误、权限不足等）</td>
</tr>
<tr>
<td><strong>5xx</strong></td>
<td><strong>服务器错误码</strong></td>
<td>服务器端发生错误，无法处理请求</td>
</tr>
</tbody></table>
<p><strong>常见状态码</strong></p>
<ul>
<li><p>**2xx：**请求成功</p>
<ul>
<li><strong>200 OK</strong>：常用于 <code>GET</code>、<code>POST</code>、<code>PUT</code> 等请求。</li>
<li><strong>201 Created</strong>：服务器创建了新资源（常用于 <code>POST</code>）。</li>
<li><strong>204 No Content</strong>：服务器无返回内容（常用于 <code>DELETE</code>）。</li>
</ul>
</li>
<li><p><strong>3xx：</strong></p>
<ul>
<li><strong>301 Moved Permanently</strong>：资源永久移动，后续请求应使用新 URL（SEO 友好）。</li>
<li><strong>302 Found</strong>（临时重定向）：资源暂时移动，后续请求仍可使用原 URL。</li>
<li><strong>304 Not Modified</strong>（缓存优化）：客户端缓存资源仍然有效，无需重新下载（结合 <code>ETag</code>、<code>Last-Modified</code> 头使用）。<ul>
<li><strong>缓存相关：</strong></li>
<li>浏览器在接收到 <code>304 Not Modified</code> 后，不会下载新资源，而是从本地缓存加载，提升性能。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>4xx：</strong></p>
<ul>
<li><strong>400 Bad Request</strong>：请求格式错误或参数无效，服务器无法解析。</li>
<li><strong>401 Unauthorized</strong>：身份认证失败，需要提供有效凭证（如未登录）。</li>
<li><strong>403 Forbidden</strong>：服务器拒绝请求。（如权限不够）</li>
<li><strong>404 Not Found</strong>：请求的资源不存在（常见于访问错误的 URL）。</li>
</ul>
</li>
<li><p><strong>5xx：</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong>：服务器内部错误（代码异常、数据库崩溃等）。</li>
<li><strong>502 Bad Gateway</strong>：服务器作为网关&#x2F;代理，收到无效响应（上游服务器问题）。</li>
<li><strong>503 Service Unavailable</strong>：服务器暂时不可用（维护、超载等）。</li>
</ul>
</li>
</ul>
<p><strong>状态码使用案例</strong></p>
<ol>
<li><strong>用户访问网站首页</strong><ul>
<li>正常加载：返回 <code>200 OK</code></li>
<li>页面不存在：返回 <code>404 Not Found</code></li>
<li>需要登录：返回 <code>401 Unauthorized</code></li>
</ul>
</li>
<li><strong>API 接口</strong><ul>
<li>获取数据成功：返回 <code>200 OK</code></li>
<li>没有权限：返回 <code>403 Forbidden</code></li>
<li>请求参数错误：返回 <code>400 Bad Request</code></li>
</ul>
</li>
<li><strong>重定向</strong><ul>
<li>旧网站迁移到新域名：返回 <code>301 Moved Permanently</code></li>
<li>用户登录后跳转到主页：返回 <code>302 Found</code></li>
<li>资源未修改：返回 &#96;304 Not Modified</li>
</ul>
</li>
</ol>
<h4 id="什么是强缓存和协商缓存"><a href="#什么是强缓存和协商缓存" class="headerlink" title="什么是强缓存和协商缓存"></a><strong>什么是强缓存和协商缓存</strong></h4><p>HTTP 协议中，缓存机制主要用于减轻服务器负担，加快页面加载速度</p>
<ol>
<li>浏览器第一次访问时访问服务器时需要下载资源</li>
<li>后续访问时，只要强缓存没有失效就直接从缓存中获取，不需要将获取资源的请求包含在请求报文中</li>
<li>当强缓存失效后，浏览器会使用协商缓存机制来验证资源是否被修改</li>
</ol>
<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><ul>
<li><strong>Expires</strong><br> <code>Expires</code> 是一个 HTTP 响应头，指定资源的过期时间（绝对时间），表示在该时间之前资源都是有效的，可以直接使用缓存，不需要向服务器重新请求。<br> 用于设置强缓存。当客户端收到带有 <code>Expires</code> 头的响应后，在当前时间早于 <code>Expires</code> 指定时间内，浏览器直接从本地缓存中读取资源。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 21 Oct 2025 07:28:00 GMT</span><br><span class="line"><span class="comment">## 表示在 2025 年 10 月 21 日 07:28:00 GMT 之前，资源均可直接使用缓存。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>Cache-Control</strong></p>
<p><code>Cache-Control</code> 是 HTTP&#x2F;1.1 提供的用于控制缓存行为的通用头部，可以用于请求和响应中。它提供了多种指令来精细控制资源如何被缓存。<br>用于替代或补充 <code>Expires</code>，提供更灵活的缓存控制。服务器可以根据业务需求，准确控制资源的缓存策略</p>
<ul>
<li><strong>常见指令</strong>：<ul>
<li><strong>max-age</strong>：指定资源在客户端缓存的最大时间（秒），例如 <code>max-age=3600</code> 表示缓存有效期为 3600 秒。</li>
<li><strong>no-cache</strong>：表示缓存必须在使用前进行重新验证，即使缓存仍在有效期内。</li>
<li><strong>no-store</strong>：禁止缓存，确保每次请求都从服务器获取最新数据。</li>
<li><strong>public</strong> 和 <strong>private</strong>：分别指示资源可以被所有用户缓存，或仅供单个用户缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=3600, public</span><br><span class="line"><span class="comment">## 表示资源可以被缓存 3600 秒，并允许任何缓存设备缓存此资源。</span></span><br></pre></td></tr></table></figure>



<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><ul>
<li><p><strong>Last-Modified</strong></p>
<p> <code>Last-Modified</code> 是服务器在响应中返回的头部字段，用来指示资源的最后修改时间。它通常以 GMT 时间格式表示。</p>
<p> 客户端在后续请求时，可以使用 <code>If-Modified-Since</code> 请求头将之前获取的 <code>Last-Modified</code> 值发送给服务器。如果资源自该时间之后没有更新，服务器可以返回 <code>304 Not Modified</code> 状态，从而避免不必要的数据传输。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Tue, 20 Apr 2025 12:00:00 GMT</span><br><span class="line"><span class="comment">## 表示资源在该时间之后没有发生变化，客户端可据此进行缓存验证。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>ETag</strong></p>
<p> <code>ETag</code>（实体标签）是服务器为特定资源生成的唯一标识符，它反映了资源的版本。当资源内容发生变化时，ETag 值也会改变。</p>
<p> 客户端在后续请求时，可以在请求头中使用 <code>If-None-Match</code> 将之前收到的 ETag 值发送给服务器。服务器比对后，如果发现资源没有变化，则返回 <code>304 Not Modified</code>，让客户端继续使用缓存数据。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ETag: <span class="string">&quot;686897696a7c876b7e&quot;</span></span><br><span class="line"><span class="comment">## 表示该资源当前的版本标识符，后续可以利用此值进行缓存验证。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>浏览器使用缓存流程</code><br><img src="/2025/02/19/2025-02-19-卡码八股训练营记录/1.png"  alt="1" style="zoom:67%;" /></p>
<h3 id="Day04"><a href="#Day04" class="headerlink" title="Day04"></a>Day04</h3><h4 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h4><ul>
<li><strong>连接管理</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：默认使用<strong>短连接</strong>，每次请求&#x2F;响应后关闭 TCP 连接；<br>可以通过 <code>Connection: keep-alive</code> 来实现持久连接</li>
<li><em>HTTP&#x2F;1.1</em>：默认启用<strong>持久连接</strong>（<code>Connection</code>字段值默认为<code>keep-alive</code>），<br>在同一 TCP 连接上可以连续发送多个请求和响应，减少了连接建立和关闭的开销。</li>
</ul>
</li>
<li><strong>管道化</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：客户端的每次请求都需要在上一次请求的响应到达之后发送，请求发送有等待时间</li>
<li><em>HTTP&#x2F;1.1</em>：支持<strong>管道化</strong>，即同一连接上可以连续发送多个请求，<br>但由于服务器必须按顺序返回响应（队头阻塞问题），实际效果有限</li>
</ul>
</li>
<li><strong>缓存控制</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：主要依赖 <code>Expires</code> 头来指定资源的绝对过期时间，没有协商缓存机制</li>
<li><em>HTTP&#x2F;1.1</em>：引入了 <code>Cache-Control </code>头提供更精细的缓存指令,通过 <code>If-Modified-Since </code>和 <code>If-None-Match </code>等头实现协商缓存</li>
</ul>
</li>
<li><strong>错误处理和状态码</strong><br><strong>HTTP&#x2F;1.1</strong>增加了状态码（如 <code>100 Continue</code>）用于中间响应和更精细的错误处理，<br>使客户端能更好地管理请求过程和错误恢复</li>
<li><strong>请求头要求</strong><br><strong>HTTP&#x2F;1.1</strong>要求所有请求必须包含 <code>Host</code> 头  —&gt;  一台服务器&#x2F;一个IP 上可托管多个 域名&#x2F;网站</li>
<li><strong>带宽优化</strong><ul>
<li><em>HTTP&#x2F;1.0</em>：不支持断点续传功能，客户端只需要某个对象的一部分时，服务器也会将整个对象发送过来</li>
<li><em>HTTP&#x2F;1.1</em>：在请求头引入了<code>range</code>头域，允许只请求资源的某个部分，此时服务器返回状态码<code>206</code></li>
</ul>
</li>
</ul>
<h4 id="HTTP2-0与HTTP1-1的区别？"><a href="#HTTP2-0与HTTP1-1的区别？" class="headerlink" title="HTTP2.0与HTTP1.1的区别？"></a>HTTP2.0与HTTP1.1的区别？</h4><ul>
<li><p><strong>二进制协议</strong></p>
<ul>
<li>HTTP&#x2F;1.1：请求和响应内容都是以纯文本方式发送的，解析时开销较大且容易出错。</li>
<li>HTTP&#x2F;2.0：采用二进制格式，将数据分割为小的帧，解析更高效、可靠</li>
</ul>
</li>
<li><p><strong>多路复用</strong></p>
<ul>
<li>HTTP&#x2F;1.1：支持持久连接，但请求在同一连接上串行发送，容易出现队头阻塞<ul>
<li>可以连续发送多个请求，但服务器必须按顺序返回响应</li>
</ul>
</li>
<li>HTTP&#x2F;2.0：支持多路复用，允许在单个TCP连接上并行交错发送多个请求和响应<ul>
<li>请求和响应报文被拆分为更小的帧<ul>
<li>帧类型包括 DATA、HEADERS、PRIORITY 等，每种类型的帧都有特定的用途。</li>
<li>流的状态管理涉及多种状态，如“已打开”、“已关闭”等，客户端和服务器可以通过发送特定的帧（如 RST_STREAM）来管理流的生命周期</li>
</ul>
</li>
<li>帧被分配到不同的流（Stream），每个流都有唯一的标识符</li>
<li>接收方根据帧头中的流标识符将属于同一流的帧重新组装为完整的请求或响应</li>
</ul>
</li>
<li>HTTP&#x2F;2.0 基于 TCP 协议来传输数据，发生了丢包现象时，就会触发 TCP 的重传机制，<br>这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来</li>
</ul>
</li>
<li><p><strong>头部压缩</strong></p>
<ul>
<li>HTTP&#x2F;1.1：头部信息以纯文本发送，冗余较多</li>
<li>HTTP&#x2F;2.0：引入 HPACK 算法对头部进行压缩，显著减少传输数据量<br><strong>HPACK 算法</strong>：<ul>
<li><strong>静态表和动态表</strong>：<br>客户端和服务器各自维护一个<strong>静态表</strong>和<strong>动态表</strong>，用于存储常见的头部字段。<br>静态表包含预定义的常用头部，动态表则在通信过程中动态更新，记录已发送的头部字段。<br>通过引用这些表中的索引，可以避免重复传输相同的头部信息。</li>
<li><strong>哈夫曼编码</strong>：<br>HPACK 使用哈夫曼编码对头部字段进行压缩，将常用字符编码为更短的二进制序列，从而减少头部的大小。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器推送</strong></p>
<p><code>HTTP/2.0</code> 允许服务器主动推送页面相关资源给客户端，而不需要客户端明确请求，<br>避免了客户端请求和服务器响应之间的延迟，可以减少页面加载时间</p>
<ul>
<li>例如，客户端请求一个 HTML 页面时，服务器可以主动推送相关的 CSS、JavaScript 文件等资源，从而加快页面渲染速度</li>
</ul>
</li>
<li><p><strong>优先级和依赖</strong></p>
<p><code>HTTP/2.0</code> 允许客户端为请求设置优先级，并表达请求之间的依赖关系，资源加载更加有序</p>
</li>
</ul>
<h4 id="HTTP3-0有了解过吗？"><a href="#HTTP3-0有了解过吗？" class="headerlink" title="HTTP3.0有了解过吗？"></a>HTTP3.0有了解过吗？</h4><p>HTTP3.0基于 QUIC 协议，运行在UDP上，整合了TCP和TLS协议</p>
<p>应用层数据直接被封装成QUIC帧，<br>整合一个或多个帧，加上信息（<strong>连接 ID</strong>&#x2F;<code>Connection ID</code>）后被封装成一个 QUIC 数据包<br>QUIC 数据包被封装在 UDP 数据报中，通过网络传输</p>
<ul>
<li><strong>无队头阻塞</strong><ul>
<li>HTTP&#x2F;1.1没有解决响应的队头阻塞、HTTP&#x2F;2基于TCP 协议，<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong></li>
<li>HTTP3.0基于UDP 协议发送，<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong></li>
</ul>
</li>
<li><strong>零 RTT 连接建立</strong><ul>
<li>传输数据前的 QUIC 协议握手只需要 1 RTT，目的是为确认双方的「连接 ID」</li>
<li>QUIC 内部包含了 TLS</li>
<li>第二次连接时，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</li>
</ul>
</li>
<li><strong>连接迁移</strong><ul>
<li>网络环境发送改变（如Wifi—&gt;移动网络）时，通过确认<code>Connection ID</code>实现<strong>零 RTT 连接</strong></li>
</ul>
</li>
<li><strong>向前纠错机制</strong><ul>
<li>每个数据包还包括了部分其他数据包的数据，少量丢包无需重传</li>
</ul>
</li>
<li><strong>安全性</strong><ul>
<li>默认使用TLS加密</li>
</ul>
</li>
</ul>
<h3 id="Day05"><a href="#Day05" class="headerlink" title="Day05"></a>Day05</h3><h4 id="HTTPS和HTTP有哪些区别"><a href="#HTTPS和HTTP有哪些区别" class="headerlink" title="HTTPS和HTTP有哪些区别"></a>HTTPS和HTTP有哪些区别</h4><ul>
<li>HTTP 明文传输、TCP三次握手后建立连接传输报文，默认工作在80端口</li>
<li>HTTPS TCP三次握手后还需要进行SSL&#x2F;TLS的握手过程才能进入加密报文传输，默认工作在443端口<ul>
<li>需要向CA（证书权威机构）申请数字证书，来保证服务器身份可信</li>
</ul>
</li>
</ul>
<h4 id="HTTPS的工作原理-HTTPS建立连接的过程）"><a href="#HTTPS的工作原理-HTTPS建立连接的过程）" class="headerlink" title="HTTPS的工作原理(HTTPS建立连接的过程）"></a>HTTPS的工作原理(HTTPS建立连接的过程）</h4><p><code>HTTPS</code> 主要基于<code>SSL/TLS</code> 协议，确保数据传输的安全性和完整性</p>
<ol>
<li><p><strong>客户端向服务器请求加密通信</strong></p>
<ul>
<li>请求报文包括：<ul>
<li>客户端支持的TLS版本、支持的加密算法、随机数1（Client Random）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器选择一个客户端支持的加密算法</strong></p>
<ul>
<li>响应报文包括：<ul>
<li>CA证书：服务器的数字证书，由受信任的CA签发、<br>随机数2（Server Random）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>客户端验证证书合法性</strong></p>
<ul>
<li>使用数字证书中的公钥<strong>加密</strong>报文<br>报文内容包括：<ul>
<li>随机数3（预主密钥 Pre-Master Secret）：三个随机数生成 <strong>会话密钥&#x2F;主密钥（Master Secret）</strong></li>
<li>加密算法改变通知：之前使用会话密钥加密通话</li>
<li>结束握手通知、之前消息摘要校验值（用于服务器验证数据完整性）<ul>
<li>“加密算法改变通知”通常是通过<strong>ChangeCipherSpec</strong>消息发送，<br>而<strong>Finished</strong>消息则包含了整个握手过程的摘要，用于双方确认握手数据未被篡改。<br>这两个消息实际上是分开的，而不是合并在一个报文中。<ol>
<li>客户端生成并发送加密后的预主密钥（即ClientKeyExchange消息）。</li>
<li>客户端随后发送ChangeCipherSpec和Finished消息。</li>
<li><code>Tips</code>：<br>消息通常指应用层的数据单位，而报文是网络层的数据传输单位。<br>消息在传输过程中可能被分割成多个报文进行传输。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器生成会话密钥</strong></p>
<ul>
<li><p>服务器使用自己的私钥解密客户端发送的预主密钥，随后与客户端共同计算出主密钥，再派生出对称加密所需的各个子密钥。</p>
</li>
<li><p>发送内容：通知服务器后续加密、结束握手通知、之前消息摘要校验值（用于客户端验证数据完整性）</p>
<ul>
<li>后续加密的通知、结束握手通知和之前消息摘要校验值同样是两个消息分别发送的</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据传输完成后销毁密钥</strong></p>
<ul>
<li>通信结束后双方应销毁会话密钥以防止长期使用造成安全风险。</li>
</ul>
</li>
</ol>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><ul>
<li><strong>TCP</strong> <ul>
<li><strong>面向连接</strong>：数据传输前需要建立连接（三次握手），确保通信双方的可靠连接</li>
<li><strong>可靠数据传输</strong>（保证顺序、完整性）：通过序列号、确认应答、重传机制等<ul>
<li>检测并重传丢失数据包</li>
</ul>
</li>
<li><strong>拥塞控制机制</strong>：根据网络状况调整发送速率</li>
<li><strong>滑动窗口机制</strong>：流量控制，保证对端能够处理发送的数据</li>
<li>报文头部复杂：TCP头部通常为20字节，包含序列号、确认号、窗口大小等多个字段</li>
</ul>
</li>
<li><strong>UDP</strong> <ul>
<li><strong>无连接</strong>：数据传输前不需要建立连接，发送方直接将数据包发送出去，接收方无需确认</li>
<li><strong>不可靠</strong>：UDP不提供数据包的确认、重传等机制，无法保证数据的顺序性和完整性，<br>           适用于对实时性要求高且能容忍一定数据丢失的应用。</li>
<li>发送速率恒定</li>
<li>头部报文相对简单，开销较小 ：<br>UDP头部只有8字节，包含源端口、目的端口、长度和校验和等基本信息，适合对速度和效率要求高的应用。</li>
</ul>
</li>
</ul>
<h3 id="Day06"><a href="#Day06" class="headerlink" title="Day06"></a>Day06</h3><h4 id="TCP连接如何确保可靠性"><a href="#TCP连接如何确保可靠性" class="headerlink" title="TCP连接如何确保可靠性"></a>TCP连接如何确保可靠性</h4><ul>
<li><strong>连接管理</strong>：三次握手、四次挥手</li>
<li><strong>差错控制</strong>：<ul>
<li><strong>序列号和确认应答机制</strong>：<br>每个数据包都被赋予唯一的序列号，接收方通过发送确认包（ACK）来告知发送方数据已成功接收。<br>发送方根据确认包的序列号来确认哪些数据已经收到，哪些还需要重新发送。</li>
<li><strong>超时重传机制</strong>：<br>如果发送方在一定时间内没有收到接收方的确认（ACK），它会重新发送未确认的数据包。<br>这确保了数据在丢包时能够重新传输。</li>
</ul>
</li>
<li><strong>流量控制</strong>：<br>TCP使用滑动窗口机制进行流量控制，确保接收方的缓冲区不被溢出。<br>接收方在ACK包中告诉发送方它能够接收的最大数据量，发送方根据这一信息调整数据发送速度。</li>
<li><strong>拥塞控制</strong>：TCP使用拥塞控制机制来动态调整发送速率，防止网络过载，</li>
</ul>
<h4 id="TCP-拥塞控制机制"><a href="#TCP-拥塞控制机制" class="headerlink" title="TCP 拥塞控制机制"></a>TCP 拥塞控制机制</h4><ul>
<li><p><strong>慢启动</strong>：<br>发送方维护一个拥塞窗口，窗口初始设为一个小的值（通常为1个最大报文段大小MSS）<br>每一经过一RTT窗口大小翻倍，达到阈值后进入拥塞避免阶段</p>
</li>
<li><p><strong>拥塞避免</strong> ：拥塞窗口大小达到阈值之后，增长方式由指数级增长变为线性增长</p>
</li>
<li><p><strong>快重传</strong> ：<br>接收方收到失序数据包时<strong>重复发送上一个数据包的ACK</strong><br>发送方收到<strong>三个重复的ACK</strong>后，认为发生了丢包，直接重传丢失的数据包，而不是等待超时</p>
</li>
<li><p><strong>快恢复</strong> ：<br>快重传之后，TCP不会回到慢启动阶段，而是将窗口大小设置为阈值的一半，然后继续线性增长</p>
</li>
</ul>
<h4 id="TCP-流量控制机制"><a href="#TCP-流量控制机制" class="headerlink" title="TCP 流量控制机制"></a>TCP 流量控制机制</h4><p><strong>流量控制的目的</strong></p>
<ul>
<li><strong>防止接收方过载</strong>：接收方有一定的缓冲区，当发送数据过快而接收方处理不过来时，就可能造成缓冲区溢出，从而丢失数据。</li>
<li><strong>保障数据正确接收</strong>：确保数据传输双方的速率匹配，使得接收方能够及时处理和确认收到的数据。</li>
</ul>
<p>TCP采用<strong>滑动窗口机制</strong>实现流量控制，<strong>TCP报文头中有一个“窗口大小”字段（16位）</strong>，<br>它由接收方计算并告知发送方，表示接收方当前可用的缓冲区大小。</p>
<ul>
<li>发送方发送，接收方更新，协商窗口大小</li>
<li>接收方将接收数据存入缓冲区，向上层应用提供数据处理</li>
<li>接收方定期发送确认报文，缓冲区快满时、减少窗口大小，缓冲区剩余空间较大时，增大窗口大小</li>
</ul>
<p>TCP流量控制主要是为了确保发送方不会以超过接收方处理能力的速率发送数据，从而防止接收方的缓冲区溢出和数据丢失。其基本实现原理和关键组件如下：</p>
<p><strong>流量控制与拥塞控制的区别</strong></p>
<ul>
<li><strong>流量控制</strong>：主要是点对点的机制，关注的是发送方与接收方之间的数据速率匹配，防止接收方缓冲区溢出。</li>
<li><strong>拥塞控制</strong>：则是端到端的机制，目的是防止整个网络中某个环节因数据量过大而导致拥塞、丢包及延迟增加。</li>
<li>在实际传输中，发送方的发送速率受两个因素的限制：<br>接收方通告的窗口大小（流量控制）和网络状况下的拥塞窗口（拥塞控制），<br>实际允许发送的数据量为两者的最小值。</li>
</ul>
<h4 id="UDP怎么实现可靠传输"><a href="#UDP怎么实现可靠传输" class="headerlink" title="UDP怎么实现可靠传输"></a>UDP怎么实现可靠传输</h4><p><strong>选择UDP原因</strong>：TCP在<strong>传输层</strong>实现可靠连接，存在问题：连接延迟、队头阻塞、网络迁移需要重新建立连接</p>
<p>UDP本身是无连接、不可靠的协议，但在需要可靠传输的场景下，可以在<strong>应用层</strong>自行实现类似TCP的可靠性机制。一般可以从以下两方面实现：</p>
<ul>
<li><strong>超时重传</strong><ul>
<li>为每个UDP数据报设计一个自定义首部，其中包含时间戳，用于测量数据报的往返时间（RTT），从而计算合适的重传超时时间（RTO）。</li>
<li>采用“等停（stop-and-wait）”方式发送数据报，即发送一个数据报后等待对端确认，确认收到后再发送下一个；若超过RTO未收到确认，则进行重传，同时将RTO扩大为原来的两倍，再次启动计时。</li>
</ul>
</li>
<li><strong>确认和序列号机制</strong><ul>
<li>在UDP数据报首部中增加确认序列号字段，标识当前数据报的序号。</li>
<li>对端在收到数据报后，提取时间戳和序列号，并构造确认报文（ACK）返回给发送方。</li>
<li>发送方收到确认后，就知道该数据报已正确到达；同时，对端根据序列号对收到的数据报进行排序，并丢弃重复的数据报，保证数据按序交付给上层应用。</li>
</ul>
</li>
</ul>
<p><strong>QUIC协议</strong><br>基于UDP协议，在应用层实现可靠传输，通过三次握手协商ConnectionID建立连接<br>（网络迁移时只需要确认ConnectionID，可实现0RTT建立连接）</p>
<h3 id="Day08"><a href="#Day08" class="headerlink" title="Day08"></a>Day08</h3><h4 id="TCP连接三次握手的过程，为什么是三次"><a href="#TCP连接三次握手的过程，为什么是三次" class="headerlink" title="TCP连接三次握手的过程，为什么是三次"></a>TCP连接三次握手的过程，为什么是三次</h4><p>TCP 采用 <strong>三次握手</strong> 主要是为了<br><strong>确保双方的发送和接收能力都正常</strong>，<br><strong>同步初始序列号（ISN），保证数据有序传输</strong>，<br><strong>防止旧的连接请求影响新连接</strong></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>发送方</th>
<th>报文类型</th>
<th>关键字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第一次握手</strong></td>
<td>客户端</td>
<td><strong>SYN</strong></td>
<td><code>SYN=1, seq=x</code></td>
<td>请求建立连接</td>
</tr>
<tr>
<td><strong>第二次握手</strong></td>
<td>服务器</td>
<td><strong>SYN+ACK（SYN-ACK）</strong></td>
<td><code>SYN=1, ACK=1, seq=y, ack=x+1</code></td>
<td>服务器同意连接</td>
</tr>
<tr>
<td><strong>第三次握手</strong></td>
<td>客户端</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, seq=x+1, ack=y+1</code></td>
<td>确认连接建立</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>第一次握手（SYN）</strong>：客户端 → 服务器：发送 <code>SYN（seq=x）</code>，表示希望建立连接，并携带 <strong>初始序列号（ISN）</strong></p>
<ul>
<li>客户端确认自己<strong>能发送数据</strong>，请求建立连接。<ul>
<li>✔️ 客户端知道自己 <strong>能发送数据</strong>（但不知道服务器能否接收）</li>
<li>❌ 客户端还不知道服务器的状态、服务器也不知道客户端是否能正常接收数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第二次握手（SYN+ACK）</strong>：服务器 → 客户端：返回 <code>SYN+ACK（SYN=1, ACK=1, seq=y, ack=x+1）</code>，<br>表示：<strong>ACK&#x3D;x+1</strong>：确认收到了客户端的 SYN，表明服务器 <strong>能接收</strong> 数据。<br>        <strong>SYN&#x3D;y</strong>：服务器也发送自己的 SYN，请求客户端确认服务器的状态。</p>
<ul>
<li>服务器确认自己能<strong>接收并发送</strong>，并请求客户端确认。<ul>
<li>✔️ 服务器知道自己 <strong>能接收</strong> 客户端的数据。</li>
<li>✔️ 服务器知道客户端 <strong>能发送</strong> 数据。</li>
<li>❌ 服务器还不知道客户端是否能接收数据、客户端也不知道服务器的数据是否能被自己正确接收。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第三次握手（ACK）</strong>：客户端 → 服务器：发送 <code>ACK（ACK=1, seq=x+1, ack=y+1）</code><br>表示：<strong>ACK&#x3D;y+1</strong>：确认收到了服务器的 SYN，说明客户端 <strong>能接收</strong> 数据。<strong>这一步之后，双方都确认了收发能力，连接正式建立！</strong></p>
<ul>
<li>客户端最终确认服务器的<strong>发送能力</strong>，确保连接正常。<ul>
<li>✔️ 客户端&#x2F;服务器 知道对方 <strong>能收发</strong> 数据 ，成功建立连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>为什么不能用两次握手？</strong></p>
<p>如果只用 两次握手<code>（SYN → SYN+ACK）</code>，可能会遇到 <strong>旧 SYN 报文导致的错误连接问题</strong>。</p>
<p><strong>问题：旧 SYN 报文导致连接异常</strong></p>
<ol>
<li>客户端 A 发送 <code>SYN</code> 请求，但网络延迟，未到达服务器。</li>
<li>客户端 A 以为服务器无响应，放弃连接，重新发送新的 <code>SYN</code>。</li>
<li>服务器此时收到<strong>旧的</strong> <code>SYN </code>请求，并误以为客户端要建立新连接，返回 <code>SYN+ACK</code>。</li>
<li>客户端 A 没有预期这次握手，可能直接忽略或返回 RST，导致服务器错误建立连接。</li>
</ol>
<p> <strong>三次握手可以避免这个问题</strong>：</p>
<ul>
<li>只有客户端 收到服务器的 <code>SYN+ACK</code>，并主动发送 <code>ACK</code>，服务器才会确认连接建立，从而避免误连接。</li>
</ul>
<p><strong>为什么不能用四次或更多次握手？</strong></p>
<p>三次握手已经足够确保双方的收发能力正常，额外的握手只会增加开销，没有额外收益，因此三次是最合理的方案。</p>
<h4 id="TCP连接四次挥手的过程，为什么是四次？"><a href="#TCP连接四次挥手的过程，为什么是四次？" class="headerlink" title="TCP连接四次挥手的过程，为什么是四次？"></a>TCP连接四次挥手的过程，为什么是四次？</h4><p>TCP 采用 <strong>四次挥手</strong> 主要是为了<br><strong>确保双方都能正常断开连接</strong><br><strong>让双方的数据传输完全结束，避免丢失</strong><br><strong>保证全双工通信中，双方都能独立关闭发送方向</strong></p>
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>发送方</strong></th>
<th><strong>报文类型</strong></th>
<th><strong>关键字段</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>第一次挥手</strong></td>
<td>客户端</td>
<td><strong>FIN</strong></td>
<td><code>FIN=1, seq=x</code></td>
<td>请求关闭连接</td>
</tr>
<tr>
<td><strong>第二次挥手</strong></td>
<td>服务器</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, ack=x+1</code></td>
<td>确认关闭请求</td>
</tr>
<tr>
<td><strong>第三次挥手</strong></td>
<td>服务器</td>
<td><strong>FIN</strong></td>
<td><code>FIN=1, seq=y</code></td>
<td>服务器请求关闭</td>
</tr>
<tr>
<td><strong>第四次挥手</strong></td>
<td>客户端</td>
<td><strong>ACK</strong></td>
<td><code>ACK=1, ack=y+1</code></td>
<td>确认服务器关闭</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>第一次挥手（客户端 → 服务器：FIN）</strong></p>
<ul>
<li>客户端 发送 <code>FIN（seq=x）</code>，表示自己 没有数据要发送了，请求关闭 发送方向。<br>客户端进入 <strong>FIN-WAIT-1状态</strong>，等待服务器确认。</li>
<li>客户端 –&gt; 服务器: <code>FIN, seq=x</code></li>
</ul>
</li>
<li><p><strong>第二次挥手（服务器 → 客户端：ACK）</strong></p>
<ul>
<li>服务器 发送 <code>ACK（ack=x+1）</code>，表示 收到了客户端的关闭请求，但仍可能有数据要发送。<br>服务器进入 <strong>CLOSE-WAIT 状态</strong>，继续处理剩余数据。<br>客户端进入 <strong>FIN-WAIT-2 状态</strong>，等待服务器关闭。</li>
<li>服务器 –&gt; 客户端: <code>ACK, ack=x+1</code></li>
</ul>
</li>
<li><p><strong>第三次挥手（服务器 → 客户端：FIN）</strong></p>
<ul>
<li>服务器 处理完所有数据后，发送<code> FIN（seq=y）</code>，请求关闭 发送方向。<br>服务器进入 <strong>LAST-ACK 状态</strong>，等待客户端的确认。</li>
<li>服务器 –&gt; 客户端: <code>FIN, seq=y</code></li>
</ul>
</li>
<li><p><strong>第四次挥手（客户端 → 服务器：ACK）</strong></p>
<ul>
<li>客户端 发送 <code>ACK（ack=y+1）</code>，确认服务器的关闭请求。<br>客户端进入 <strong>TIME-WAIT 状态</strong>，等待 <strong>2MSL</strong>（最大报文生存时间），确保服务器收到 <code>ACK</code> 后才完全释放连接。<br>服务器收到 ACK 后，进入 <strong>CLOSED 状态</strong>，彻底关闭连接。</li>
<li>客户端 –&gt; 服务器: <code>ACK, ack=y+1</code></li>
</ul>
</li>
</ul>
<p><strong>为什么需要四次挥手，而不是三次？</strong></p>
<p>TCP 是 <strong>全双工通信</strong>，<strong>数据的 发送和接收是独立的，所以需要分别关闭：</strong></p>
<p>前两次挥手：客户端请求关闭 发送通道，服务器确认<br>后两次挥手：服务器处理完剩余数据后，主动关闭 发送通道，客户端确认</p>
<p><strong>如果只用 三次挥手：</strong></p>
<p>服务器如果 还未发送完数据 就直接关闭，可能导致<strong>数据丢失</strong>。</p>
<p><strong>TIME-WAIT 状态与 2MSL 等待期</strong><br>TIME-WAIT 作用</p>
<ul>
<li>确保服务器收到最终的 <code>ACK</code><br>如果服务器没有收到 <code>ACK</code>，它会超时重发<code> FIN</code>，<strong>TIME-WAIT</strong> 允许客户端 重新发送 <code>ACK</code>。</li>
<li>防止旧连接数据干扰新连接<br>旧连接的数据可能在网络中滞留，<strong>TIME-WAIT</strong> 确保这些数据在新连接建立前被丢弃。</li>
</ul>
<p><strong>为什么等待 2MSL？</strong></p>
<p><strong>MSL</strong>（Maximum Segment Lifetime） 是一个 TCP 报文在网络中的最长存活时间。<br>等待 2MSL 确保网络中 所有旧数据包都已消失，避免影响新连接。</p>
<h4 id="HTTP的Keep-Alive是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？"><a href="#HTTP的Keep-Alive是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？" class="headerlink" title="HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？"></a>HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</h4><ul>
<li><p><strong>HTTP Keep-Alive</strong>	 <strong>HTTP 应用层</strong>。</p>
<ul>
<li>HTTP 的 <strong>Keep-Alive</strong> 机制允许 <strong>在同一个 TCP 连接上发送多个 HTTP 请求和响应</strong>，而不是在每个请求后都关闭 TCP 连接。</li>
<li><strong>目的</strong><ul>
<li>减少 TCP 连接的建立和关闭开销**，避免频繁的三次握手（建立连接）和四次挥手（关闭连接）。**</li>
<li>提高 HTTP 请求的性能**，减少请求延迟，提高服务器的吞吐量。**</li>
<li>减少服务器资源消耗，降低 CPU 和内存开销。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>TCP Keepalive</strong>    <strong>TCP 传输层</strong></p>
<ul>
<li>TCP 的 <strong>Keepalive 机制不是用来复用连接的，而是用于检测 TCP 连接是否仍然存活</strong>。当一个 TCP 连接长时间没有数据传输时，TCP Keepalive <strong>定期发送探测包</strong>，检查对端是否仍然在线，以避免资源浪费。</li>
<li><strong>目的</strong><ul>
<li><strong>检测并清理无效的 TCP 连接</strong>，防止服务器资源被僵尸连接占用。</li>
<li><strong>保持 NAT 设备中的 TCP 连接映射有效</strong>，防止 NAT 设备因长时间无数据而丢弃连接。</li>
</ul>
</li>
<li><strong>TCP Keepalive 的工作方式</strong><ul>
<li><strong>TCP 连接长时间没有数据传输</strong>（默认 2 小时）。<strong>内核发送 Keepalive 探测包</strong>，询问对方是否存活。</li>
<li><strong>如果对方正常响应</strong>，连接继续保持。<strong>如果连续多次探测无响应</strong>（如 3 次），TCP 认为对端失效，关闭连接。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>HTTP Keep-Alive 和 TCP Keepalive 的区别</strong></p>
<ul>
<li><strong>核心区别</strong><ul>
<li><strong>HTTP Keep-Alive 解决的是“重复建立连接的问题”</strong>，避免 HTTP 请求频繁创建新 TCP 连接。</li>
<li><strong>TCP Keepalive 解决的是“连接是否还存活的问题”</strong>，防止僵尸连接占用系统资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>机制</th>
<th>作用</th>
<th>适用协议</th>
<th>作用层次</th>
<th>触发方式</th>
<th>典型使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HTTP Keep-Alive</strong></td>
<td>复用 TCP 连接，减少握手开销</td>
<td>HTTP</td>
<td><strong>应用层</strong></td>
<td>HTTP 头部 <code>Connection: Keep-Alive</code></td>
<td>加速 HTTP 访问，减少 TCP 连接消耗</td>
</tr>
<tr>
<td><strong>TCP Keepalive</strong></td>
<td>检测 TCP 连接是否存活，防止僵尸连接</td>
<td>TCP</td>
<td><strong>传输层</strong></td>
<td>操作系统定期发送探测包</td>
<td>服务器维护长连接，检测对端是否存活</td>
</tr>
</tbody></table>
<h3 id="Day09"><a href="#Day09" class="headerlink" title="Day09"></a>Day09</h3><h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><p>DNS基本概念</p>
<ul>
<li><strong>DNS是什么？</strong><br>域名系统（Domain Name System）是将易记的域名（例如 <a target="_blank" rel="noopener" href="http://www.example.com)转换为计算机能识别的ip地址(例如/">www.example.com）转换为计算机能识别的IP地址（例如</a> 192.0.2.1）的分布式数据库系统。它类似于互联网的“电话簿”，使我们无需记住数字地址即可访问网站。</li>
<li><strong>DNS的作用</strong><br>DNS使得互联网用户可以通过友好的域名访问网站、邮件服务器等，同时提供一定的负载均衡和容错能力。</li>
</ul>
<p><strong>DNS查询的基本流程</strong></p>
<p><strong>用户发起请求</strong><br>当你在浏览器中输入一个URL时，操作系统和浏览器会检查各自的DNS缓存（以及Hosts文件），<br>如果已经存在该域名对应的IP地址，解析过程会立即结束；<br>如果没有命中，则向配置的本地域名解析器（DNS Resolver）发送请求。</p>
<p><strong>本地域名解析器处理请求（递归查询）</strong><br>本地DNS服务器通常采用递归查询方式，它负责替客户端查找最终的IP地址。<br>（<strong>递归查询</strong>由本地域名解析器替客户端完成所有查询过程，简化了客户端的操作。）</p>
<p>若自身缓存中没有记录，它会依次向其他DNS服务器发起查询。</p>
<p><strong>迭代查询过程</strong><br>本地域名解析器会按照以下步骤依次查询：</p>
<ul>
<li><strong>查询根DNS服务器</strong>：<br>根服务器不会返回具体的IP地址，而是告诉解析器该查询应转发到哪个顶级域（如.com、.net、.org）的DNS服务器。</li>
<li><strong>查询顶级域名服务器</strong>：<br>利用根服务器返回的信息，本地解析器向对应的顶级域名服务器发出查询。<br>顶级域名服务器同样不会直接返回目标IP，而是指向负责该域名的权威DNS服务器。</li>
<li><strong>查询权威DNS服务器</strong>：<br>本地DNS解析器最终向权威DNS服务器发送查询请求，权威服务器并返回具体的IP地址。<br>（权威DNS服务器是负责存储特定域名和IP地址映射的服务器）</li>
</ul>
<p><strong>返回结果</strong><br>得到IP地址后，本地域名解析器将结果缓存（以便下次查询更快响应），并将IP地址返回给客户端，浏览器随后使用该IP地址发起HTTP请求访问网站。</p>
<h4 id="CDN是什么，有什么作用？"><a href="#CDN是什么，有什么作用？" class="headerlink" title="CDN是什么，有什么作用？"></a>CDN是什么，有什么作用？</h4><p>CDN（内容分发网络）是一种由遍布全球各地的边缘服务器组成的分布式网络系统，<br>其核心目的是将网站的静态资源（如图片、CSS、JavaScript文件等）缓存在离用户最近的节点上，从而加速内容加载，降低延迟，提高网站性能和用户体验。</p>
<p><strong>工作原理</strong></p>
<ol>
<li><strong>用户请求</strong><br> 当用户在浏览器中请求某个网站时，DNS系统会将请求解析到CDN网络中离用户最近的<strong>边缘服务器</strong>。<ul>
<li><strong>调度系统</strong><br>通过DNS解析或Anycast技术，把用户请求引导到最优的CDN节点</li>
<li><strong>边缘服务器&#x2F;PoP（Point of Presence）</strong><br>分布在各地的节点，负责缓存内容并快速响应用户请求。</li>
</ul>
</li>
<li><strong>缓存内容</strong><ul>
<li><strong>边缘缓存</strong>：如果该边缘服务器已缓存了所需内容，则直接返回给用户，无需每次都访问源站。</li>
<li><strong>回源请求</strong>：如果缓存中没有，则边缘服务器会向源站（Origin Server）请求内容，并将获取到的内容缓存起来，以便后续请求使用。<ul>
<li><strong>缓存策略</strong><ul>
<li><strong>TTL（生存时间）</strong>：决定缓存内容在边缘节点中存留多久。</li>
<li><strong>缓存失效与更新策略</strong>：确保内容及时更新，比如通过主动刷新、定时更新或基于内容变更的触发机制。</li>
<li><strong>分层缓存</strong>：结合多级缓存结构，使不同类型的内容（静态与动态）能够有效缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>可用性</strong>：即使某些节点出现问题，用户请求可以被重定向到其他健康的节点。</li>
</ol>
<p><strong>主要优势与作用</strong></p>
<ul>
<li><strong>提升访问速度</strong><br> 用户可以从最近的节点获取内容，大幅降低延迟，加快页面加载速度。</li>
<li><strong>减轻源站压力</strong><br> 大量静态资源由CDN节点分担，源站不需要处理所有流量，降低服务器负载。</li>
<li><strong>提高可靠性与可用性</strong><br> 多个节点分布在全球，即使部分节点发生故障，其他节点仍能提供服务，增强整体稳定性。</li>
<li><strong>防御DDoS攻击</strong><br> 分布式架构能够吸收并分散恶意流量，提升抗攻击能力。</li>
<li><strong>改善用户体验</strong><br> 快速加载和更稳定的连接使用户获得更流畅的浏览体验，进而提高网站转化率和满意度。</li>
</ul>
<h4 id="Cookie和Session是什么？有什么区别？"><a href="#Cookie和Session是什么？有什么区别？" class="headerlink" title="Cookie和Session是什么？有什么区别？"></a>Cookie和Session是什么？有什么区别？</h4><ul>
<li><p><strong>Cookie</strong></p>
<ul>
<li>客户端&#x2F;浏览器发起HTTP请求后服务器通过 HTTP 响应头设置<code>Set-Cookie</code>值，<br>由服务器将一个或多个<code> Cookie</code> 发送到用户浏览器，然后浏览器将这些 <code>Cookie</code> 存储在本地。<br>服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的<code>Cookie</code>得到客户端特有的信息，从而动态生成与该客户端相对应的内容。</li>
<li><code>Cookie</code>  存储容量较小，一般为几 KB<br>生命周期由服务器设置，通过HTTP请求自动发送</li>
<li>易被窃取、篡改、有传输风险（中间人截获）—&gt; HTTPS</li>
<li>存储小量非敏感信息，如用户个性化设置，临时状态等</li>
</ul>
</li>
<li><p><strong>Session</strong></p>
<ul>
<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是<code>Session</code>。（<code>Session</code>  数据存储在服务器上）</li>
<li>存储容量较大，通常没有固定限制，取决于服务器的配置和资源。<br>生命周期由服务器管理（默认与会话相关，通常在浏览器关闭后失效）<br><code>Session ID</code>  通常通过<code> Cookie</code>  或 URL 参数传递</li>
<li>Session 数据存储在服务器上，更难被用户访问和修改<br>（攻击者获取Session后也有可能冒充用户）</li>
<li>Session主要用于存储用户登录状态及权限信息、保存敏感数据和状态管理（在多步操作或交易中，存储临时数据，确保数据一致性）等</li>
</ul>
</li>
</ul>
<h3 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h3><h4 id="进程和线程之间有什么区别"><a href="#进程和线程之间有什么区别" class="headerlink" title="进程和线程之间有什么区别"></a>进程和线程之间有什么区别</h4><ul>
<li><strong>进程</strong><ul>
<li>进程是<strong>操作系统进行资源分配和调度的基本单位</strong>，<br><strong>每个进程拥有独立的内存空间、代码段、数据段以及系统资源。</strong></li>
<li><strong>独立内存空间</strong>：每个进程都有自己独立的地址空间，因此在创建和销毁时需要分配或回收较多资源，开销较大。<br><strong>上下文切换开销</strong>：进程切换时需要保存和恢复整个进程的状态，导致上下文切换开销较高。</li>
<li><strong>进程间通信（IPC）</strong>：由于进程相互隔离，通信必须依赖专门的机制，如管道、消息队列、共享内存等，这使得进程间通信相对复杂。</li>
<li><strong>隔离性高</strong>：进程之间相互隔离，一个进程的崩溃一般不会影响到其他进程，因而整体安全性和稳定性较好。</li>
</ul>
</li>
<li><strong>线程</strong><ul>
<li>线程是<strong>程序执行的最小单位</strong>，是进程内的执行单元。<br><strong>一个进程至少包含一个线程，也可以拥有多个线程，这些线程共享进程内的内存空间和资源</strong></li>
<li><strong>共享内存空间</strong>：同一进程中的所有线程共享内存和其他资源，因此创建和销毁线程的成本较低。<br><strong>轻量级切换</strong>：线程之间的切换只需保存少量的上下文信息，上下文切换速度快。</li>
<li><strong>直接共享数据</strong>：同一进程内的线程可以直接访问共享内存，因此线程间通信更为方便。但这种共享也可能引发数据竞争，需要使用互斥锁、信号量等同步机制进行协调。</li>
<li><strong>风险共享</strong>：由于同一进程内的线程共享内存和资源，一个线程出现错误（如非法内存访问）可能导致整个进程崩溃，从而影响系统稳定性。</li>
</ul>
</li>
</ul>
<p>在实际应用中，<br>如果需要高度的安全性和资源隔离，使用进程会更合适；<br>而如果追求高效的并发和轻量级的切换，线程则是更好的选择。</p>
<h4 id="并行和并发有什么区别"><a href="#并行和并发有什么区别" class="headerlink" title="并行和并发有什么区别"></a>并行和并发有什么区别</h4><p><strong>并行</strong>：</p>
<ul>
<li>同一时刻执行多个任务，在<strong>物理上</strong>同时执行。</li>
<li>需要多核 CPU 或多台计算机，每个核心或计算节点独立执行不同的任务。</li>
<li>并行旨在缩短任务的执行时间。</li>
<li>并行通过增加处理单元、同时执行多个任务来提高处理能力，<br>显著缩短总的执行时间，但需要考虑任务间的同步和通信开销。</li>
<li><strong>应用场景</strong>：适用于计算密集型任务，如科学计算、图像处理等，需要将大任务分解为可并行执行的子任务。</li>
<li>需要将任务有效地分解为独立的子任务，并处理任务间的协调和数据共享，增加了编程的复杂性。</li>
</ul>
<p><strong>并发</strong>：</p>
<ul>
<li>相同的时间段内执行多个任务，任务可能交替执行，通过调度实现，在<strong>逻辑上</strong>同时处理。</li>
<li>不要求物理上真正同时执行。例如，单核 CPU 通过任务切换来执行多个任务，使其看起来是同时运行的。</li>
<li>并发旨在提高资源利用率和系统吞吐量</li>
<li>通过共享资源（如CPU时间）、减少任务的等待时间，来提高系统的响应速度，<br>但频繁的上下文切换可能带来开销。</li>
<li><strong>应用场景</strong>：适用于需要同时处理大量任务且任务之间可能存在交互的场景，如Web服务器需要同时处理多个客户端请求。</li>
<li>需要处理任务间的同步和资源竞争问题，可能导致死锁、竞态条件等复杂情况。</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>并发（Concurrency）</th>
<th>并行（Parallelism）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>任务<strong>交替执行</strong>，宏观上同时进行</td>
<td>任务<strong>真正同时执行</strong></td>
</tr>
<tr>
<td><strong>依赖硬件</strong></td>
<td>不需要多核，单核也能并发</td>
<td>需要多核或多机</td>
</tr>
<tr>
<td><strong>执行方式</strong></td>
<td>任务<strong>切换</strong>执行</td>
<td>任务<strong>同时</strong>执行</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>I&#x2F;O 密集型任务，如 Web 服务器处理多个请求</td>
<td>CPU 密集型任务，如深度学习计算</td>
</tr>
<tr>
<td><strong>实现难度</strong></td>
<td>需要线程管理、同步机制</td>
<td>需要高性能硬件、数据分割</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Python 中的 <code>asyncio</code>，Java 多线程</td>
<td>OpenMP、CUDA 并行计算</td>
</tr>
</tbody></table>
<ul>
<li><strong>并发可以实现并行</strong>：在多核 CPU 或分布式环境下，并发任务可以被调度到不同核心或机器上，形成真正的并行执行。</li>
<li><strong>并行通常包含并发</strong>：并行任务可能需要协调、通信，而协调机制通常涉及并发编程。</li>
</ul>
<h4 id="解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？"><a href="#解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？" class="headerlink" title="解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？"></a>解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？</h4><p>用户态和内核态是 CPU 的两种运行模式，主要用于<strong>保护系统资源和控制访问权限</strong>。</p>
<ul>
<li><strong>用户态</strong>：<ul>
<li>普通应用程序运行的环境，权限受限，不能直接访问硬件。</li>
<li>只能执行普通指令，若需要访问操作系统资源，必须通过<strong>系统调用</strong>进入内核态。</li>
</ul>
</li>
<li><strong>内核态</strong>：<ul>
<li>操作系统内核运行的环境，拥有最高权限，可直接管理<strong>进程、内存、I&#x2F;O 设备</strong>等。</li>
<li>允许执行特权指令，如<strong>控制硬件、修改内存管理单元（MMU）状态</strong>等。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>用户态（User Mode）</th>
<th>内核态（Kernel Mode）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>特权级别</strong></td>
<td>低（受限制）</td>
<td>高（完全访问权限）</td>
</tr>
<tr>
<td><strong>执行主体</strong></td>
<td>应用程序</td>
<td>操作系统内核</td>
</tr>
<tr>
<td><strong>访问硬件</strong></td>
<td>不能直接访问</td>
<td>可直接操作硬件</td>
</tr>
<tr>
<td><strong>指令权限</strong></td>
<td>仅普通指令</td>
<td>可执行特权指令</td>
</tr>
<tr>
<td><strong>稳定性</strong></td>
<td>高（程序崩溃不影响系统）</td>
<td>低（内核崩溃导致系统崩溃）</td>
</tr>
</tbody></table>
<p><strong>用户态和内核态的切换场景</strong></p>
<p>CPU 运行时，可能因以下原因从用户态切换到内核态：</p>
<ol>
<li><strong>系统调用（System Call）</strong><ul>
<li>当用户进程需要操作文件、访问网络、分配内存等，需要调用操作系统提供的服务。<br>例如 <code>read()</code>, <code>write()</code>, <code>open()</code> 等函数，最终会触发软中断（Trap），CPU 切换到内核态执行内核代码。</li>
</ul>
</li>
<li><strong>异常（Exception）</strong><ul>
<li>当用户程序执行非法操作（如除零、访问非法内存）时，CPU 触发异常，进入内核态，交由操作系统处理。</li>
</ul>
</li>
<li><strong>中断（Interrupt）</strong><ul>
<li>外设（键盘、网络、磁盘等）发送中断信号，CPU 停止当前任务，切换到内核态执行中断处理程序（ISR）。</li>
<li>例如：<ul>
<li>键盘输入触发中断，CPU 进入内核态读取输入数据。</li>
<li>磁盘 I&#x2F;O 完成后触发中断，通知操作系统数据已准备就绪。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><strong>用户态：</strong> 运行普通应用，权限受限，不能直接访问硬件。</li>
<li><strong>内核态：</strong> 运行操作系统，完全控制系统资源，可直接访问硬件。</li>
<li><strong>切换场景：</strong> 通过<strong>系统调用、异常、中断</strong>切换到内核态。</li>
</ul>
<h3 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h3><h4 id="进程调度算法你了解多少"><a href="#进程调度算法你了解多少" class="headerlink" title="进程调度算法你了解多少"></a>进程调度算法你了解多少</h4><ol>
<li><strong>先来先服务（FCFS）</strong>：<ul>
<li><strong>特点</strong>：按照进程的到达顺序进行调度，最简单的调度算法。</li>
<li><strong>缺点</strong>：由于没有考虑进程的运行时间，可能会导致长作业占用CPU较长时间，导致短作业的等待时间过长，产生“convoy effect”。</li>
</ul>
</li>
<li><strong>最短作业优先（SJF）</strong>：<ul>
<li><strong>特点</strong>：非抢占式调度，优先调度估计运行时间最短的进程。</li>
<li><strong>缺点</strong>：需要知道进程的运行时间，且可能导致长作业永远得不到调度，出现“饥饿”现象。实际系统中通常采用估算方法来解决这个问题。</li>
</ul>
</li>
<li><strong>最短剩余时间优先（SRTF）</strong>：<ul>
<li><strong>特点</strong>：基于最短作业优先（SJF）的抢占式调度算法。每当一个新的进程到达时，比较其剩余运行时间与当前正在执行进程的剩余时间。如果新进程的剩余时间更短，当前进程被挂起，转而执行新进程。</li>
<li><strong>缺点</strong>：可能导致频繁的上下文切换，增加系统开销。</li>
</ul>
</li>
<li><strong>优先级调度（Priority Scheduling）</strong>：<ul>
<li><strong>特点</strong>：每个进程都有一个优先级，系统根据优先级来决定调度顺序。高优先级的进程会优先执行。</li>
<li><strong>缺点</strong>：可能会导致低优先级进程“饥饿”，即长时间无法获得调度。为了解决这个问题，通常会引入优先级提升机制，使等待时间过长的进程逐渐获得更高的优先级。</li>
</ul>
</li>
<li><strong>时间片轮转（RR）</strong>：<ul>
<li><strong>特点</strong>：每个进程轮流执行，分配一个固定的时间片。当时间片用完后，进程会被挂起，调度下一个进程执行，直到所有进程执行完毕。</li>
<li><strong>缺点</strong>：如果时间片设置过大，可能导致响应时间较长；如果时间片设置过小，频繁的上下文切换会增加系统开销。</li>
</ul>
</li>
<li><strong>多级队列（Multilevel Queue Scheduling）</strong>：<ul>
<li><strong>特点</strong>：将进程按照优先级分为多个队列，不同队列使用不同的调度算法。例如，高优先级队列使用时间片轮转调度，而低优先级队列使用先来先服务（FCFS）等。</li>
<li><strong>优点</strong>：可以在不同类型的任务间进行合理的调度，确保高优先级任务不会被低优先级任务干扰。</li>
<li><strong>缺点</strong>：由于每个队列使用不同的调度算法，可能导致进程之间的切换较为复杂。</li>
</ul>
</li>
</ol>
<h4 id="进程间有哪些通信方式-进程间通信（IPC）"><a href="#进程间有哪些通信方式-进程间通信（IPC）" class="headerlink" title="进程间有哪些通信方式 &#x2F; 进程间通信（IPC）"></a>进程间有哪些通信方式 &#x2F; 进程间通信（IPC）</h4><ol>
<li><strong>管道（Pipe）</strong><ul>
<li>半双工，只能实现单向数据流动；用于父子进程或具有血缘关系的进程间通信。<br>常见于命令行中多个命令的连接，例如 <code>ls | grep txt</code>。<ul>
<li>半双工（Half-duplex）通信方式：<br>通信双方都能发送和接收数据，但同一时间只能有一个方向在传输数据，不能同时进行双向通信。</li>
</ul>
</li>
</ul>
</li>
<li><strong>命名管道（FIFO）</strong><ul>
<li>与管道类似，同样是半双工，但由于它有名字，可以在不相关的进程之间通信（无需进程之间的血缘关系）<br>常用于需要临时建立进程间数据传递通道的场景</li>
</ul>
</li>
<li><strong>消息队列</strong><ul>
<li>内核维护一个消息链表，允许进程发送格式化的消息，并支持消息优先级；通信是异步的。<br>适用于客户端—服务器模式和复杂的事件传递场景。</li>
</ul>
</li>
<li><strong>信号</strong><ul>
<li>用于向进程发送异步通知，告知某种事件的发生，通常只传递信号编号；处理函数要求尽可能简单。<br>处理用户中断（例如Ctrl+C）、定时器事件或其他异常情况。</li>
</ul>
</li>
<li><strong>信号量</strong><ul>
<li>作为计数器使用，控制多个进程或线程对共享资源的访问，通常用来实现互斥和同步。<br>解决<strong>生产者-消费者问题</strong>、资源管理和进程同步问题。</li>
</ul>
</li>
<li><strong>共享内存</strong><ul>
<li>将一段内存映射到多个进程的地址空间中，实现高速数据共享；<br>但必须借助同步机制（如互斥锁、信号量）避免竞态条件。<br>适用于大数据量、高性能的通信场景，如实时数据处理和数据库缓存。</li>
</ul>
</li>
<li><strong>Socket套接字</strong><ul>
<li>全双工，支持TCP&#x2F;IP 的网络通信的基本操作单元，<br>主要用于在客户端和服务器之间通过网络进行通信、网络应用开发以及分布式系统</li>
</ul>
</li>
</ol>
<p><strong>安全问题与预防</strong></p>
<ul>
<li><strong>竞态条件</strong>：多个进程同时访问共享数据时，若没有适当的同步机制（如互斥锁或信号量），数据可能会因操作顺序不确定而出错。<br><strong>预防</strong>：在共享内存等方式中使用锁机制或原子操作，确保临界区内操作互斥执行。</li>
<li><strong>死锁</strong>：当多个进程相互等待对方释放资源时，会导致所有进程永远阻塞。<br> <strong>预防</strong>：<ul>
<li>遵循固定顺序申请资源，避免循环等待；</li>
<li>使用超时机制，在无法获取资源时及时放弃重试；</li>
<li>尽量缩小临界区，减少持锁时间。</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li><strong>简单数据传输</strong>：使用<strong>管道</strong>或<strong>命名管道</strong>。</li>
<li><strong>异步消息传递</strong>：使用<strong>消息队列</strong>进行复杂的进程间通信。</li>
<li><strong>高性能数据共享</strong>：<strong>共享内存</strong>是最快的方式，但需要额外的同步控制。</li>
<li><strong>网络通信</strong>：使用<strong>Socket</strong>进行客户端与服务器间的数据交换。</li>
</ul>
<h4 id="解释一下进程同步和互斥，以及如何实现进程同步和互斥"><a href="#解释一下进程同步和互斥，以及如何实现进程同步和互斥" class="headerlink" title="解释一下进程同步和互斥，以及如何实现进程同步和互斥"></a>解释一下进程同步和互斥，以及如何实现进程同步和互斥</h4><p>进程同步和互斥是确保多个并发执行的进程或线程在访问共享资源时<br>不会产生数据错误和逻辑冲突的两种关键机制。</p>
<p><strong>进程同步</strong></p>
<ul>
<li>进程同步指的是多个并发执行的进程之间协调和管理它们的执行顺序或执行时机，<br> 以保证它们按照预期的顺序或时间间隔执行。<br> 这对于一些依赖于前后顺序的操作（例如生产者消费者问题）尤为重要。</li>
<li>主要目的是保证<strong>数据一致性</strong>和<strong>程序正确性</strong>，即确保在某些操作发生前，必须满足特定条件或顺序。<br> 例如，消费者在取出数据之前，必须等待生产者将数据写入缓冲区。</li>
</ul>
<p><strong>互斥</strong></p>
<ul>
<li>互斥指的是在某一时刻只允许一个进程（或线程）访问某个共享资源，<br> 防止多个进程同时进入临界区，从而避免数据竞争（Race Condition）。</li>
<li>主要是保证共享资源（如共享内存、全局变量、文件等）在同一时间内不被多个进程同时修改，确保<strong>操作的原子性</strong>和<strong>数据的完整性</strong>。</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li><p><strong>信号量和 PV 操作</strong></p>
<ul>
<li><p><strong>信号量</strong>：特殊的变量，用来表示系统中某种资源的数量或状态。</p>
</li>
<li><p><strong>PV操作</strong></p>
<ul>
<li><strong>P操作（“检查”信号量）</strong>：进入临界区前。如果信号量的值大于0，则将其减1并允许进程进入；若为0，则进程将被阻塞，等待资源释放。</li>
<li><strong>V操作（“归还”资源）</strong>：退出临界区时，将信号量的值加1，并唤醒因P操作而阻塞的进程。</li>
</ul>
</li>
<li><p>这种机制既可以实现<strong>互斥</strong>（当信号量初始值为1时，相当于互斥锁），也可以<strong>控制有限资源的访问</strong>（计数信号量）。</p>
</li>
</ul>
</li>
<li><p><strong>临界区与互斥锁（Mutex）</strong></p>
<ul>
<li><strong>临界区</strong>：<br>访问共享资源的代码段 &#x2F; 可能引发互斥问题的代码。<br>在进入临界区前，必须先获取相应的锁（互斥锁）；离开时释放锁，<br>从而保证同一时刻只有一个进程能够执行临界区内的代码。</li>
<li><strong>互斥锁</strong>：<br>每个共享资源都关联一个互斥锁，只有获得该锁的进程才能进入临界区访问资源。<br>互斥锁是一种常用的实现互斥的方法，其工作原理简单且直观。</li>
</ul>
</li>
<li><p><strong>条件变量</strong></p>
<ul>
<li><strong>条件变量</strong>：<br>条件变量通常与互斥锁配合使用，并采用<code>while循环</code>检查条件以防止假唤醒。<br>用于让进程在特定条件下（例如缓冲区非空或非满）<strong>等待&#x2F;进入阻塞状态</strong> 或 被<strong>唤醒</strong>。</li>
<li>在临界区内，进程检查某一条件是否满足，如果不满足，则调用等待操作（例如<code>wait()</code>），这会自动释放互斥锁并将进程挂起；<br>当其他进程改变了共享状态后，调用通知操作（例如<code>signal()</code>或<code>notify()</code>），唤醒等待的进程，然后重新获得互斥锁继续执行。</li>
</ul>
</li>
</ul>
<h3 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h3><h4 id="什么是死锁，如何避免死锁？"><a href="#什么是死锁，如何避免死锁？" class="headerlink" title="什么是死锁，如何避免死锁？"></a>什么是死锁，如何避免死锁？</h4><p>系统中多个进程&#x2F;线程分别持有部分资源，且<strong>相互等待</strong>其他进程释放它们所需的资源而造成的一种僵局</p>
<p><strong>死锁同时满足四个条件，破坏其一即可预防</strong></p>
<ul>
<li><strong>互斥条件</strong>：资源不能被多个进程共享<ul>
<li>某些资源（如读操作）可以设计为共享模式，降低互斥资源的使用场景</li>
</ul>
</li>
<li><strong>请求保持条件</strong>：进程在等待新的资源而阻塞时不会释放自己的资源。<ul>
<li>采用一次性申请策略：<br>进程在开始执行前一次性申请所有需要的资源；<br>若无法全部获得，则不占有任何资源，待所有资源可用时再执行。</li>
<li>或者采用动态释放策略：<br>在申请资源时如果发现无法一次性满足所有资源要求，<br>则释放当前已占用资源，等待一段时间后重试。</li>
</ul>
</li>
<li><strong>不可剥夺条件</strong>：资源在未使用完之前，不能被操作系统&#x2F;其他进程强制收回，只能由进程自己释放。<ul>
<li>资源分配时允许抢占：<br>进程请求新资源而系统检测到可能发生死锁时，可暂时剥夺其他进程占用的部分资源分配给请求者</li>
</ul>
</li>
<li><strong>循环等待条件</strong>：系统中存在进程循环链，每个进程都在等待链中下一个进程所占有的资源，形成闭环。<ul>
<li>为所有资源设定一个全局的顺序：<br>要求所有进程按照相同顺序申请资源，防止形成循环等待。<br>例如，规定进程申请资源时必须先申请编号较小的，再申请编号较大的资源，避免出现闭环等待。</li>
</ul>
</li>
</ul>
<p><strong>无法完全预防死锁的情况下，系统可以采用检测与恢复机制</strong></p>
<ul>
<li><p><strong>死锁检测</strong></p>
<ul>
<li><strong>资源分配图检测</strong>：构建资源分配图或等待图，定期检查是否存在环路。若存在闭环，则说明可能发生了死锁。</li>
<li><strong>银行家算法</strong>：通过模拟资源分配过程来判断系统是否进入不安全状态。</li>
</ul>
</li>
<li><p><strong>死锁解除</strong>：一旦检测到死锁，可以采取如下措施解除：</p>
<ul>
<li><strong>进程中止</strong>：选择中止一个或多个处于死锁状态的进程，以打破循环等待。</li>
<li><strong>资源抢占</strong>：强制收回某些进程已经占用的资源，使系统重新恢复到安全状态。</li>
<li><strong>回滚机制</strong>：事务性系统中，通过回滚部分操作来释放资源，重新执行操作，确保系统数据一致性。</li>
</ul>
</li>
</ul>
<h4 id="介绍一下几种典型的锁"><a href="#介绍一下几种典型的锁" class="headerlink" title="介绍一下几种典型的锁"></a>介绍一下几种典型的锁</h4><p><strong>互斥锁</strong>：</p>
<ul>
<li><p>任何时刻只有一个线程能够进入临界区访问&#x2F;修改资源。<br>其他线程等待该锁释放后获取，保证<strong>资源的一致性</strong>。</p>
</li>
<li><p><strong>优点</strong>：实现简单，能有效防止数据并发修改引发的不一致问题。<br><strong>缺点</strong>：但在高并发场景下容易引起线程阻塞和上下文切换，进而影响系统性能。</p>
</li>
<li><p><strong>适用场景</strong></p>
<ul>
<li>需要独占访问共享数据的场合（如写操作）、</li>
<li>数据竞争较严重的环境。</li>
</ul>
</li>
</ul>
<p><strong>自旋锁</strong></p>
<ul>
<li>自旋锁与互斥锁的作用类似，都用于保护共享资源。<br>但自旋锁获取不到锁时不会让线程进入睡眠状态，<br>而是采用忙等待（busy waiting）的方式<strong>不断轮询</strong>锁的状态，直到锁可用。</li>
<li><strong>优点</strong>：避免了线程切换带来的开销，延迟较低。<br><strong>缺点</strong>：如果锁等待时间较长，会占用CPU资源，导致资源浪费；在单核系统上效果较差。</li>
<li><strong>适用场景</strong><ul>
<li>持锁时间非常短的临界区，能降低线程切换的开销、</li>
<li>多核处理器环境中，适合使用自旋锁，因为忙等待期间其他线程可在其他核上执行。</li>
</ul>
</li>
</ul>
<p><strong><code>互斥锁</code>和<code>自旋锁</code>是最基本的两种锁机制。</strong><br><strong>高级锁（如读写锁、悲观锁和乐观锁）的实现往往是基于这两种基本机制的扩展或改进</strong></p>
<p><strong>读写锁</strong></p>
<ul>
<li>在互斥锁基础上的扩展，特点是允许多个线程同时执行<strong>读操作</strong>，但在执行<strong>写操作</strong>时要求<strong>独占访问</strong>。<br>即在<strong>写操作</strong>进行时，不允许其他线程进行读或写操作，从而保证<strong>数据的完整性</strong>。</li>
<li><strong>优点</strong>：能显著提高读密集型应用的并发性能，减少锁竞争。<br><strong>缺点</strong>：如果写操作频繁，可能会出现写饥饿或整体性能下降的情况，同时实现上比互斥锁复杂。</li>
<li><strong>适用场景</strong><ul>
<li>读操作远多于写操作的场合，如缓存系统或配置文件的读取、</li>
<li>需要在保证数据一致性的同时提高系统并发度。</li>
</ul>
</li>
</ul>
<p><strong>悲观锁</strong></p>
<ul>
<li>悲观锁 假定 <code>在并发环境下数据冲突 / 多线程同时修改共享资源</code> 的概率比较高<br>在访问共享资源时一律上锁，确保在操作过程中不会发生并发冲突（如数据库中常见的行级锁和表级锁）</li>
<li><strong>优点</strong>：安全性高，能有效防止并发冲突。<br><strong>缺点</strong>：加锁时间较长可能会降低系统吞吐量，引发较多的阻塞等待。</li>
<li><strong>适用场景</strong><ul>
<li>多线程或多进程写操作较多、冲突频繁的场景，如金融系统中的账户转账。</li>
<li>数据一致性要求非常高的业务逻辑。</li>
</ul>
</li>
</ul>
<p><strong>乐观锁</strong></p>
<ul>
<li>乐观锁基于“冲突较少”的假设，在操作共享资源时不立即加锁，而是在更新时检测数据是否被其他线程修改。<br>常见的实现方式有基于版本号（versioning）或时间戳的比较，在冲突检测到时，放弃本次修改或者重试操作。</li>
<li><strong>优点</strong>：无需长时间持有锁，可以极大地提高并发性能。<br><strong>缺点</strong>：在高冲突环境下，频繁的冲突检测和重试会影响整体效率，同时实现逻辑较为复杂。</li>
<li><strong>适用场景</strong><ul>
<li>读操作远多于写操作的场景，如用户信息更新、库存扣减等。</li>
<li>并发冲突发生概率较低的系统中，能最大限度地减少锁竞争。</li>
</ul>
</li>
</ul>
<p><strong>选择策略</strong></p>
<ul>
<li><strong>互斥锁</strong>适用于简单的独占访问场景；<strong>自旋锁</strong>适用于临界区操作短、上下文切换成本较高的场合；</li>
<li><strong>读写锁</strong>在读多写少的场景中能显著提升并发性能；</li>
<li><strong>悲观锁</strong>在高冲突、高一致性要求的场合较为稳妥；<strong>乐观锁</strong>则适合冲突较少、追求高并发性能的场景。</li>
</ul>
<h4 id="讲一讲你理解的虚拟内存"><a href="#讲一讲你理解的虚拟内存" class="headerlink" title="讲一讲你理解的虚拟内存"></a>讲一讲你理解的虚拟内存</h4><ul>
<li><strong>定义和工作原理</strong><ul>
<li>虚拟内存为每个进程提供一个看似连续的虚拟地址空间，其实际<strong>映射</strong>关系由页表维护，<br>利用内存管理单元（MMU）完成虚拟地址到物理地址的转换。</li>
<li>当某个虚拟页面不在物理内存中时，会触发缺页异常，操作系统负责将该页面从硬盘（交换区）调入内存。</li>
</ul>
</li>
<li><strong>页置换算法的作用</strong><ul>
<li>当物理内存资源不足时，操作系统会采用页置换算法（例如FIFO、LRU等）来决定哪些页面需要被换出，从而为新加载的页面腾出内存空间。</li>
</ul>
</li>
<li><strong>虚拟内存的优点与可能的性能问题</strong><ul>
<li>优点<ul>
<li>扩展内存容量，使程序能够使用超过实际物理内存大小的内存空间。</li>
<li>提供内存隔离，确保各进程之间的内存安全。</li>
<li>通过内存映射文件技术，实现高效的文件I&#x2F;O操作。</li>
</ul>
</li>
<li>性能问题<ul>
<li>频繁的缺页异常和页面交换可能引发I&#x2F;O瓶颈，从而降低系统性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h3><h4 id="你知道的线程同步的方式有哪些？"><a href="#你知道的线程同步的方式有哪些？" class="headerlink" title="你知道的线程同步的方式有哪些？"></a>你知道的线程同步的方式有哪些？</h4><p>线程同步机制：多线程编程中保证线程之间的互不干扰的机制</p>
<ul>
<li><p><strong>互斥锁</strong></p>
<ul>
<li>用于保护共享资源，使任一时刻只有一个线程能进入临界区，防止多个线程同时修改数据，确保数据一致性。</li>
<li><strong>优点</strong>：实现简单、适用性广。<br><strong>缺点</strong>：如果使用不当可能会导致线程长时间等待甚至死锁，锁粒度过大时会降低并发性能。</li>
</ul>
</li>
<li><p><strong>自旋锁</strong></p>
<ul>
<li>自旋锁在等待锁时不会挂起线程，而是通过忙等待（不断循环检测锁状态）保持对锁的占用，适用于临界区执行时间非常短的情况。</li>
<li><strong>优点</strong>：避免线程挂起与上下文切换，适合多核系统中短时竞争场景。<br><strong>缺点</strong>：如果等待时间较长，自旋会占用大量CPU资源，可能导致效率低下。</li>
</ul>
</li>
<li><p><strong>读写锁</strong></p>
<ul>
<li>读写锁允许多个线程并发读取共享数据，但写操作时要求独占访问。<br>这种机制在读操作远多于写操作时能显著提高并发性能。</li>
<li><strong>优点</strong>：在读多写少的场景下能提高系统整体并发性。<br><strong>缺点</strong>：实现较复杂，可能出现写者饥饿（长时间等待写入）的情况。</li>
</ul>
</li>
<li><p><strong>条件变量</strong></p>
<ul>
<li>条件变量允许线程在等待特定条件（如队列不为空、资源可用等）时进入睡眠状态，<br>避免忙等待。通常需要与互斥锁结合使用，确保状态检查与等待操作的原子性。</li>
<li><strong>优点</strong>：有效降低CPU空转，适合事件触发和生产者-消费者模型。<br><strong>缺点</strong>：使用时逻辑较复杂，容易出错，必须保证条件的正确性和通知的及时性。</li>
</ul>
</li>
<li><p><strong>信号量</strong></p>
<ul>
<li>信号量是一种基于计数器的同步机制，用于控制对共享资源的访问数量。<br>二值信号量（值为1）可用于实现互斥，而计数信号量允许多个线程同时访问有限的资源（如连接池）。</li>
<li><strong>优点</strong>：灵活控制并发访问的数量，适用于有限资源的管理。<br><strong>缺点</strong>：管理和调试较复杂，容易因计数错误导致资源泄露或竞争问题。</li>
</ul>
</li>
</ul>
<p><strong>如何选择合适的线程同步机制</strong></p>
<ul>
<li><strong>资源访问方式</strong>：  <ul>
<li>需要严格互斥时优先使用<strong>互斥锁</strong>；  </li>
<li>临界区执行时间非常短且竞争不激烈时，<strong>自旋锁</strong>可以减少上下文切换；  </li>
<li>对共享数据的读操作远多于写操作时，使用<strong>读写锁</strong>能提高并发度。</li>
</ul>
</li>
<li><strong>线程间通信</strong>：  <ul>
<li>当线程需要等待某个条件满足时，<strong>条件变量</strong>是理想的选择；  </li>
<li>对于管理有限资源访问，<strong>信号量</strong>能有效控制同时访问的线程数。</li>
</ul>
</li>
</ul>
<h4 id="有哪些页面置换算法"><a href="#有哪些页面置换算法" class="headerlink" title="有哪些页面置换算法"></a>有哪些页面置换算法</h4><ul>
<li><p><strong>最佳置换算法（OPT）</strong></p>
<ul>
<li>根据未来页面访问情况，选择最长时间内不会被访问的页面进行淘汰。</li>
<li>理论上缺页率最低，常作为性能下界参考；<br>实际中无法实现，因为操作系统无法预知未来的页面访问序列。</li>
<li><strong>适用场景</strong>：理论研究和算法性能比较时使用。</li>
</ul>
</li>
<li><p><strong>先进先出算法（FIFO）</strong></p>
<ul>
<li>按照页面进入内存的顺序，最早进入的页面先被淘汰。</li>
<li>实现简单，但可能会淘汰仍在被频繁使用的页面，<br>容易出现“Belady 异常”（增加内存反而缺页率上升）。</li>
<li><strong>适用场景</strong>：<br>对实现要求简单且不追求最优性能的场景。</li>
</ul>
</li>
<li><p><strong>最近最久未使用算法（LRU）</strong></p>
<ul>
<li>利用页面历史访问记录，淘汰最长时间未被访问的页面。</li>
<li>符合程序时间局部性原理，缺页率较低；<br>但需要维护访问顺序或时间戳，开销相对较大。</li>
<li><strong>适用场景</strong>：应用于大部分实际系统，尤其适合访问模式具有明显时间局部性的场景。</li>
</ul>
</li>
<li><p><strong>时钟算法（Clock）</strong></p>
<ul>
<li>利用环形队列和页面的引用位来近似实现 LRU。时钟指针遍历页面，<br>当遇到引用位为 0 的页面时进行置换；若引用位为 1，则清零后继续查找。</li>
<li>实现较简单，开销低，能够较好地平衡实现复杂性和性能，是 LRU 的一种高效近似算法。</li>
<li><strong>适用场景</strong>：实际操作系统中广泛采用，特别是在硬件资源有限、需要降低实现成本的场景。</li>
</ul>
</li>
<li><p><strong>最不经常使用算法（LFU）</strong></p>
</li>
<li><p>记录页面访问频率，淘汰访问次数最少的页面。</p>
</li>
<li><p>能反映页面的长期使用情况，适用于访问模式相对稳定的环境；<br>但对突发性或短期变化响应不够敏感，维护访问计数也会增加额外开销。</p>
</li>
<li><p><strong>适用场景</strong>：用于那些页面访问频率变化较小的系统，但在动态环境下可能不够灵活。</p>
</li>
</ul>
<p><strong>如何选择</strong></p>
<ul>
<li><strong>理论与实际折中</strong>：<br> 虽然最佳置换算法（<strong>OPT</strong>）理论上最优，但实际中无法实现，<br>因此常用 <strong>LRU</strong> 或其近似算法（如 <strong>Clock</strong>）来兼顾性能和实现复杂度。</li>
<li><strong>实现复杂度与系统特性</strong>：<br><strong>FIFO</strong> 实现简单，但在某些场景下可能性能不佳；<br>而 <strong>LRU</strong> 和 <strong>LFU</strong> 虽然性能较优，但开销较大，需要额外的数据结构支持。</li>
<li><strong>工作负载特点</strong>：<br>根据系统的内存容量、访问局部性（时间或频率）以及实际工作负载，<br>选择合适的算法可以在资源利用和系统响应之间取得平衡。</li>
</ul>
<h3 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h3><h4 id="熟悉哪些Linux命令"><a href="#熟悉哪些Linux命令" class="headerlink" title="熟悉哪些Linux命令"></a>熟悉哪些Linux命令</h4><p><strong>文件操作：</strong></p>
<ul>
<li><code>ls</code>：列出目录内容、<code>cd</code>：更改当前工作目录、<br><code>pwd</code>：显示当前工作目录路径。</li>
<li><code>cp</code>：复制文件或目录、<br><code>mv</code>：移动或重命名文件或目录、<code>rm</code>：删除文件或目录。</li>
<li><code>touch</code>：创建空文件或更新文件的时间戳。</li>
<li><code>mkdir</code>：创建新目录、<code>rmdir</code>：删除空目录。</li>
</ul>
<p><strong>文件内容查看：</strong></p>
<ul>
<li><code>cat</code>：连接并显示文件内容。<br><code>head</code>：显示文件的前几行。<br><code>tail</code>：显示文件的后几行，常用于查看日志文件。</li>
<li><code>more</code>：分页显示文件内容。<br><code>less</code>：与 <code>more</code> 类似，但提供更强大的导航功能。</li>
</ul>
<p><strong>权限管理：</strong></p>
<ul>
<li><code>chmod</code>：更改文件或目录的访问权限。<br><code>chown</code>：更改文件或目录的所有者和&#x2F;或所属组。</li>
</ul>
<p><strong>磁盘管理：</strong></p>
<ul>
<li><code>df</code>：显示文件系统的磁盘空间使用情况。<br><code>du</code>：估算文件和目录的磁盘使用情况。</li>
<li><code>fdisk</code>：用于磁盘分区的管理工具。</li>
<li><code>mount</code>：挂载文件系统。<br><code>umount</code>：卸载已挂载的文件系统。</li>
</ul>
<p><strong>网络管理：</strong></p>
<ul>
<li><code>ifconfig</code>&#x2F;<code>ip addr</code>：显示或配置网络接口。</li>
<li><code>ping</code>：测试与主机的网络连接。</li>
<li><code>netstat</code>：显示网络连接、路由表和接口统计信息。</li>
<li><code>ssh</code>：通过安全外壳协议远程登录。<br><code>scp</code>：通过 SSH 进行安全的文件复制。<br><code>ftp</code>：文件传输协议客户端，用于在网络上传输文件。</li>
</ul>
<p><strong>进程管理：</strong></p>
<ul>
<li><code>ps</code>：显示当前进程的快照。<br><code>top</code>：实时显示系统中各个进程的资源使用情况。</li>
<li><code>kill</code>：向进程发送信号（通常用于终止进程）。<br><code>killall</code>：通过进程名终止所有匹配的进程。</li>
<li><code>bg</code>：将进程放到后台运行、<code>fg</code>：将后台进程带到前台运行。</li>
</ul>
<p><strong>软件包管理：</strong></p>
<ul>
<li><code>apt-get</code>：Debian 系列发行版的包管理工具，用于安装、更新和删除软件包。<br><code>yum</code>：Red Hat 系列发行版的包管理工具，用于安装、更新和删除软件包。</li>
<li><code>rpm</code>：Red Hat Package Manager，用于安装、查询、验证、更新和卸载 RPM 包。<br><code>dpkg</code>：Debian 包管理器，用于安装、构建、删除和管理 Debian 软件包。</li>
</ul>
<h4 id="Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用"><a href="#Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用" class="headerlink" title="Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用"></a>Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用</h4><p><strong>1. 查看进程</strong></p>
<ul>
<li>方法：<ul>
<li>使用 <code>ps aux</code> 或 <code>ps -ef</code> 命令列出当前所有进程及详细信息。</li>
<li>使用 <code>top</code> 或 <code>htop</code> 命令实时监控进程的运行状态和资源占用情况。</li>
</ul>
</li>
</ul>
<p><strong>2. 杀死进程</strong></p>
<ul>
<li>方法：<ul>
<li>首先使用 <code>ps</code> 或 <code>top</code> 命令查找目标进程的 PID（进程ID）。</li>
<li>然后使用 <code>kill PID</code> 命令发送终止信号（默认 SIGTERM）来请求进程结束。</li>
<li>如果进程无法正常退出，可使用 <code>kill -9 PID</code> 强制终止进程。</li>
</ul>
</li>
</ul>
<p><strong>3. 查看端口占用</strong></p>
<ul>
<li>方法：<ul>
<li>使用 <code>lsof -i:端口号</code> 命令可以列出占用特定端口的进程信息。</li>
<li>或者使用 <code>netstat -tulnp | grep 端口号</code> 命令查看该端口的监听状态和相关进程ID。</li>
<li>另外，<code>ss -tulnp | grep 端口号</code> 也是常用的工具，输出信息类似于 netstat，但速度更快。</li>
</ul>
</li>
</ul>
<h4 id="说一下-select、poll、epoll"><a href="#说一下-select、poll、epoll" class="headerlink" title="说一下 select、poll、epoll"></a>说一下 select、poll、epoll</h4><ul>
<li><strong>select</strong><ul>
<li><strong>原理</strong>：传入一个固定大小的文件描述符集合，内核逐一检查这些描述符是否有可读、可写或异常事件。</li>
<li><strong>特点与限制</strong>：实现简单、兼容性好，但受限于最大描述符数（通常为1024）且每次调用都需要遍历整个集合，效率随描述符数量增加而下降。</li>
</ul>
</li>
<li><strong>poll</strong><ul>
<li><strong>原理</strong>：使用动态数组（pollfd数组）来监控多个文件描述符，避免了select固定数量的限制。</li>
<li><strong>特点与限制</strong>：克服了文件描述符数量的限制，但同样需要遍历整个数组，性能随描述符数量线性下降，拷贝开销较大。</li>
</ul>
</li>
<li><strong>epoll</strong><ul>
<li><strong>原理</strong>：将感兴趣的文件描述符注册到内核中，内核维护一个事件表，并在文件描述符就绪时通过事件通知给应用程序。支持水平触发和边缘触发模式。</li>
<li><strong>特点与限制</strong>：在处理大量文件描述符时效率高，时间复杂度接近 O(1)；但仅适用于 Linux 平台，且在活动连接非常频繁的情况下，边缘触发模式下的处理需要开发者额外注意，可能使优势不那么明显。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：<br><strong>select</strong> 是最早的 I&#x2F;O 多路复用技术，但存在文件描述符数量和效率上的限制；</p>
<p><strong>poll</strong> 改进了数量限制的问题，但在大量连接时性能仍然不足；</p>
<p>而 <strong>epoll</strong> 则通过事件驱动方式显著提高了性能，尤其适用于高并发场景，<br>不过仅在 Linux 平台可用，并且在某些特殊情况下（如活动连接频繁）其优势可能会减弱。</p>
<h3 id="Day16"><a href="#Day16" class="headerlink" title="Day16"></a>Day16</h3><h4 id="一条SQL查询语句是如何执行的？"><a href="#一条SQL查询语句是如何执行的？" class="headerlink" title="一条SQL查询语句是如何执行的？"></a>一条SQL查询语句是如何执行的？</h4><ul>
<li><strong>连接器</strong>：<br>负责与客户端建立连接、进行权限认证，并维持和管理整个会话。</li>
<li><strong>查询缓存</strong>：<br> 当接收到查询请求后，MySQL 首先检查查询缓存，判断是否存在相同语句的执行结果；如果存在，则直接返回缓存中的结果，节省解析和执行的开销。</li>
<li><strong>分析器</strong>：<br> 将输入的 SQL 语句拆分成多个字符串和标记，识别各部分的含义，构建解析树（或抽象语法树），确保语句符合语法和语义规则。</li>
<li><strong>优化器</strong>：<br> 根据解析器输出的语法树以及数据库中的索引、统计信息等，决定最优的执行计划。比如在多索引或多表关联时，选择合适的索引和连接顺序，以降低查询成本。</li>
<li><strong>执行器</strong>：<br> 根据优化器生成的执行计划，实际执行查询操作，读取数据、进行计算和转换，最后将结果返回给客户端。</li>
</ul>
<p>这种分层设计使得 MySQL 在处理查询请求时能够高效地完成从连接建立、缓存检查、语句解析、执行计划优化到最终数据检索的全过程。</p>
<h4 id="事务的四大特性-ACID-属性-有哪些？"><a href="#事务的四大特性-ACID-属性-有哪些？" class="headerlink" title="事务的四大特性 &#x2F; ACID 属性 有哪些？"></a>事务的<code>四大特性</code> &#x2F; <code>ACID 属性</code> 有哪些？</h4><ul>
<li><p><strong>原子性（Atomicity）</strong></p>
<ul>
<li>一个事务中的所有操作<strong>要么全部成功，要么全部失败</strong>。</li>
<li>确保<strong>数据操作的不可分割性</strong>，避免部分提交导致数据不一致。</li>
<li>举例：在银行转账中，扣款和加款必须同时完成；如果其中一步失败，则整个转账操作都会回滚，保证账户状态不出现部分更新的情况。</li>
</ul>
</li>
<li><p><strong>一致性（Consistency）</strong></p>
<ul>
<li>事务必须使数据库从一个一致性状态转换到另一个一致性状态。</li>
<li>保证业务规则和约束始终得到遵守，防止数据错误。</li>
<li>举例：在订单处理系统中，订单总金额与库存数量之间的关系在事务执行前后必须保持业务规则的一致性。</li>
</ul>
</li>
<li><p><strong>隔离性（Isolation）</strong></p>
<ul>
<li><strong>并发执行的事务之间互不干扰，执行结果应该与串行执行相同</strong>。</li>
<li>防止并发事务间的相互干扰，确保数据的正确性。</li>
<li>举例：当两个用户同时更新同一条记录时，通过隔离机制避免数据竞争，确保每个事务看到的数据都是正确且独立的。</li>
<li><strong>现代技术</strong>：多版本并发控制（MVCC）就是一种实现隔离性的机制，通过保存数据的多个版本来减少锁竞争，提高并发性能。</li>
</ul>
</li>
<li><p><strong>持久性（Durability）</strong></p>
<ul>
<li><p>一旦<strong>事务提交，其对数据库的修改将永久保存</strong>，即使系统出现故障也不会丢失。</p>
</li>
<li><p>保证事务结果的长期可靠性和数据安全性。</p>
</li>
<li><p>举例：在订单提交后，即使数据库发生崩溃，已提交的订单信息也应该在恢复后依然存在。</p>
</li>
</ul>
</li>
</ul>
<h4 id="数据库的事务隔离级别有哪些？"><a href="#数据库的事务隔离级别有哪些？" class="headerlink" title="数据库的事务隔离级别有哪些？"></a>数据库的事务隔离级别有哪些？</h4><ul>
<li><p><strong>读未提交</strong></p>
<ul>
<li>允许一个事务读取其他事务尚未提交的修改数据，<strong>并发性能最高</strong></li>
<li>是最低的隔离级别，因此会存在<strong>脏读</strong>、<strong>不可重复读</strong>和<strong>幻读</strong>的问题。<strong>数据一致性较弱</strong></li>
</ul>
</li>
<li><p><strong>读已提交</strong></p>
<ul>
<li>一个事务只能读取其他事务已经提交的数据，未提交的数据对当前事务不可见。是<strong>大多数系统的默认选择</strong></li>
<li>能够解决<strong>脏读问题</strong>，适合大部分应用场景。<br>但由于在同一事务中多次读取可能遇到其他事务提交的数据，所以仍可能发生<strong>不可重复读</strong>和<strong>幻读</strong>。</li>
</ul>
</li>
<li><p><strong>可重复读</strong></p>
<ul>
<li>保证在事务执行期间，多次读取同一数据得到的结果一致。</li>
<li>在事务开始后和结束前，其他事务对数据的修改对当前事务不可见，从而解决了不可重复读的问题。提高了<strong>事务内数据一致性</strong><br>不过，在某些情况下可能仍然会遇到<strong>幻读</strong>（例如插入新的符合查询条件的数据）。</li>
</ul>
</li>
<li><p><strong>序列化</strong></p>
<ul>
<li>最高的隔离级别，通过强制事务串行化执行，使得并发事务的执行结果与串行执行的效果完全一致。提供<strong>最严格的数据一致性保证</strong></li>
<li><strong>从根本上避免了脏读、不可重复读和幻读问题。</strong><br>由于严格的并发控制，可能会对性能产生较大的影响，适用于对数据一致性要求极高的场景。</li>
</ul>
</li>
</ul>
<h3 id="Day17"><a href="#Day17" class="headerlink" title="Day17"></a>Day17</h3><h4 id="MySQL的执行引擎有哪些？"><a href="#MySQL的执行引擎有哪些？" class="headerlink" title="MySQL的执行引擎有哪些？"></a>MySQL的执行引擎有哪些？</h4><p>MySQL 提供多种存储引擎来满足不同业务需求，<br>最常用的有 InnoDB 和 MyISAM，<br>此外还有 Memory、Archive、CSV、Blackhole、NDB Cluster 等。</p>
<ul>
<li><p><strong>InnoDB</strong></p>
<ul>
<li>目前MySQL的默认存储引擎，适用于需要事务和高并发的应用。<ul>
<li>OLTP（联机事务处理）应用，如银行、电子商务系统，要求数据一致性和高并发写入。</li>
</ul>
</li>
<li><strong>事务支持</strong>：完全支持 ACID 事务，保证数据一致性。</li>
<li><strong>锁机制</strong>：采用行级锁，能有效支持高并发写操作。<br><strong>外键支持</strong>：支持外键约束，有助于维护数据完整性。</li>
<li><strong>崩溃恢复</strong>：具有良好的崩溃恢复能力，数据安全性高。</li>
</ul>
</li>
<li><p><strong>MyISAM</strong></p>
<ul>
<li>早期的默认存储引擎，支持全文索引，但是不支持事务，也不支持行级锁和外键约束，适用于快速读取且数据量不大的场景。<ul>
<li>读密集型应用、数据仓库或数据分析场景，不需要事务支持和复杂的并发控制。</li>
</ul>
</li>
<li><strong>非事务性</strong>：不支持事务，数据一致性保障较弱。</li>
<li><strong>锁机制</strong>：使用表级锁，读写操作并发性较低，但在读密集型场景下表现优秀。</li>
<li><strong>索引和全文搜索</strong>：支持全文索引，适合搜索应用。</li>
<li><strong>存储效率</strong>：通常存储空间占用较小，适合静态数据或日志存储。</li>
</ul>
</li>
<li><p><strong>其他存储引擎</strong></p>
<ul>
<li><strong>Memory</strong>：<br>数据存储在内存中，查询速度极快。<br>数据会在服务器重启后丢失，适合用于临时表或缓存数据。</li>
<li><strong>Archive</strong>：<br>优化了高速数据插入和数据压缩，适合存放归档数据或日志。<br>只支持 INSERT 和 SELECT，索引功能有限。</li>
<li><strong>CSV</strong>：数据以 CSV 格式存储，便于与其他系统交换数据，但不适合复杂查询和高性能需求。</li>
<li><strong>Blackhole</strong>：数据写入后即被丢弃，常用于复制中充当中转站。</li>
<li><strong>NDB Cluster</strong>：用于构建高可用、高扩展性的分布式集群，适合要求高容错和实时处理的场景。</li>
</ul>
</li>
<li><p><strong>选择</strong></p>
<ul>
<li><strong>事务性与数据一致性</strong>：如果应用要求支持事务、行级锁和外键约束，则应选择 <strong>InnoDB</strong>。</li>
<li><strong>高读取性能</strong>：对于以读为主且对事务要求不高的场景，<strong>MyISAM</strong> 是一个不错的选择。</li>
<li><strong>临时高速存取</strong>：当需要快速访问数据且不关心持久性时，可以使用 <strong>Memory</strong> 引擎。</li>
</ul>
</li>
</ul>
<h4 id="MySQL为什么使用B-树来作索引"><a href="#MySQL为什么使用B-树来作索引" class="headerlink" title="MySQL为什么使用B+树来作索引"></a>MySQL为什么使用B+树来作索引</h4><p> B+树 能够提供高效且稳定的查询性能，同时大大减少磁盘 I&#x2F;O 操作，并支持高效的范围查询。</p>
<p><strong>什么是 B树？</strong></p>
<ul>
<li><strong>B树</strong> 是一种多路平衡查找树，所有节点都保持有序，并且所有叶子节点都处于同一深度。</li>
<li>在 B树中，每个节点既存储索引键也存储数据（记录）。这样，在进行单点查找时，可能在非叶节点就能直接返回结果。</li>
<li>B树支持高效的查找、插入和删除操作，但由于每个节点同时存储数据和索引，其存储空间利用率和树的高度可能不是最优的。</li>
</ul>
<p><strong>为什么 MySQL 使用 B+树 作为索引？</strong></p>
<ul>
<li><strong>专门用于索引</strong>：<ul>
<li>B+树是 B树 的变种，其非叶子节点只存储索引键，所有实际数据都存放在叶子节点中。</li>
<li>这种设计使得同样大小的节点可以存储更多的索引键，从而降低树的高度，减少磁盘访问次数，提高查询效率。</li>
</ul>
</li>
<li><strong>范围查询效率高</strong>：<ul>
<li>B+树的所有叶子节点通过链表串联，支持顺序遍历。</li>
<li>在进行范围查询时，只需定位到起始叶子节点后，依次顺序扫描即可，无需在多个不连续节点间跳跃查找。</li>
</ul>
</li>
<li><strong>磁盘 I&#x2F;O 减少</strong>：<ul>
<li>由于树的高度较低，查询时需要读取的磁盘页更少，从而显著减少了 I&#x2F;O 操作，提升了整体性能。</li>
</ul>
</li>
<li><strong>高效的插入和删除</strong>：<ul>
<li>大部分更新操作仅影响叶子节点，减少了对整体树结构的调整，提升了插入和删除的效率。</li>
</ul>
</li>
<li><strong>适合高并发</strong>：<ul>
<li>B+树的结构更适合缓存机制，能更好地利用内存缓存热点数据，从而提高高并发场景下的访问性能。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong>B树</strong> 是一种既存索引又存记录的平衡查找树，<br>而 <strong>B+树</strong> 则将所有数据都存放在叶子节点，通过链表实现叶子节点的顺序访问。</li>
<li>MySQL 之所以选择 B+树 作为索引，是因为它能使索引结构“矮胖”，<br>降低树高，减少磁盘 I&#x2F;O，同时大大提升范围查询和更新操作的效率，<br>适合高并发数据库应用场景。</li>
</ul>
<h4 id="说一下索引失效的场景？"><a href="#说一下索引失效的场景？" class="headerlink" title="说一下索引失效的场景？"></a>说一下索引失效的场景？</h4><p>索引失效意味着查询操作不能有效利用索引进行数据检索，从而导致数据库必须进行全表扫描或大量数据页的读取，严重影响查询性能。常见的索引失效场景包括：</p>
<ul>
<li><strong>使用 OR 条件</strong><br> 当查询条件中使用 OR 连接多个条件时，如果各条件分别作用于不同的列（且这些列各自有索引），MySQL 可能无法将各个索引联合利用，从而导致索引失效。</li>
<li><strong>使用非等值查询</strong><br> 对于使用 !&#x3D; 或 &lt;&gt; 这类非等值操作符的条件，尤其是当条件在 WHERE 子句的起始部分时，索引往往无法发挥作用。</li>
<li><strong>对列进行类型转换</strong><br> 如果在查询中对索引列进行了数据类型转换（如将字符转换为数字或日期），MySQL 需要对每行数据进行转换，导致索引无法直接使用。</li>
<li><strong>使用 LIKE 语句</strong><br> 当 LIKE 查询以通配符 % 开头（例如 LIKE ‘%abc’）时，由于无法确定匹配起始位置，索引也难以发挥作用。</li>
<li><strong>在列上使用函数或表达式</strong><br> 在查询条件中对索引列使用函数（如 UPPER()、SUBSTR() 等）或其他表达式，都会破坏索引的原有顺序，从而使索引失效。</li>
<li><strong>表连接中的列类型不匹配</strong><br> 如果在表连接时涉及的列数据类型不一致（例如一个表的列是整数，另一个表的列是字符串），MySQL 可能需要进行隐式类型转换，导致无法利用原有索引。</li>
</ul>
<h3 id="Day18"><a href="#Day18" class="headerlink" title="Day18"></a>Day18</h3><h4 id="什么是慢查询？原因是什么？可以怎么优化？"><a href="#什么是慢查询？原因是什么？可以怎么优化？" class="headerlink" title="什么是慢查询？原因是什么？可以怎么优化？"></a>什么是慢查询？原因是什么？可以怎么优化？</h4><ul>
<li><p>**什么是慢查询？**数据库查询的执行时间超过预设的超时时间时，就被称为慢查询。这通常意味着 SQL 执行耗时较长，会影响系统性能和响应速度。</p>
</li>
<li><p><strong>慢查询产生的原因</strong></p>
<ul>
<li><strong>查询语句复杂</strong>：涉及多个表的连接和子查询，使执行过程更复杂。</li>
<li><strong>查询数据量大</strong>：数据量庞大时，即使查询本身逻辑简单，遍历数据也会耗时较长。</li>
<li><strong>缺少合适的索引</strong>：无法利用索引导致全表扫描，查询效率大幅下降。</li>
<li><strong>数据库设计不合理</strong>：表结构设计臃肿或冗余，查询时需要处理更多无关数据。</li>
<li><strong>并发冲突</strong>：多个查询同时访问同一资源时可能产生锁等待或资源争用，从而延长响应时间。</li>
<li><strong>硬件资源不足</strong>：服务器负载过高、CPU、内存或磁盘 IO 性能不够，都会使查询变慢。</li>
</ul>
</li>
<li><p><strong>优化慢查询的方法</strong></p>
<ul>
<li><strong>定位慢查询</strong>：运行 SQL，使用慢查询日志（例如 MySQL 的 <code>slow_query_log</code>）找到耗时较长的 SQL。</li>
<li><strong>利用 EXPLAIN 分析执行计划</strong>：查看 SQL 是如何利用索引进行查询的，确定是否存在全表扫描或不合理的连接方式。</li>
<li><strong>选择区分度最高的字段建索引</strong>：针对查询条件中最具选择性的字段建立索引，可大幅减少扫描行数。</li>
<li><strong>调整查询方式</strong>：<ul>
<li>尽量避免 <code>SELECT *</code>，只查询需要的字段；</li>
<li>对于 <code>ORDER BY LIMIT</code> 的查询，尽量让排序的数据量尽早减小；</li>
<li>重写过于复杂的查询，简化子查询和多表连接。</li>
</ul>
</li>
<li><strong>遵循索引建立原则</strong><ul>
<li>注意联合索引的最左前缀匹配；</li>
<li>避免对索引列进行函数或类型转换，确保索引能生效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="undo-log、redo-log、binlog-有什么用？"><a href="#undo-log、redo-log、binlog-有什么用？" class="headerlink" title="undo log、redo log、binlog 有什么用？"></a>undo log、redo log、binlog 有什么用？</h4><table>
<thead>
<tr>
<th>日志类型</th>
<th>作用</th>
<th>记录内容</th>
<th>存储位置</th>
<th>主要应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Undo Log</strong></td>
<td>事务回滚 &amp; MVCC</td>
<td><strong>修改前的数据</strong>（逻辑日志）</td>
<td>InnoDB 存储引擎层</td>
<td>事务回滚、MVCC</td>
</tr>
<tr>
<td><strong>Redo Log</strong></td>
<td>事务持久化 &amp; 崩溃恢复</td>
<td><strong>数据页的变更</strong>（物理日志）</td>
<td>InnoDB 存储引擎层</td>
<td>事务提交、崩溃恢复</td>
</tr>
<tr>
<td><strong>Binlog</strong></td>
<td>数据备份 &amp; 主从复制</td>
<td><strong>SQL 语句</strong>（逻辑日志）</td>
<td>MySQL Server 层</td>
<td>备份恢复、主从复制</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>Undo Log（回滚日志）—— 事务回滚 &amp; MVCC</strong></p>
<ul>
<li><strong>作用</strong>：保证事务的<strong>原子性（A）和一致性（C）</strong>，用于<strong>事务回滚</strong>和<strong>MVCC（多版本并发控制）</strong>。</li>
<li><strong>记录内容</strong>：数据被修改前的值（逻辑日志）。</li>
<li><strong>存储位置</strong>：InnoDB 存储引擎层。</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>事务回滚</strong>：如果事务失败或需要撤销，Undo Log 可恢复原始数据。</li>
<li><strong>MVCC</strong>：在可重复读（Repeatable Read）等隔离级别下，提供数据的历史版本，支持一致性读。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Redo Log（重做日志）—— 事务持久化 &amp; 崩溃恢复</strong></p>
<ul>
<li><strong>作用</strong>：保证事务的<strong>持久性（D）</strong>，防止数据库崩溃导致已提交事务丢失。</li>
<li><strong>记录内容</strong>：物理日志，记录数据页的变更（写入了什么修改）。</li>
<li><strong>存储位置</strong>：InnoDB 存储引擎层（<code>ib_logfile</code>）。</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>崩溃恢复</strong>：数据库重启时，通过 Redo Log 重新应用未落盘的数据，确保已提交事务不丢失。</li>
<li><strong>WAL 机制（Write-Ahead Logging）</strong>：事务提交时，先写 Redo Log，再更新数据，提高写入性能。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Binlog（归档日志）—— 数据备份 &amp; 主从复制</strong></p>
<ul>
<li><strong>作用</strong>：用于<strong>数据恢复</strong>和<strong>主从复制</strong>，在 MySQL Server 层记录 SQL 操作。</li>
<li><strong>记录内容</strong>：逻辑日志，记录所有 DML 语句（INSERT、UPDATE、DELETE）。</li>
<li><strong>存储位置</strong>：Server 层（<code>mysql-bin</code> 文件）。</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>主从复制</strong>：主库将 Binlog 发送给从库，从库回放日志，实现数据同步。</li>
<li><strong>数据恢复</strong>：误删数据时，可通过 Binlog 进行基于时间点的恢复。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>一句话概括</strong></p>
<ul>
<li><strong>Undo Log</strong> 让事务可回滚，支持 MVCC。</li>
<li><strong>Redo Log</strong> 让事务提交后数据不丢失，即使数据库崩溃也能恢复。</li>
<li><strong>Binlog</strong> 让数据可复制、可备份，实现增量恢复和主从同步。</li>
</ul>
<h3 id="Day19"><a href="#Day19" class="headerlink" title="Day19"></a>Day19</h3><h4 id="MySQL和Redis的区别是什么"><a href="#MySQL和Redis的区别是什么" class="headerlink" title="MySQL和Redis的区别是什么"></a>MySQL和Redis的区别是什么</h4><ul>
<li><strong>MySQL</strong>：<br>关系型数据库管理系统（RDBMS），以表格形式存储数据，支持 SQL 查询语言。<ul>
<li><strong>数据存储</strong>：将数据存储在<strong>磁盘</strong>上，提供持久化存储，适合处理需要持久保存的数据。</li>
<li><strong>性能</strong>：适用于复杂查询和事务处理，但读写速度相对较慢，受磁盘 I&#x2F;O 影响。</li>
<li><strong>数据一致性</strong>：支持 ACID 事务，保证数据的一致性和完整性。</li>
<li><strong>适用场景</strong>：适用于需要<strong>复杂查询</strong>、<strong>事务支持</strong>和<strong>持久化存储</strong>的应用，如金融系统、企业级应用等。</li>
</ul>
</li>
<li><strong>Redis</strong>：<br>键值存储系统（NoSQL），以键值对形式存储数据，<br>支持多种数据结构，如字符串、列表、哈希表、集合等。<ul>
<li><strong>数据存储</strong>：将数据存储在<strong>内存</strong>中，读写速度快，适合需要快速访问的数据。</li>
<li><strong>性能</strong>：读写性能极高，适用于高并发场景，但由于基于内存，数据量过大时需要考虑内存容量限制。</li>
<li><strong>数据一致性</strong>：提供简单的事务功能，但在数据一致性方面相对较弱，适用于对一致性要求不高的场景。</li>
<li><strong>适用场景</strong>：更适合处理<strong>高速</strong>、<strong>高并发</strong>和需要<strong>缓存</strong>的数据访问，以及需要<strong>复杂数据结构</strong>和功能的场景，如实时数据分析、实时推荐、消息队列等。</li>
</ul>
</li>
</ul>
<h4 id="Redis有什么优缺点？为什么用Redis查询会比较快"><a href="#Redis有什么优缺点？为什么用Redis查询会比较快" class="headerlink" title="Redis有什么优缺点？为什么用Redis查询会比较快"></a>Redis有什么优缺点？为什么用Redis查询会比较快</h4><ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><strong>高性能</strong>：Redis 将数据存储在内存中，读写速度极快，每秒可处理超过 10 万次读写操作。 </li>
<li><strong>丰富的数据结构</strong>：支持多种数据类型，如字符串、哈希、列表、集合、有序集合等，满足各种应用场景的需求。</li>
<li><strong>高可用性</strong>：提供了<strong>分布式</strong>特性，可以将数据分布在多个节点上，<br>               支持主从复制、哨兵模式和集群模式，确保系统的高可用性和可扩展性。</li>
<li>持久化：提供 RDB（Redis Database）和 AOF（Append Only File）两种持久化方式，确保数据的安全性和可靠性。<br>            但持久化操作可能增加 I&#x2F;O 开销，影响性能。</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li><strong>内存限制</strong>：由于数据存储在内存中，数据库容量受到物理内存的限制， 相比磁盘存储成本更高，不适合存储海量数据。</li>
</ul>
</li>
<li><p><strong>查询速度快的原因：</strong></p>
<ul>
<li><strong>基于内存操作</strong>：数据存储在内存中，减少了磁盘 I&#x2F;O 操作，提高了操作速度。 </li>
<li><strong>高效的数据结构</strong>：底层多种数据结构支持不同的数据类型，优化了数据的读写效率。 </li>
<li><strong>单线程模型</strong>：采用单线程模型，避免了多线程上下文切换带来的开销和资源竞争，提高了性能。 </li>
<li><strong>I&#x2F;O 多路复用</strong>：使用 I&#x2F;O 多路复用机制，同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。</li>
</ul>
</li>
</ul>
<h3 id="Day20"><a href="#Day20" class="headerlink" title="Day20"></a>Day20</h3><h4 id="Redis的数据类型有那些？"><a href="#Redis的数据类型有那些？" class="headerlink" title="Redis的数据类型有那些？"></a>Redis的数据类型有那些？</h4><p>常见的五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）及 Zset(sorted set：有序集合)</strong>。</p>
<ul>
<li>字符串<code>STRING</code>：存储字符串数据，最基本的数据类型。</li>
<li>哈希表<code>HASH</code>：存储字段和值的映射，用于存储对象。</li>
<li>列表<code>LIST</code>：存储有序的字符串元素列表。</li>
<li>集合<code>SET</code>：存储唯一的字符串元素，无序。</li>
<li>有序集合<code>ZSET</code>：类似于集合，但每个元素都关联一个分数，可以按分数进行排序。</li>
</ul>
<p>Redis版本更新后增加了几种数据类型，</p>
<ul>
<li><code>BitMap</code>: 存储位的数据结构，可以用于处理一些位运算操作。</li>
<li><code>HyperLogLog</code>：用于基数估算的数据结构，用于统计元素的唯一数量。</li>
<li><code>GEO</code>： 存储地理位置信息的数据结构。</li>
<li><code>Stream</code>：专门为消息队列设计的数据类型。</li>
</ul>
<h4 id="Redis是单线程的还是多线程的，为什么？"><a href="#Redis是单线程的还是多线程的，为什么？" class="headerlink" title="Redis是单线程的还是多线程的，为什么？"></a>Redis是单线程的还是多线程的，为什么？</h4><p>Redis 的线程模型经历了从单线程到多线程的演进。<br>在 Redis 6.0 之前，主要采用单线程模型，这意味着所有客户端请求都由一个主线程处理。这种设计有以下优点：</p>
<ul>
<li><strong>简化模型</strong>：单线程模型简化了并发控制，避免了多线程同步问题，降低了开发复杂性。</li>
<li><strong>性能优化</strong>：由于操作主要在内存中进行，单线程避免了线程切换和锁竞争的开销。</li>
<li><strong>原子性保证</strong>：单线程执行确保了操作的原子性，简化了事务和持久化的实现。</li>
<li><strong>顺序执行</strong>：单线程保证了请求的顺序执行。</li>
</ul>
<p>但是Redis的单线程模型并不意味着它在处理客户端请求时不高效。实际上，由于其操作主要在内存中进行，Redis能够提供极高的吞吐量和低延迟的响应。</p>
<p>然而，随着业务需求的增长和技术的演进，Redis 在 6.0 版本引入了多线程模型。<br>新的多线程模型将网络 I&#x2F;O 操作分担到多个线程中，提升了处理高并发请求的能力，但核心数据操作仍然是单线程执行，以保持其原子性和一致性。</p>
<h4 id="说一说Redis持久化机制有哪些"><a href="#说一说Redis持久化机制有哪些" class="headerlink" title="说一说Redis持久化机制有哪些"></a>说一说Redis持久化机制有哪些</h4><p>Redis 提供了两种主要的持久化机制：<strong>RDB（Redis Database）</strong> 和 <strong>AOF（Append Only File）</strong>。<br>此外，从 Redis 4.0 开始，引入了<strong>混合持久化</strong>方式。</p>
<ul>
<li><p><strong>RDB（Redis Database）快照</strong></p>
<ul>
<li><p><strong>将某一时刻的内存数据，以二进制的方式写入磁盘；</strong></p>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>紧凑性</strong>：RDB 文件为紧凑的二进制文件，适合备份和传输。</li>
<li><strong>快速恢复</strong>：使用 RDB 文件恢复数据比 AOF 更快。</li>
<li><strong>性能影响小</strong>：RDB 通过子进程执行快照操作，主进程不进行 I&#x2F;O 操作，确保高性能。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>数据丢失风险</strong>：由于快照在特定时间点生成，如果 Redis 意外宕机，可能会丢失最近一次快照后的数据。</li>
<li><strong>阻塞问题</strong>：在执行 <code>SAVE</code> 命令时，Redis 会阻塞，可能影响性能。</li>
</ul>
</li>
<li><p><strong>触发方式</strong>：</p>
<ul>
<li><strong>手动触发</strong>：使用 <code>SAVE</code>（同步阻塞）或 <code>BGSAVE</code>（后台异步）命令。</li>
<li><strong>自动触发</strong>：通过配置文件设置条件，如 <code>save &lt;seconds&gt; &lt;changes&gt;</code>，在指定时间内发生指定次数的写操作时触发。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>AOF（Append Only File）日志</strong></p>
<ul>
<li><strong>每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里</strong></li>
<li><strong>优点</strong>：<ul>
<li><strong>更高的数据安全性</strong>：AOF 可以根据配置实现更频繁的持久化，减少数据丢失风险。</li>
<li><strong>可读性强</strong>：AOF 文件以文本形式记录命令，便于审查和修改。</li>
<li><strong>可修复性</strong>：即使 AOF 文件末尾损坏，Redis 也能通过内置工具修复。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>文件体积大</strong>：相比 RDB，AOF 文件通常更大。</li>
<li><strong>恢复速度慢</strong>：由于需要重放所有写操作，AOF 恢复数据的速度比 RDB 慢。</li>
<li><strong>性能影响</strong>：频繁的写操作可能影响 Redis 性能。</li>
</ul>
</li>
<li><strong>触发方式</strong>：<ul>
<li><strong>配置文件设置</strong>：通过 <code>appendonly yes</code> 启用 AOF，并设置 <code>appendfsync</code> 参数来控制持久化频率，如 <code>always</code>（每次写操作后）、<code>everysec</code>（每秒）或 <code>no</code>（由操作系统决定）。</li>
<li><strong>手动触发</strong>：使用 <code>BGREWRITEAOF</code> 命令对 AOF 文件进行重写，以压缩文件大小。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>混合持久化</strong></p>
<ul>
<li><strong>概念</strong>：从 Redis 4.0 开始，支持将 <strong>RDB 快照和 AOF 日志结合</strong>起来的混合持久化方式。</li>
<li><strong>优点</strong>：<ul>
<li><strong>兼具 RDB 和 AOF 的优点</strong>：既有 RDB 的快速恢复能力，又有 AOF 的高数据安全性。</li>
<li><strong>减少 AOF 文件大小</strong>：通过将 RDB 快照作为 AOF 文件的开头，减少了 AOF 文件的体积。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>实现复杂性增加</strong>：混合持久化的实现增加了系统的复杂性。</li>
</ul>
</li>
<li><strong>触发方式</strong>：<ul>
<li><strong>配置文件设置</strong>：通过设置 <code>aof-use-rdb-preamble yes</code> 启用混合持久化。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>RDB</strong> 适合需要快速恢复和对数据一致性要求不高的场景，而 <strong>AOF</strong> 更适合需要高数据安全性的场景。<br><strong>混合持久化方式</strong>则兼顾了两者的优点，适用于对数据安全性和恢复速度都有较高要求的场景。</p>
<h3 id="Day22"><a href="#Day22" class="headerlink" title="Day22"></a>Day22</h3><h4 id="介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？"><a href="#介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？" class="headerlink" title="介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？"></a>介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？</h4><p>在使用 Redis 作为缓存时，可能会遇到 <strong>缓存雪崩</strong>、<strong>缓存击穿</strong> 和 <strong>缓存穿透</strong> 三种问题。了解它们的定义、成因及解决方案，有助于保障系统的稳定性和性能。</p>
<p><strong>1. 缓存雪崩</strong></p>
<ul>
<li><strong>定义</strong>：缓存雪崩是指在某一时间点，缓存中大量数据同时失效，导致大量请求直接访问数据库，造成数据库压力骤增，甚至可能引发系统崩溃。</li>
<li><strong>原因</strong>：<ul>
<li>大量缓存设置了相同的过期时间，导致它们在同一时间失效。</li>
<li>缓存服务器宕机或不可用，导致所有请求直接访问数据库。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>设置不同的过期时间</strong>：为缓存添加随机的过期时间，避免大量缓存同时失效。例如，在原有过期时间基础上增加一个随机值，使缓存失效时间分散。</li>
<li><strong>缓存预热</strong>：在系统上线前，将热点数据提前加载到缓存中，避免在高并发访问时直接请求数据库。</li>
<li><strong>构建高可用缓存集群</strong>：通过主从复制、哨兵模式或集群模式，提升缓存系统的可用性，避免因缓存服务器宕机导致的雪崩。</li>
<li><strong>请求限流或熔断</strong>：在缓存失效或不可用时，对请求进行限流或熔断，防止大量请求涌向数据库，保护数据库的稳定性。</li>
</ul>
</li>
</ul>
<p><strong>2. 缓存击穿</strong></p>
<ul>
<li><strong>定义</strong>：缓存击穿是指缓存中某个热点数据在高并发访问下突然失效，导致大量请求直接访问数据库，增加数据库的负载。</li>
<li><strong>原因</strong>：<ul>
<li>热点数据在缓存中失效，而此时有大量并发请求访问该数据，导致请求直接访问数据库。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>设置热点数据永不过期</strong>：对热点数据设置为永不过期，避免缓存失效引发的击穿问题。</li>
<li><strong>使用互斥锁</strong>：在缓存失效时，通过加锁机制控制只有一个线程从数据库加载数据并回填缓存，其他线程等待或返回默认值，避免大量并发请求直接访问数据库。</li>
</ul>
</li>
</ul>
<p><strong>3. 缓存穿透</strong></p>
<ul>
<li><strong>定义</strong>：缓存穿透是指查询一个在缓存和数据库中都不存在的数据，这个数据始终无法被缓存，导致每次请求都直接访问数据库，增加数据库的负载。</li>
<li><strong>原因</strong>：<ul>
<li>用户请求的数据在缓存和数据库中都不存在，每次请求都绕过缓存直接查询数据库。</li>
<li>恶意攻击者故意请求不存在的数据，导致大量请求穿透缓存，直接打到数据库。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>使用布隆过滤器</strong>：在缓存之前增加布隆过滤器，用于快速判断请求的数据是否存在。如果布隆过滤器判断数据不存在，则直接返回，避免访问数据库。</li>
<li><strong>缓存空值</strong>：当数据库中查询不到数据时，将空结果也缓存起来，并设置一个较短的过期时间，防止同样的请求频繁访问数据库。</li>
<li><strong>参数校验</strong>：对用户的请求参数进行校验，过滤掉非法或明显不存在的请求，减少对数据库的无效访问。</li>
</ul>
</li>
</ul>
<p>针对不同的业务场景，需要选择合适的解决方案。例如，对于可能出现大量缓存同时失效的场景，可以采用设置不同过期时间和缓存预热等策略；而对于可能遭受恶意请求的场景，则可以采用布隆过滤器和参数校验等策略。综合运用多种策略，可以有效保障系统的稳定性和性能。</p>
<h4 id="如何保证数据库和缓存的一致性"><a href="#如何保证数据库和缓存的一致性" class="headerlink" title="如何保证数据库和缓存的一致性"></a>如何保证数据库和缓存的一致性</h4><p>在使用缓存（如 Redis）来提升系统性能时，由于数据库和缓存之间存在数据同步的延迟或操作顺序问题，可能导致两者数据不一致。</p>
<p><strong>可能遇到的问题：</strong></p>
<ol>
<li><strong>缓存更新延迟</strong>：在更新数据库后，未及时更新或删除缓存，导致缓存中的数据与数据库不一致。</li>
<li><strong>缓存提前失效</strong>：缓存中的数据在数据库更新前被删除，导致新的缓存数据基于旧的数据库数据生成。</li>
<li><strong>并发操作冲突</strong>：多个并发操作同时修改数据库和缓存，可能导致数据不一致。</li>
</ol>
<p><strong>保证数据库和缓存一致性的常用策略：</strong></p>
<ul>
<li><p><strong>Cache Aside（旁路缓存）</strong></p>
<ul>
<li><strong>原理</strong>：<br>应用程序首先尝试从缓存读取数据；<br>如果缓存未命中，则从数据库读取数据，并将数据写入缓存。<br>更新数据时，先更新数据库，然后使缓存失效。</li>
<li><strong>问题</strong>：在高并发场景下，可能出现以下情况：<ul>
<li><strong>脏读</strong>：一个线程更新数据库后，尚未删除缓存，另一个线程读取到旧的缓存数据。</li>
<li><strong>缓存污染</strong>：一个线程在缓存未命中时从数据库读取数据，期间另一个线程更新了数据库并使缓存失效，前一个线程可能将旧数据写入缓存，导致缓存数据不一致。</li>
</ul>
</li>
<li><strong>可行性</strong>：上述问题发生的概率较低，因为需要同时满足缓存失效和并发写操作的条件。由于数据库读写速度通常慢于缓存，读操作在写操作之前进入数据库，并在写操作之后更新的概率较低。</li>
</ul>
</li>
<li><p><strong>Read&#x2F;Write Through（读写直通）</strong></p>
<ul>
<li><strong>原理</strong>：缓存代理负责更新数据库，应用程序视后端为单一存储，存储系统自行维护缓存。</li>
<li><strong>Read Through</strong>：在查询操作中更新缓存，即当缓存失效时，由缓存服务自行加载数据，对调用方透明。</li>
<li><strong>Write Through</strong>：当数据更新时，如果未命中缓存，直接更新数据库并返回；如果命中缓存，则先更新缓存，然后由缓存自行同步更新数据库（同步操作）。</li>
<li><strong>问题</strong>：Write Through策略可能导致写操作延迟增加，因为每次写操作都需要同步更新数据库，可能影响系统性能。</li>
</ul>
</li>
<li><p><strong>Write Behind（写回）</strong></p>
<ul>
<li><strong>原理</strong>：更新数据时，仅更新缓存，不立即更新数据库，缓存会异步批量更新数据库。</li>
<li><strong>问题</strong>：此设计使数据的I&#x2F;O操作非常快，但带来的问题是数据不是强一致性的，且可能会导致数据丢失。</li>
<li><strong>可行性</strong>：适用于对数据一致性要求不高的场景，但需要设计可靠的异步批量更新机制，以减少数据丢失的风险。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/02/17/2025-02-17-Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/17/2025-02-17-Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-17 12:00:00" itemprop="dateCreated datePublished" datetime="2025-02-17T12:00:00+08:00">2025-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-19 14:02:38" itemprop="dateModified" datetime="2025-02-19T14:02:38+08:00">2025-02-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="压力测试工具-Redis-benchmark"><a href="#压力测试工具-Redis-benchmark" class="headerlink" title="压力测试工具 Redis-benchmark"></a>压力测试工具 Redis-benchmark</h3><p>Redis-benchmark是官方自带的Redis性能测试工具&#x2F;压力测试工具，可以有效的测试Redis服务的性能。</p>
<p>默认安装路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rzy@rzysredis:/$ which redis-benchmark</span><br><span class="line">/usr/bin/redis-benchmark</span><br></pre></td></tr></table></figure>

<p>确认进程开启</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试一：100个并发连接，100000个请求，检测host为localhost 端口为6379的redis服务器性能</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class="line"><span class="comment"># 测试出来的所有命令只举例一个！</span></span><br><span class="line">====== SET ======</span><br><span class="line">100000 requests completed <span class="keyword">in</span> 1.88 seconds <span class="comment"># 对集合写入测试</span></span><br><span class="line">100 parallel clients <span class="comment"># 每次请求有100个并发客户端</span></span><br><span class="line">3 bytes payload <span class="comment"># 每次写入3个字节的数据，有效载荷</span></span><br><span class="line">keep alive: 1 <span class="comment"># 保持一个连接，一台服务器来处理这些请求</span></span><br><span class="line">17.05% &lt;= 1 milliseconds</span><br><span class="line">97.35% &lt;= 2 milliseconds</span><br><span class="line">99.97% &lt;= 3 milliseconds</span><br><span class="line">100.00% &lt;= 3 milliseconds <span class="comment"># 所有请求在 3 毫秒内完成</span></span><br><span class="line">53248.14 requests per second <span class="comment"># 每秒处理 53248.14 次请求</span></span><br></pre></td></tr></table></figure>

<p>redis 性能测试工具可选参数如下<br><img src="/2025/02/17/2025-02-17-Redis/1.png"  alt="1" style="zoom: 67%;" /></p>
<h3 id="基本知识说明"><a href="#基本知识说明" class="headerlink" title="基本知识说明"></a>基本知识说明</h3><p>Redis默认有16个数据库，类似数组下标从零开始，初始默认使用零号库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Select命令切换数据库</span></span><br><span class="line">127.0.0.1:6379&gt; select 7</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[7]&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Dbsize查看当前数据库的key的数量</span></span><br><span class="line">127.0.0.1:6379&gt; select 7</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[7]&gt; DBSIZE</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[7]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DBSIZE</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; keys * # 查看具体的key</span><br><span class="line">1) &quot;counter:__rand_int__&quot;</span><br><span class="line">2) &quot;mylist&quot;</span><br><span class="line">3) &quot;k1&quot;</span><br><span class="line">4) &quot;myset:__rand_int__&quot;</span><br><span class="line">5) &quot;key:__rand_int__&quot;</span><br></pre></td></tr></table></figure>

<p>清除数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flushdb		#清空当前库</span><br><span class="line">Flushall	#清空全部的库</span><br></pre></td></tr></table></figure>

<h5 id="为什么redis是单线程"><a href="#为什么redis是单线程" class="headerlink" title="为什么redis是单线程"></a>为什么redis是单线程</h5><p>Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽</p>
<p><strong>Redis为什么这么快？</strong></p>
<ol>
<li>多线程不一定比单线程效率高，效率与CPU 、内存 、硬盘的速度都有关系</li>
<li>redis 核心就是 <strong>数据全都在内存</strong>里，单线程的去操作就是效率最高的<ul>
<li>多线程的本质就是 CPU 模拟出来多个线程的情况，<br>这种模拟出来的情况就有一个代价，就是<strong>上下文的切换</strong>，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。</li>
<li>redis 用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。在内存的情况下，这个方案就是最佳方案。</li>
</ul>
</li>
</ol>
<p>Tips：一次CPU上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us，<br>	假设1MB的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，那么就有1500ns *1000 	&#x3D; 1500us ，单线程的读完	1MB数据耗时250us ,而此时时间上下文的切换就用了1500us了</p>
<h4 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name rzy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">exists key 的名字，判断某个key是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从当前数据库 0 移动到数据库 1</span> </span><br><span class="line">127.0.0.1:6379&gt; move name 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">expire key 秒钟：为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ttl key 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</span></span><br><span class="line">127.0.0.1:6379&gt; set name rzy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE name 10</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">type</span> key 查看你的key是什么类型</span></span><br><span class="line">127.0.0.1:6379&gt; set name rzy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; type name</span><br><span class="line">string</span><br></pre></td></tr></table></figure>



<h3 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h3><h4 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h4><p><strong>单值单Value</strong></p>
<ul>
<li><p>常用命令说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># set、get、</span></span><br><span class="line"><span class="comment"># del	删除key</span></span><br><span class="line"><span class="comment"># append	对已存在的字符串之后添加值，若不存在则等价set命令</span></span><br><span class="line"><span class="comment"># strlen	获取字符串的长度</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># incr、decr 对数字进行加减，+1 和 -1。</span></span><br><span class="line"><span class="comment"># incrby、decrby 将 key 中储存的数字加上指定的增量值。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># getrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部</span></span><br><span class="line"><span class="comment"># setrange 修改指定位置之后的值 格式是 setrange key值 具体值</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># setex（set with expire） 设置值，同时给key设置生存时间</span></span><br><span class="line"><span class="comment"># setnx（set if not exist） 仅key不存在时，才设置值和生存时间，key存在时设置失败</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># mset 同时设置一个或多个 key-value 对。</span></span><br><span class="line"><span class="comment"># mget 返回所有(一个或多个)给定 key 的值。</span></span><br><span class="line"><span class="comment"># 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。</span></span><br><span class="line"><span class="comment"># msetnx 当所有 key 都成功设置，返回 1 。</span></span><br><span class="line"><span class="comment"># 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。——原子操作</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># getset（先get再set）	——常用于更新操作</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># set、get、del、append、strlen</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 value1 <span class="comment"># 设置值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1 <span class="comment"># 获得key</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; del key1 <span class="comment"># 删除key</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看全部的key</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; exists key1 <span class="comment"># 确保 key1 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; append key1 <span class="string">&quot;hello&quot;</span> <span class="comment"># 对不存在的 key 进行 APPEND ，等同于 SET</span></span><br><span class="line">key1 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 5 <span class="comment"># 字符长度</span></span><br><span class="line">127.0.0.1:6379&gt; APPEND key1 <span class="string">&quot;-2333&quot;</span> <span class="comment"># 对已存在的字符串进行 APPEND</span></span><br><span class="line">(<span class="built_in">integer</span>) 10 <span class="comment"># 长度从 5 个字符增加到 10 个字符</span></span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;hello-2333&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN key1 <span class="comment"># # 获取字符串的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># incr、decr</span></span><br><span class="line"><span class="comment"># incrby、decrby</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0 <span class="comment"># 设置浏览量为0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr views <span class="comment"># 浏览 + 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views <span class="comment"># 浏览 + 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; decr views <span class="comment"># 浏览 - 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incrby views 10 <span class="comment"># +10</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; decrby views 10 <span class="comment"># -10</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># range</span></span><br><span class="line"><span class="comment"># getrange</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 abcd123456 <span class="comment"># 设置key2的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange key2 0 -1 <span class="comment"># 获得全部的值</span></span><br><span class="line"><span class="string">&quot;abcd123456&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key2 0 2 <span class="comment"># 截取部分字符串</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># setrange</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;abcd123456&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SETRANGE key2 1 xx <span class="comment"># 替换值</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;axxd123456&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># setex（set with expire）键秒值</span></span><br><span class="line"><span class="comment"># setnx（set if not exist）</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; setex key3 60 expire <span class="comment"># 设置过期时间</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3 <span class="comment"># 查看剩余的时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 55</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey <span class="string">&quot;redis&quot;</span> <span class="comment"># 如果不存在就设置，成功返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey <span class="string">&quot;mongodb&quot;</span> <span class="comment"># 如果存在就设置，失败返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># mset </span></span><br><span class="line"><span class="comment"># msetnx </span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; mset k10 v10 k11 v11 k12 v12</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k12&quot;</span></span><br><span class="line">2) <span class="string">&quot;k11&quot;</span></span><br><span class="line">3) <span class="string">&quot;k10&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k10 k11 k12 k13</span><br><span class="line">1) <span class="string">&quot;v10&quot;</span></span><br><span class="line">2) <span class="string">&quot;v11&quot;</span></span><br><span class="line">3) <span class="string">&quot;v12&quot;</span></span><br><span class="line">4) (nil)</span><br><span class="line">127.0.0.1:6379&gt; msetnx k10 v10 k15 v15 <span class="comment"># 原子性操作！</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get key15</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统对象缓存</span></span><br><span class="line"><span class="built_in">set</span> user:1 value(json数据)</span><br><span class="line"><span class="comment"># 可以用来缓存对象</span></span><br><span class="line">mset user:1:name zhangsan user:1:age 2</span><br><span class="line">mget user:1:name user:1:age</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># getset</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb <span class="comment"># 没有旧值，返回 nil</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;mongodb&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset db redis <span class="comment"># 返回旧值 mongodb</span></span><br><span class="line"><span class="string">&quot;mongodb&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure>

<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。</p>
<p>常规key-value缓存应用：常规计数：微博数，粉丝数等。</p>
<h4 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h4><p><strong>单值多Value</strong></p>
<p>- </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Lpush：将一个或多个值插入到列表头部。（左）</span></span><br><span class="line"><span class="comment"># rpush：将一个或多个值插入到列表尾部。（右）</span></span><br><span class="line"><span class="comment"># lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。</span></span><br><span class="line"><span class="comment"># 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。</span></span><br><span class="line"><span class="comment"># 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。</span></span><br><span class="line"><span class="comment"># rpop 移除列表的最后一个元素，返回值为移除的元素。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Lindex，按照索引下标获得元素（-1代表最后一个，0代表是第一个）</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># llen 用于返回列表的长度。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lrem key 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Ltrim key 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># rpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lset key index value 将列表 key 下标为 index 的元素的值设置为 value 。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># linsert key before/after pivot value 用于在列表的元素前或者后插入元素。</span></span><br><span class="line"><span class="comment"># 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Lpush、rpush、lrange</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH list <span class="string">&quot;right&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lrange list 0 1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lpop、rpop</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; Lpop list</span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Rpop list</span><br><span class="line"><span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Lindex</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; Lindex list 1</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; Lindex list 0</span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lindex list -1</span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># llen</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; Lpush list <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; Lpush list <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; Lpush list <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; Llen list <span class="comment"># 返回列表的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lrem key</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; Lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># Ltrim key</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello2&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># rpoplpush</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist <span class="string">&quot;bar&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist myotherlist</span><br><span class="line"><span class="string">&quot;bar&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;foo&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myotherlist 0 -1</span><br><span class="line">1) <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># lset key index value</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; exists list <span class="comment"># 对空列表(key 不存在)进行 LSET</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item <span class="comment"># 报错</span></span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list <span class="string">&quot;value1&quot;</span> <span class="comment"># 对非空列表进行 LSET</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 <span class="string">&quot;new&quot;</span> <span class="comment"># 更新值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;new&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 1 <span class="string">&quot;new&quot;</span> <span class="comment"># index 超出范围报错</span></span><br><span class="line">(error) ERR index out of range</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># linsert key before/after pivot value</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; RPUSH mylist <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LINSERT mylist BEFORE <span class="string">&quot;World&quot;</span> <span class="string">&quot;There&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;There&quot;</span></span><br><span class="line">3) <span class="string">&quot;World&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h4><p><strong>单值多value</strong></p>
<p>- </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># sadd 将一个或多个成员元素加入到集合中，不能重复</span></span><br><span class="line"><span class="comment"># smembers 返回集合中的所有的成员。</span></span><br><span class="line"><span class="comment"># sismember 命令判断成员元素是否是集合的成员。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># scard，获取集合里面的元素个数</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># srem key value 用于移除集合中的一个或多个成员元素</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; srem myset <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># srandmember key 命令用于返回集合中的一个随机元素。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># spop key 用于移除集合中的指定 key 的一个或多个随机元素</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># smove SOURCE DESTINATION MEMBER</span></span><br><span class="line"><span class="comment"># 将指定成员 member 元素从 source 集合移动到 destination 集合。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 <span class="string">&quot;set2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;set2&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">- 数字集合类</span><br><span class="line">- 差集： sdiff</span><br><span class="line">- 交集： sinter</span><br><span class="line">- 并集： sunion</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; sadd key1 <span class="string">&quot;a&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 <span class="string">&quot;b&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 <span class="string">&quot;c&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 <span class="string">&quot;d&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 <span class="string">&quot;e&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SDIFF key1 key2 <span class="comment"># 差集</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER key1 key2 <span class="comment"># 交集</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION key1 key2 <span class="comment"># 并集</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;e&quot;</span></span><br><span class="line">5) <span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure>





<h4 id="哈希Hash"><a href="#哈希Hash" class="headerlink" title="哈希Hash"></a>哈希Hash</h4><p><strong>kv模式不变，但V是一个键值对</strong></p>
<p>- </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hset、hget 命令用于为哈希表中的字段赋值 。</span></span><br><span class="line"><span class="comment"># hmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段。</span></span><br><span class="line"><span class="comment"># hgetall 用于返回哈希表中，所有的字段和值。</span></span><br><span class="line"><span class="comment"># hdel 用于删除哈希表 key 中的一个或多个指定字段</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field1 <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line"><span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HMSET myhash field1 <span class="string">&quot;Hello&quot;</span> field2 <span class="string">&quot;World&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HGET myhash field1</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGET myhash field2</span><br><span class="line"><span class="string">&quot;World&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;World&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL myhash field1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field2&quot;</span></span><br><span class="line">2) <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hlen 获取哈希表中字段的数量。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET myhash field1 <span class="string">&quot;Hello&quot;</span> field2 <span class="string">&quot;World&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hexists 查看哈希表的指定字段是否存在。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hkeys 获取哈希表中的所有域（field）。</span></span><br><span class="line"><span class="comment"># hvals 返回哈希表所有域(field)的值。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; HKEYS myhash</span><br><span class="line">1) <span class="string">&quot;field2&quot;</span></span><br><span class="line">2) <span class="string">&quot;field1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HVALS myhash</span><br><span class="line">1) <span class="string">&quot;World&quot;</span></span><br><span class="line">2) <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hincrby 为哈希表中的字段值加上指定增量值。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field 5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field 1</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field -1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY myhash field -10</span><br><span class="line">(<span class="built_in">integer</span>) -5</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># hsetnx 为哈希表中不存在的的字段赋值 。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX myhash field1 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 设置成功，返回 1 。</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX myhash field1 <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 如果给定字段已经存在，返回 0 。</span></span><br><span class="line">127.0.0.1:6379&gt; HGET myhash field1</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="有序集合Zset"><a href="#有序集合Zset" class="headerlink" title="有序集合Zset"></a>有序集合Zset</h4><p>在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2</p>
<p>- </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zadd 将一个或多个成员元素及其分数值加入到有序集当中。</span></span><br><span class="line"><span class="comment"># zrange 返回有序集中，指定区间内的成员</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 <span class="string">&quot;two&quot;</span> 3 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myset 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)</span></span><br><span class="line">次序排列。</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaoming</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 xiaohong</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 500 kuangshen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># Inf无穷大量+∞,同样地,-∞可以表示为-Inf。</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf <span class="comment"># 显示整个有序集</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores <span class="comment"># 递增排列</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">6) <span class="string">&quot;5000&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 WITHSCORES <span class="comment"># 递减排列</span></span><br><span class="line">1) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">2) <span class="string">&quot;5000&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">6) <span class="string">&quot;500&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 WITHSCORES <span class="comment"># 显示工资 &lt;=2500</span></span><br><span class="line">的所有成员</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zrem 移除有序集中的一个或多个成员</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE salary 0 -1</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem salary kuangshen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE salary 0 -1</span><br><span class="line">1) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zcard 命令用于计算集合中元素的数量。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zcount 计算有序集合中指定分数区间的成员数量。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 <span class="string">&quot;world&quot;</span> 3 <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myset 1 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myset 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaoming</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 xiaohong</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 500 kuangshen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES <span class="comment"># 显示所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">6) <span class="string">&quot;5000&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrank salary kuangshen <span class="comment"># 显示 kuangshen 的薪水排名，最少</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; zrank salary xiaohong <span class="comment"># 显示 xiaohong 的薪水排名，第三</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line"><span class="comment"># zrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。</span></span><br><span class="line"><span class="comment"># ===================================================</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK salary kuangshen <span class="comment"># 狂神第三</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK salary xiaohong <span class="comment"># 小红第一</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>





<h3 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h3><h4 id="GEO地理位置"><a href="#GEO地理位置" class="headerlink" title="GEO地理位置"></a>GEO地理位置</h4><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><h3 id="配置文件-Redis-conf"><a href="#配置文件-Redis-conf" class="headerlink" title="配置文件 Redis.conf"></a>配置文件 Redis.conf</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://souls5.github.io/2025/02/17/2025-02-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new_avatar.png">
      <meta itemprop="name" content="间">
      <meta itemprop="description" content="面向就业学习，Java相关技术栈、面试八股文和算法题中...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不是不是">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/17/2025-02-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/" class="post-title-link" itemprop="url">数据结构-数组相关算法题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-17 12:00:00" itemprop="dateCreated datePublished" datetime="2025-02-17T12:00:00+08:00">2025-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-04 14:07:57" itemprop="dateModified" datetime="2025-03-04T14:07:57+08:00">2025-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>归档用，每日刷题算法单独</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://programmercarl.com/">https://programmercarl.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="间"
      src="/images/new_avatar.png">
  <p class="site-author-name" itemprop="name">间</p>
  <div class="site-description" itemprop="description">面向就业学习，Java相关技术栈、面试八股文和算法题中...</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">间</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
